
Features to test:

x   Constructors w/ subcontracting
    --> pre > bases' pre > for x in [bases, class] ( static_inv (but not inv) > body > static_inv > inv > post )
    --> protected and private bases ALSO contract (because always part of C++ obj construction mechanism)
x   Constructor preconditions checked before member initialization list
x   Constructors have no `.precondition` (must use `constructor_precondition` instead)

x   Destructors subcontracting (w/ postconditions)
    --> for x in [class, reverse(bases)] ( static_inv > inv > body > static_inv (but not inv) > post )
    --> protected and private bases ALSO contract (because always part of C++ obj destructor mechanism)
x   Destructors have no `.precondition` (because destructors have no argument)

*   Private members check pre and post, but no cv/static invariants and no subcontracting
*   Private members above w/ bind

*   Protected members check pre and post, but no cv/static invariants and no subcontracting
*   Protected members above w/ bind

*   Static public members check pre, post, and static invariants, but no cv invariants and no subcontracting
*   Static public members above w/ bind

*   Public members subcontracting
    --> pre in logic-or
    --> post and inv in logic-and
    --> protected and private bases do not subcontract

x   Free functions pre and post (but obviously no cv/static invariants and no subcontracting)
x   Check (just for free functions, other contract use same set_... classes anyways) that:
    OK:     nothing | pre (only) | post (only) | pre > post | post > pre
    Error:  pre > pre | post > post | pre > post > pre | post > pre > post

x   Old values with/without subcontracting
    --> copied and evaluated only once by OLDOF
*   Result... by ref so never copied
*   Result as boost::optional... by ref so never copied
*   On body throw... for all contract types
*   Throw from contract (non-contract exception)
*   Failure handlers and throw on contract failure
*   Disable pre, post, and/or entry/exit inv (all combinations)
*   Contracts disabled while checking contracts...
*   Overloading for all contracts
*   Volatile inv
*   No static inv / const inv / volatile inv when static_inv / inv const / inv const volatile func not defined (for ctor, dtor, and pub member)
*   Derived public function override base protected virtual function (subst
    princ does not apply here because base protected virtual cannot be called
    by users so it cannot be "substituted")... what will this lib do?
*   add a test to disable/ similar to n1962/factial.cpp, where the contract
    recursively calls the function itself in the assertions
*   add a test for throwing exception handlers (somewhat similar to
    stroustrup97/string.cpp but but comprehensive)
*   see if MSVC 2013 resolves issues with call_if::else_([] { return true; })
    result type deduction, and also using lambdas within
    constructor_precondition
*   Volatile class invariants...
*   Check inv after C++11 move operations... documented pro/cons
*   Compiler-error if public_function<override...> does not find any function
    to actually override
*   Config macro to disable no assertion during preconditions (to avoid passing
    unchecked argument to function body)
*   Look at Andrzej's discussion on preconditions:
    https://akrzemi1.wordpress.com/2013/01/04/preconditions-part-i/
*   Can constructor/destructor body call a volatile member function? If so,
    they should also check volatile class invariant (currently they don't...)
*   If an overriding functions does not specify preconditions, make sure the
    overridden preconditions are checked (and not that subcontracted
    preconditions always pass just because the overriding function does not
    specify them)
*   Can I use unique_ptr instead of shared_ptr for old values, and maybe also
    for contract variables internal to the library, etc... ?
*   Test function and array argument types like
    `void f(int x[2][3], int (*g)(int))`
*   What shall I do with unions... can/shall I contract them? Check-out which
    members C++11 unions can have (ctors, dtor, etc.)
*   Make work the case a pure virtual uses boost::optional<T> result but an overriding function uses just T result, and the other way around too.

