<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>dbc/mfun.hpp File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>dbc/mfun.hpp File Reference</h1>Header file to only include facilities to write contracts using the macro-based API. <a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedbc.html">dbc</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mfun_8hpp.html#1c6dab06912180abfed3dc7f5b3006e3">DBC_BASE</a>(base_class_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This macro specifies the base class from which an overriding member function is subcontracting.  <a href="#1c6dab06912180abfed3dc7f5b3006e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mfun_8hpp.html#11cd5419adfe39cba4983b81dca63a71">DBC_CONSTRUCTOR</a>(signature, precondtions, postconditions, body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This macro must follow the constructor declaration matching the specified signature and it expands to the contract with the given preconditions, postconditions, and body.  <a href="#11cd5419adfe39cba4983b81dca63a71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mfun_8hpp.html#a8a977641739ad90988dccb3bac04a13">DBC_DESTRUCTOR</a>(signature, body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This macro must follow the destructor declaration matching the specified signature and it expands to the contract with the body.  <a href="#a8a977641739ad90988dccb3bac04a13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf">DBC_MEM_FUN</a>(signature, preconditions, postconditions, body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This macro must follow the member function declaration matching the specified signature and it expands to the contract with the given preconditions, postconditions, and body.  <a href="#2872f212b72c32e6254e34086e9714bf"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Header file to only include facilities to write contracts using the macro-based API. 
<p>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="1c6dab06912180abfed3dc7f5b3006e3"></a><!-- doxytag: member="mfun.hpp::DBC_BASE" ref="1c6dab06912180abfed3dc7f5b3006e3" args="(base_class_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DBC_BASE          </td>
          <td>(</td>
          <td class="paramtype">base_class_type&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This macro specifies the base class from which an overriding member function is subcontracting. 
<p>
This macro should only be used with the <em>signature</em> argument of the <code><a class="el" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN()</a></code> contract macro API. When the contract code API <code><a class="el" href="classdbc_1_1fun_1_1mem.html" title="Template used by the code-based API to specify contracts for functions members of...">dbc::fun::mem</a></code> is used, the <em>B</em> template parameter is used instead of this macro.<p>
The given base class must specify a contract for a virtual (or pure virtual) member function matching the name of the overriding function. Then the overriding function contract will subcontract from the one of base class function following the DBC <a class="el" href="Quick_Start.html#Member_Function_Call_Semantics">Member Function Call Semantics</a>. (Of course, the overriding function class type must inherit from the specified base class type as it would normally do in C++.)<p>
In the following example (from <code>"example/DBC_by_Example/NameList/names.hpp"</code>), <code>RelaxedNameList</code> inherits from <code>NameList</code>, and <code>RelaxedNameList::put()</code> subcontracts <code>NameList::put()</code>: <div class="fragment"><pre class="fragment"><span class="comment">/**</span>
<span class="comment"> * @file</span>
<span class="comment"> * @author Copyright (C) 2009 Lorenzo Caminiti.</span>
<span class="comment"> *  Distributed under DBC++ Software License (see file LICENSE_1_0.txt).</span>
<span class="comment"> */</span>
<span class="comment">/* $Id$ */</span>

<span class="preprocessor">#ifndef NAMES_HPP_</span>
<span class="preprocessor"></span><span class="preprocessor">#define NAMES_HPP_</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &lt;<a class="code" href="dbc_8hpp.html" title="Header file to include the entire Design By Contract for C++ library.">dbc.hpp</a>&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;list&gt;</span>
<span class="comment"></span>
<span class="comment">/** List of names. */</span>
<span class="keyword">class </span>NameList <a class="code" href="object_8hpp.html#126883cfec96cafb25d481c5b1e6df61" title="This macro must follow the class type name and it privately derives the class from...">DBC_INHERIT_OBJECT</a>(NameList) {
<span class="keyword">public</span>:
    <span class="comment">// Creation //</span>

    NameList()
    <a class="code" href="mfun_8hpp.html#11cd5419adfe39cba4983b81dca63a71" title="This macro must follow the constructor declaration matching the specified signature...">DBC_CONSTRUCTOR</a>( (public) (NameList)(), {
    }, {
    }, {})

    <span class="keyword">virtual</span> ~NameList()
    <a class="code" href="mfun_8hpp.html#a8a977641739ad90988dccb3bac04a13" title="This macro must follow the destructor declaration matching the specified signature...">DBC_DESTRUCTOR</a>( (public) (virtual) (NameList)(), {})

    <span class="comment">// Queries //</span>
<span class="comment"></span>
<span class="comment">    /** If specified name is in list. */</span>
    <span class="keywordtype">bool</span> has(<span class="keyword">const</span> std::string&amp; name) <span class="keyword">const</span>
    <a class="code" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN</a>( (<span class="keyword">public</span>) (<span class="keywordtype">bool</span>) (NameList) 
            (has)( (<span class="keyword">const</span> std::string&amp;)(name) ) (<span class="keyword">const</span>), {
    }, {
    }, ;)
<span class="comment"></span>
<span class="comment">    /** Return number of names in list. */</span>
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count() const
    <a class="code" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN</a>( (public) (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) (NameList) (count)() (const), {
    }, {
    }, ;)

    <span class="comment">// Commands //</span>
<span class="comment"></span>
<span class="comment">    /** Add specified name to list. */</span>
    <span class="keyword">virtual</span> <span class="keywordtype">void</span> put(<span class="keyword">const</span> std::string&amp; name)
    <a class="code" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN</a>( (<span class="keyword">public</span>) (<span class="keyword">virtual</span>) (<span class="keywordtype">void</span>) <a class="code" href="post_8hpp.html#b10fbb20732d114633c59fa07be8222a" title="This macro marks the specified type copyable so its value before the body execution...">DBC_COPYABLE</a>(NameList) 
            (put)( <a class="code" href="post_8hpp.html#b10fbb20732d114633c59fa07be8222a" title="This macro marks the specified type copyable so its value before the body execution...">DBC_COPYABLE</a>(<span class="keyword">const</span> std::string&amp;)(name) ), {
        <a class="code" href="assertion_8hpp.html#7f1678c1e2a86b6d044d8a90af6a81ff" title="Assert the specified condition allowing to indicate the action to take in case the...">DBC_ASSERT_STREAM</a>(!<span class="keyword">self</span>.has(name), <span class="stringliteral">"not in list"</span>,
                err &lt;&lt; <span class="stringliteral">"name '"</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">"' already in list"</span>);
    }, {
        <span class="comment">// required() is provided to facilitate writing post-condition guards</span>
        <span class="comment">// for more flexible contracts of virtual functions.</span>
        <span class="keywordflow">if</span> (required()) <span class="comment">// Or "if (!self.old.has(name.old))".</span>
            <a class="code" href="assertion_8hpp.html#7f1678c1e2a86b6d044d8a90af6a81ff" title="Assert the specified condition allowing to indicate the action to take in case the...">DBC_ASSERT_STREAM</a>(<span class="keyword">self</span>.now.has(name.now), 
                    <span class="stringliteral">"if require passed, in list"</span>,
                    err &lt;&lt; <span class="stringliteral">"name '"</span> &lt;&lt; name.now &lt;&lt; <span class="stringliteral">"' not in list"</span>);
        <span class="comment">// Because name's type is const, name.now could be used here instead of</span>
        <span class="comment">// name.old (saving to declare name's type as DBC_COPYABLE() and to </span>
        <span class="comment">// have to copy its value). However, technically "seld.old.has(</span>
        <span class="comment">// name.old)" is the expression equivalent to required().</span>
        <span class="keywordflow">if</span> (!<span class="keyword">self</span>.old.has(name.old))
            <a class="code" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT</a>(<span class="keyword">self</span>.now.count() == (<span class="keyword">self</span>.old.count() + 1),
                    <span class="stringliteral">"if was not in list, count increased"</span>);
    }, ;)

<span class="keyword">private</span>:
    std::list&lt;std::string&gt; names_;
    
    <a class="code" href="invariant_8hpp.html#fd939e7c1754a61a57c20bb7c6422ed4" title="This macro must be used within the class declaration and it specifies the invariants...">DBC_INVARIANT</a>(NameList, {})
};
<span class="comment"></span>
<span class="comment">/** List of names that allows for duplicates. */</span>
<span class="keyword">class </span>RelaxedNameList: <span class="keyword">public</span> NameList
        <a class="code" href="object_8hpp.html#64d183bdaf93713b7beb33fa120c27c9" title="This macro must follow the last base class type name and if privately derives the...">DBC_MULTI_INHERIT_OBJECT</a>(RelaxedNameList) {
<span class="keyword">public</span>:
    <span class="comment">// Creation //</span>

    RelaxedNameList()
    <a class="code" href="mfun_8hpp.html#11cd5419adfe39cba4983b81dca63a71" title="This macro must follow the constructor declaration matching the specified signature...">DBC_CONSTRUCTOR</a>( (public) (RelaxedNameList)(), {
    }, {
    }, {})

    <span class="keyword">virtual</span> ~RelaxedNameList()
    <a class="code" href="mfun_8hpp.html#a8a977641739ad90988dccb3bac04a13" title="This macro must follow the destructor declaration matching the specified signature...">DBC_DESTRUCTOR</a>( (public) (virtual) (RelaxedNameList)(), {})

    <span class="comment">// Commands //</span>

    <span class="keywordtype">void</span> put(<span class="keyword">const</span> std::string&amp; name)
    <a class="code" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN</a>( (<span class="keyword">public</span>) (<span class="keywordtype">void</span>) 
            <a class="code" href="post_8hpp.html#b10fbb20732d114633c59fa07be8222a" title="This macro marks the specified type copyable so its value before the body execution...">DBC_COPYABLE</a>(RelaxedNameList)<a class="code" href="mfun_8hpp.html#1c6dab06912180abfed3dc7f5b3006e3" title="This macro specifies the base class from which an overriding member function is subcontracting...">DBC_BASE</a>(NameList)
            (put)( <a class="code" href="post_8hpp.html#b10fbb20732d114633c59fa07be8222a" title="This macro marks the specified type copyable so its value before the body execution...">DBC_COPYABLE</a>(<span class="keyword">const</span> std::string&amp;)(name) ), {
        <a class="code" href="assertion_8hpp.html#7f1678c1e2a86b6d044d8a90af6a81ff" title="Assert the specified condition allowing to indicate the action to take in case the...">DBC_ASSERT_STREAM</a>(<span class="keyword">self</span>.has(name), <span class="stringliteral">"in list"</span>,
                err &lt;&lt; <span class="stringliteral">"name '"</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">"' not in list"</span>);
    }, {
        <span class="keywordflow">if</span> (<span class="keyword">self</span>.old.has(name.old))
            <a class="code" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT</a>(<span class="keyword">self</span>.now.count() == <span class="keyword">self</span>.old.count(),
                    <span class="stringliteral">"if in list, count unchanged"</span>);
    }, ;)
    
<span class="keyword">private</span>:
    <a class="code" href="invariant_8hpp.html#fd939e7c1754a61a57c20bb7c6422ed4" title="This macro must be used within the class declaration and it specifies the invariants...">DBC_INVARIANT</a>(RelaxedNameList, {})
};

<span class="preprocessor">#endif // NAMES_HPP_</span>
<span class="preprocessor"></span>
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base_class_type</em>&nbsp;</td><td>The base class type. This class must specify a contract for a virtual function with same name as the overriding function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Subcontract the overriding function from the function's contract in the specified base class. It is used in the <em>signature</em> argument of <code><a class="el" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN()</a></code>. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><em>B</em> template parameter of <code><a class="el" href="classdbc_1_1fun_1_1mem.html" title="Template used by the code-based API to specify contracts for functions members of...">dbc::fun::mem</a></code> for same functionality for contract code API. <p>
<code>"example/DBC_by_Example/Observer/"</code> for an example of subcontracting a pure virtual member function. <p>
<code>"example/DBC_by_Example/CustomerManager/"</code> for another subcontracting example. </dd></dl>

</div>
</div><p>
<a class="anchor" name="11cd5419adfe39cba4983b81dca63a71"></a><!-- doxytag: member="mfun.hpp::DBC_CONSTRUCTOR" ref="11cd5419adfe39cba4983b81dca63a71" args="(signature, precondtions, postconditions, body)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DBC_CONSTRUCTOR          </td>
          <td>(</td>
          <td class="paramtype">signature,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">precondtions,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">postconditions,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">body&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This macro must follow the constructor declaration matching the specified signature and it expands to the contract with the given preconditions, postconditions, and body. 
<p>
See the more extensive <code><a class="el" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN()</a></code> documentation as this documentation <em>complements</em> it for constructors.<p>
As a result of the code generated by this macro expansion, every call to the constructor follows the DBC <a class="el" href="Quick_Start.html#Constructor_Call_Semantics">Constructor Call Semantics</a> checking the constructor's contract. The contract specified by this macro is automatically documented.<p>
This macro can also follow special <em>initialization</em> member functions named <code>init()</code>. Being able to call such <code>init()</code> functions with the DBC <a class="el" href="Quick_Start.html#Constructor_Call_Semantics">Constructor Call Semantics</a> is necessary for the library when separating constructors declaration and definition to deal with member initializers (see <a class="el" href="Writing_Contracts.html#Separating_Declaration_and_Definition">Separating Declaration and Definition</a>), and also to support emulation of <em>delegating constructors</em>.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>In order to avoid the issues associated with two stage initialization (see [<a class="el" href="Bibliography.html#Str97">Str97</a>]), these <code>init()</code> functions should always be declared private and invoked only by constructors.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If delegating constructors were to be added to future C++ standard revisions (which seems to be the case [<a class="el" href="Bibliography.html#Sut05">Sut05</a>]), it may be possible to revisit this library to remove the reliance on the <code>init()</code> functions.</dd></dl>
For example (from <a class="el" href="Quick_Start.html#A_Complete_Example">A Complete Example</a>): <div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="dbc_8hpp.html" title="Header file to include the entire Design By Contract for C++ library.">dbc.hpp</a>&gt;</span>
 
  <span class="keyword">class </span>str <a class="code" href="object_8hpp.html#126883cfec96cafb25d481c5b1e6df61" title="This macro must follow the class type name and it privately derives the class from...">DBC_INHERIT_OBJECT</a>(str) {
  <span class="keyword">public</span>:
      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> MAX_SIZE = 16000;
  
      str(<span class="keyword">const</span> <span class="keywordtype">char</span>* chars): size_(), chars_() <span class="comment">// Constructor declaration.</span>
      <a class="code" href="mfun_8hpp.html#11cd5419adfe39cba4983b81dca63a71" title="This macro must follow the constructor declaration matching the specified signature...">DBC_CONSTRUCTOR</a>( (public) (str)( (const char*)(chars) ), {
          <span class="comment">// Constructor preconditions.</span>
          <span class="keywordtype">size_t</span> len = strlen(chars); <span class="comment">// Code allowed (but keep it simple).</span>
          <span class="comment">// Use DBC_ASSERT() or DBC_ASSERT_STREAM() to assert conditions.</span>
          <a class="code" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT</a>(len &gt;= 0 &amp;&amp; len &lt; str::MAX_SIZE, <span class="stringliteral">"size in range"</span>);
      }, {
          <span class="comment">// Constructor postconditions.</span>
          <a class="code" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT</a>(<span class="keyword">self</span>.now.size() == strlen(chars.now), <span class="stringliteral">"size set"</span>);
          <a class="code" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT</a>(strcmp(<span class="keyword">self</span>.now.chars_, chars.now) == 0, <span class="stringliteral">"chars set"</span>);
      }, {
          <span class="comment">// Constructor body.</span>
          size_ = strlen(chars);
          chars_ = <span class="keyword">new</span> <span class="keywordtype">char</span>[size_ + 1];
          strcpy(chars_, chars);
      })
      
  <span class="keyword">private</span>:
      <span class="keywordtype">size_t</span> size_;
      <span class="keywordtype">char</span>* chars_;
      ...
  };
</pre></div> Or, equivalently but separating constructor declaration and definition using the <code>init()</code> function: <dl compact><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Rework this example with actual copy constrcutor of str. </dd></dl>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="dbc_8hpp.html" title="Header file to include the entire Design By Contract for C++ library.">dbc.hpp</a>&gt;</span>
  
  <span class="keyword">class </span>str <a class="code" href="object_8hpp.html#126883cfec96cafb25d481c5b1e6df61" title="This macro must follow the class type name and it privately derives the class from...">DBC_INHERIT_OBJECT</a>(str) {
  <span class="keyword">public</span>:
      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> MAX_SIZE = 16000;
      
      <span class="comment">// Constructor deals with member initializers</span>
      str(<span class="keyword">const</span> <span class="keywordtype">char</span>* chars): size_(), chars_() { <span class="comment">// Member initializers...</span>
          <span class="comment">// ...then just call init (with DBC Constructor Call Semantics).</span>
          init(chars);
      }
      
  <span class="keyword">private</span>: <span class="comment">// init() should be private and invoked by constructor only.</span>
      <span class="comment">// DBC_CONSTRUCTOR can be used for special init functions.</span>
      <span class="keywordtype">void</span> init(<span class="keyword">const</span> <span class="keywordtype">char</span>* chars) <span class="comment">// Function declaration.</span>
      <a class="code" href="mfun_8hpp.html#11cd5419adfe39cba4983b81dca63a71" title="This macro must follow the constructor declaration matching the specified signature...">DBC_CONSTRUCTOR</a>( (<span class="keyword">public</span>) (str)( (<span class="keyword">const</span> <span class="keywordtype">char</span>*)(chars) ), {
          <span class="comment">// Constructor preconditions.</span>
          <span class="keywordtype">size_t</span> len = strlen(chars); <span class="comment">// Code allowed (but keep it simple).</span>
          <span class="comment">// Use DBC_ASSERT() or DBC_ASSERT_STREAM() to assert conditions.</span>
          <a class="code" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT</a>(len &gt;= 0 &amp;&amp; len &lt; str::MAX_SIZE, <span class="stringliteral">"size in range"</span>);
      }, {
          <span class="comment">// Constructor postconditions.</span>
          <a class="code" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT</a>(<span class="keyword">self</span>.now.size() == strlen(chars.now), <span class="stringliteral">"size set"</span>);
          <a class="code" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT</a>(strcmp(<span class="keyword">self</span>.now.chars_, chars.now) == 0, <span class="stringliteral">"chars set"</span>);
      }, ;) <span class="comment">// ';' separates declaration and definition.</span>
      
      <span class="keywordtype">size_t</span> size_;
      <span class="keywordtype">char</span>* chars_;
      ...
  };
  
  <span class="comment">// But member initializers are handled by constructor declaration.</span>
  <a class="code" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">str::DBC_BODY</a>(init)(<span class="keyword">const</span> <span class="keywordtype">char</span>* chars) { <span class="comment">// Definition.</span>
      <span class="comment">// Constructor body.</span>
      size_ = strlen(chars);
      chars_ = <span class="keyword">new</span> <span class="keywordtype">char</span>[size_ + 1];
      strcpy(chars_, chars);
  }
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>signature</em>&nbsp;</td><td>C++ preprocessor sequence of tokens matching the constructor declaration with the following syntax: <br>
 <br>
 <code> <em>{</em>(public) <em>||</em> (protected) <em>||</em> (private)<em>}</em> <em>[</em>(template)<em>]</em> (class_type)( <em>{[</em>DBC_COPYABLE<em>]</em>(argument_type)(argument_name)<em>}*</em> ) </code> <br>
 <br>
 Comparing this <em>signature</em> syntax with the one of <code><a class="el" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN()</a></code> note:<ul>
<li>The absence of <code>(virtual)</code> as constructors cannot be virtual.</li><li>The absence of <code>(result_type)</code> as constructors do not return any type.</li><li>The absence of <code>DBC_COPYABLE</code> for <code>class_type</code> as before the body execution there is no object so <code>self.old</code> is never available in postconditions.</li><li>The absence of <code><a class="el" href="mfun_8hpp.html#1c6dab06912180abfed3dc7f5b3006e3" title="This macro specifies the base class from which an overriding member function is subcontracting...">DBC_BASE(base_class_type)</a></code> as C++ will automatically call the base class constructor contract (if there is one) as part of the object construction mechanism, with no need for explicit subcontracting.</li><li>The absence of <code>function_name</code> as the constructor name is inferred from <code>class_type</code>.</li><li>The absence of <code>(const)</code> as constructors can never be constant member functions since they construct the object. </li></ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>preconditions</em>&nbsp;</td><td>A code block <code>{...}</code> listing the constructor preconditions. The following variables are available in this code block (see <code><a class="el" href="classdbc_1_1fun_1_1constr.html#407758982bebeb0dcc41d7e27e387415" title="The user must implement this function specifying the preconditions required by the...">dbc::fun::constr::require()</a></code>): <code>argument_name</code>. (<code>self</code> is not available because there is no object before the constructor body is executed.) <br>
 Limit this code to a simple list of assertions using <code><a class="el" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT()</a></code> and <code><a class="el" href="assertion_8hpp.html#7f1678c1e2a86b6d044d8a90af6a81ff" title="Assert the specified condition allowing to indicate the action to take in case the...">DBC_ASSERT_STREAM()</a></code>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>postconditions</em>&nbsp;</td><td>A code block <code>{...}</code> listing the constructor postconditions. The following variables are available in this code block (see <code><a class="el" href="classdbc_1_1fun_1_1constr.html#70dabbda7a03be65624fc93b72460c4c" title="The user must implement this function specifying the postconditions ensured by the...">dbc::fun::constr::ensure()</a></code>): <code>self.now</code>, <code>argument_name.now</code>, <code>argument_name.old</code> (if relative <code>argument_type</code> was declared copyable). (<code>self.old</code> is not available because there was no object before the constructor body execution, <code>result</code> is not available because constructors do not return any value.) <br>
 Limit this code to a simple list of assertions using <code><a class="el" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT()</a></code> and <code><a class="el" href="assertion_8hpp.html#7f1678c1e2a86b6d044d8a90af6a81ff" title="Assert the specified condition allowing to indicate the action to take in case the...">DBC_ASSERT_STREAM()</a></code>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>A code block <code>{...}</code> listing the constructor body definition. Use <code></code>; (and <code>init()</code>) when the function definition is separate from its declaration. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>This macro expands to the constructor contract. Preconditions, postconditions, and invariants optional compilation is controlled by the <code>DBC_CHECK_REQUIRE</code>, <code>DBC_CHECK_ENSURE</code>, and <code>DBC_CHECK_INVARIANT</code> compile-time symbols. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>Different macros <code><a class="el" href="mfun_8hpp.html#a8a977641739ad90988dccb3bac04a13" title="This macro must follow the destructor declaration matching the specified signature...">DBC_DESTRUCTOR()</a></code> and <code><a class="el" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN()</a></code> need to be used for destructor and member function contracts because of their different DBC call semantics. <p>
<code><a class="el" href="invariant_8hpp.html#fd939e7c1754a61a57c20bb7c6422ed4" title="This macro must be used within the class declaration and it specifies the invariants...">DBC_INVARIANT()</a></code> to specify class invariants. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a8a977641739ad90988dccb3bac04a13"></a><!-- doxytag: member="mfun.hpp::DBC_DESTRUCTOR" ref="a8a977641739ad90988dccb3bac04a13" args="(signature, body)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DBC_DESTRUCTOR          </td>
          <td>(</td>
          <td class="paramtype">signature,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">body&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This macro must follow the destructor declaration matching the specified signature and it expands to the contract with the body. 
<p>
See the more extensive <code><a class="el" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN()</a></code> documentation as this documentation <em>complements</em> it for destructors.<p>
As a result of the code generated by this macro expansion, every call to destructor follows the DBC Destructor Call Semantics checking the class invariant (destructors have no preconditions and postconditions). The contract specified by this macro is automatically documented.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The C++ Standard Template Library (STL) exception safety rules require destructors to never throw exceptions. To comply with this STL requirement, if the class invariant is violated while the destrcutor contract is checked, no exception will be thrown and <code><a class="el" href="namespacedbc.html#d6b88f4dab92db77200e6e2c2d41f662" title="The default handler called if destructor contract violation attempts to throw an...">dbc::broken_destructor_invariant()</a></code> will be invoked instead (this function can be redefined by the user, it terminates by default). Furthermore, if the destructor is invoked during stack unwinding due to an unhandled exception then an invariant violation while checking the destructor contract will simply be ignored (no exception will be thrown, <code><a class="el" href="namespacedbc.html#d6b88f4dab92db77200e6e2c2d41f662" title="The default handler called if destructor contract violation attempts to throw an...">dbc::broken_destructor_invariant()</a></code> will <em>not</em> be invoked, and only a warning message will be logged).</dd></dl>
For example (from <a class="el" href="Quick_Start.html#A_Complete_Example">A Complete Example</a>): <div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="dbc_8hpp.html" title="Header file to include the entire Design By Contract for C++ library.">dbc.hpp</a>&gt;</span>

<span class="keyword">class </span>str <a class="code" href="object_8hpp.html#126883cfec96cafb25d481c5b1e6df61" title="This macro must follow the class type name and it privately derives the class from...">DBC_INHERIT_OBJECT</a>(str) {
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> ~str() <span class="comment">// Destructor declaration.</span>
    <a class="code" href="mfun_8hpp.html#a8a977641739ad90988dccb3bac04a13" title="This macro must follow the destructor declaration matching the specified signature...">DBC_DESTRUCTOR</a>( (public) (virtual) (str)(), { <span class="comment">// No pre/post-conditions.</span>
        <span class="comment">// Destructor body (only check invariant at entry).</span>
        <span class="keyword">delete</span>[] chars_; <span class="comment">// Invariant already checked chars_ != 0.</span>
    })
    
<span class="keyword">private</span>:
    <span class="keywordtype">char</span>* chars_;
    ...
};
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>signature</em>&nbsp;</td><td>C++ preprocessor sequence of tokens matching the destructor declaration with the following syntax: <br>
 <br>
 <code> <em>{</em>(public) <em>||</em> (protected) <em>||</em> (private)<em>}</em> <em>[</em>(virtual)<em>]</em> <em>[</em>(template)<em>]</em> (class_type)() </code> <br>
 <br>
 Comparing this <em>signature</em> syntax with the one of <code><a class="el" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN()</a></code> note:<ul>
<li>The absence of <code>(result_type)</code> as destructors do not return any type.</li><li>The absence of <code>DBC_COPYABLE</code> for <code>class_type</code> as destructors have no postconditions.</li><li>The absence of <code><a class="el" href="mfun_8hpp.html#1c6dab06912180abfed3dc7f5b3006e3" title="This macro specifies the base class from which an overriding member function is subcontracting...">DBC_BASE(base_class_type)</a></code> as C++ will automatically call the base class destructor contract (if there is one) as part of the object destruction mechanism, with no need for explicit subcontracting.</li><li>The absence of <code>function_name</code> as the destructor name is inferred from <code>class_type</code>.</li><li>The absence of <code>argument_type</code> and <code>argument_name</code> as destructors have no arguments.</li><li>The absence of <code>(const)</code> as destructors can never be constant member functions since they destroy the object. </li></ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>A code block <code>{...}</code> listing the destructor body definition. Use <code></code>; (and <code><a class="el" href="body_8hpp.html#b2a724cce3b64ae6dc5d91c7f4ce8f26" title="This macro expands to the destructor body function name, it is used to separate the...">DBC_DESTRUCTOR_BODY()</a></code>) when function definition is separate from its declaration. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>This macro expands to the destructor contract. Invariants optional compilation is controlled by <code>DBC_CHECK_INVARIANT</code> compile-time symbol. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>Different macros <code><a class="el" href="mfun_8hpp.html#11cd5419adfe39cba4983b81dca63a71" title="This macro must follow the constructor declaration matching the specified signature...">DBC_CONSTRUCTOR()</a></code> and <code><a class="el" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN()</a></code> need to be used for constructor and member function contracts because of their different DBC call semantics. <p>
<code><a class="el" href="invariant_8hpp.html#fd939e7c1754a61a57c20bb7c6422ed4" title="This macro must be used within the class declaration and it specifies the invariants...">DBC_INVARIANT()</a></code> to specify class invariants. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2872f212b72c32e6254e34086e9714bf"></a><!-- doxytag: member="mfun.hpp::DBC_MEM_FUN" ref="2872f212b72c32e6254e34086e9714bf" args="(signature, preconditions, postconditions, body)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DBC_MEM_FUN          </td>
          <td>(</td>
          <td class="paramtype">signature,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">preconditions,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">postconditions,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">body&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This macro must follow the member function declaration matching the specified signature and it expands to the contract with the given preconditions, postconditions, and body. 
<p>
As a result of the code generated by this macro expansion, every call to the member function follows the DBC <a class="el" href="Quick_Start.html#Member_Function_Call_Semantics">Member Function Call Semantics</a> checking the function's contract. The contract specified by this macro is automatically documented (see Automatic_Contract_Documentation).<p>
For example (from <a class="el" href="Quick_Start.html#A_Complete_Example">A Complete Example</a>): <div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="dbc_8hpp.html" title="Header file to include the entire Design By Contract for C++ library.">dbc.hpp</a>&gt;</span>

<span class="keyword">class </span>str <a class="code" href="object_8hpp.html#126883cfec96cafb25d481c5b1e6df61" title="This macro must follow the class type name and it privately derives the class from...">DBC_INHERIT_OBJECT</a>(str) {
<span class="keyword">public</span>:
    <span class="comment">// No (virtual), (template), DBC_COPYABLE, DBC_BASE(...), and no args.</span>
    <span class="keywordtype">size_t</span> size() const <span class="comment">// Member function declaration.</span>
    <a class="code" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN</a>( (public) (<span class="keywordtype">size_t</span>) (str) (size)() (const), {
        <span class="comment">// Preconditions here (keep it simple).</span>
        <span class="comment">// No preconditions in this case.</span>
    }, {
        <span class="comment">// Postconditions here (keep it simple).</span>
        <a class="code" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT</a>(result == <span class="keyword">self</span>.now.size_, <span class="stringliteral">"returning size"</span>);
    }, {
        <span class="comment">// Body definition here.</span>
        <span class="keywordflow">return</span> size_;
    })

<span class="keyword">private</span>:
    <span class="keywordtype">size_t</span> size_;
    ...
};
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>signature</em>&nbsp;</td><td>A C++ preprocessor sequence of tokens (see <a class="el" href="Bibliography.html#Boost">Boost.Preprocessor</a> sequences) matching the member function declaration with the following syntax: <br>
 <br>
 <code> <em>{</em>(public) <em>||</em> (protected) <em>||</em> (private)<em>}</em> <em>[</em>(virtual)<em>]</em> (result_type) <em>[</em>(template)<em>] </em><em>[</em>DBC_COPYABLE<em>]</em>(class_type)<em>[</em><code><a class="el" href="mfun_8hpp.html#1c6dab06912180abfed3dc7f5b3006e3" title="This macro specifies the base class from which an overriding member function is subcontracting...">DBC_BASE(base_class_type)</a></code><em>]</em> (function_name)( <em>{[</em>DBC_COPYABLE<em>]</em>(argument_type)(argument_name)<em>}*</em> ) <em>[</em>(const)<em>]</em> </code> <br>
 <br>
 Where all parenthesis <code>()</code> are mandatory, spaces are optional, and: <ul>
<li><code><em>expression1 || expression2</em></code> indicates that either <code><em>expression1</code></em> or <code><em>expression2</code></em> can be specified. </li>
<li><code><em>{expression}</em></code> indicates the result of the enclosed <code><em>expression</code></em>. For example, <code><em>{</em>(public) <em>||</em> (protected) <em>||</em> (private)<em>}</em></code> indicates that either <code>(public)</code>, <code>(protected)</code>, or <code>(private)</code> can be specified. </li>
<li><code><em>[expression]</em></code> indicates that <code><em>expression</code></em> is optional. For example, <code><em>[</em>DBC_COPYABLE<em>]</em></code> indicates that either <code>DBC_COPYABLE</code> or nothing (no token) can be specified. </li>
<li><code><em>{expression}*</em></code> indicates that <code><em>expression</code></em> can be repeated an arbitrary number of times specifing different tokens or it can be omitted (i.e., it can be repeated 0, 1, 2, ... times). For example, <code>( <em>{</em>(argument_type) (argument_name)<em>}*</em> )</code> indicates that either <code>()</code> (repeated 0 times), or <code>( (argument0_type)(argument0_name) )</code> (repeated 1 time), or <code>( (argument0_type)(argument0_name) (argument1_type)(argument1_name) )</code> (repeated 2 times), etc can be specified. </li>
<li><code>result_type</code> is the member function return type. </li>
<li><code>class_type</code> is the member function class type. The class type must inherit (privately) from <a class="el" href="classdbc_1_1object.html" title="Any class with a contract must privately inherit from this base object class.">dbc::object</a> (see <code><a class="el" href="object_8hpp.html#126883cfec96cafb25d481c5b1e6df61" title="This macro must follow the class type name and it privately derives the class from...">DBC_INHERIT_OBJECT()</a></code>) and must have an invariant (see <code><a class="el" href="invariant_8hpp.html#fd939e7c1754a61a57c20bb7c6422ed4" title="This macro must be used within the class declaration and it specifies the invariants...">DBC_INVARIANT()</a></code>). </li>
<li><code>base_class_type</code> is the base class from which the member function is being derived using <code><a class="el" href="mfun_8hpp.html#1c6dab06912180abfed3dc7f5b3006e3" title="This macro specifies the base class from which an overriding member function is subcontracting...">DBC_BASE()</a></code> (only required when <a class="el" href="Writing_Contracts.html#Subcontracting">subcontracting</a>). </li>
<li><code>function_name</code> is the member function name. This must be a valid C++ preprocessor token name so operator symbols cannot be used; spell the operator name instead. For example, <code>operator==</code> cannot be used because the <code>==</code> symbol is not a valid preprocessor token name but you can use an arbitrary name (with no symbols) like <code>operator_equal</code> instead (when separating definitions from declaration, this same name has to be passed to <code><a class="el" href="body_8hpp.html#e057f8723886dbe188046aeea280e730" title="This macro expands to the operator body function name, it is used to separate the...">DBC_OPERATOR_BODY()</a></code>). </li>
<li><code>argument_type</code> is the argument type (can be omitted or repeated up to <code>DBC_CONFIG_MAX_ARGC - 1</code> times for multiple arguments). </li>
<li><code>argument_name</code> is the argument name (can be omitted or repeated up to <code>DBC_CONFIG_MAX_ARGC - 1</code> times for for multiple arguments).</li>
</ul>
The syntax of <em>signature</em> is defined to follow the C++ member function declaration syntax as much as possible (e.g., you first indicate the access level, then virtual, class follow by function names, then argument, etc). This way of expressing function signatures using C++ preprocessor token sequences might seems unfamiliar at first but, in our experience, you will quickly get used to it with a just little practice. The numerous examples distributed with the library illustrate how to use this syntax for templates, operators, virtual functions, etc (see the code in the <code>"example/"</code> directory). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>preconditions</em>&nbsp;</td><td>A code block <code>{...}</code> listing the member function preconditions. The following variables are available in this code block (see <code><a class="el" href="classdbc_1_1fun_1_1mem.html#24adf1f45e517092b99fa24084492ac1" title="The user must implement this function specifying the preconditions required by the...">dbc::fun::mem::require()</a></code>): <ul>
<li><code>self</code> is a constant reference <code>const&amp;</code> to the object (of type <code>class_type</code>). </li>
<li><code>argument_name</code> is a constant reference to the named argument.</li>
</ul>
<code><a class="el" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT()</a></code> and <code><a class="el" href="assertion_8hpp.html#7f1678c1e2a86b6d044d8a90af6a81ff" title="Assert the specified condition allowing to indicate the action to take in case the...">DBC_ASSERT_STREAM()</a></code> can be used to assert conditions in this code block. General code is allowed in this code block but it is strongly recommended to limit it to a <em>simple</em> list of assertions (otherwise it is likely that the contract will have more bugs than the code it is checking). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>postconditions</em>&nbsp;</td><td>A code block <code>{...}</code> listing the member function postconditions. The following variables are available in this code block (see <code><a class="el" href="classdbc_1_1fun_1_1mem.html#fc00820aeae815d42a40118f96cb7563" title="The user must implement this function specifying the postconditions ensured by the...">dbc::fun::mem::ensure()</a></code>): <ul>
<li><code>self.now</code> is a constant reference to the current object value (after the body execution). </li>
<li><code>self.old</code> is a constant reference to the object value before the body execution. This is available only if the class type was declared copyable in <em>signature</em> using <code><a class="el" href="post_8hpp.html#b10fbb20732d114633c59fa07be8222a" title="This macro marks the specified type copyable so its value before the body execution...">DBC_COPYABLE(class_type)</a></code>. </li>
<li><code>argument_name.now</code> is a constant reference to the named argument current value (after the body execution). </li>
<li><code>argument_name.old</code> is a constant reference to the named argument value before the body execution. This is available only if the relative argument type was declared copyable in <em>signature</em> using <code><a class="el" href="post_8hpp.html#b10fbb20732d114633c59fa07be8222a" title="This macro marks the specified type copyable so its value before the body execution...">DBC_COPYABLE(argument_type)</a></code>. </li>
<li><code>result</code> is a constant reference to the value being returned. This is available only for non-void functions (i.e., if <code>result_type</code> was not declared <code>void</code> in <em>signature</em>).</li>
</ul>
<code><a class="el" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT()</a></code> and <code><a class="el" href="assertion_8hpp.html#7f1678c1e2a86b6d044d8a90af6a81ff" title="Assert the specified condition allowing to indicate the action to take in case the...">DBC_ASSERT_STREAM()</a></code> can be used to assert conditions in this code block. General code is allowed in this code block but it is strongly recommended to limit it to a <em>simple</em> list of assertions (otherwise it is likely that the contract will have more bugs than the code it is checking). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>A code block <code>{...}</code> listing the member function body definition. Use <code></code>; (and <code><a class="el" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">DBC_BODY()</a></code>) when the function definition is separate from its declaration (see <a class="el" href="Writing_Contracts.html#Separating_Declaration_and_Definition">Separating Declartion and Definition</a>). Use <code>= 0;</code> for pure virtual functions (see <a class="el" href="Writing_Contracts.html#Subcontracting">Subcontracting</a>). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>This macro expands to the member function contract. If preconditions/postconditions are not checked (<code>DBC_CHECK_REQUIRE</code>/<code>DBC_CHECK_ENSURE</code> symbols are not defined at compile-time), the preconditions/postconditions code block will not be part of the macro expansion so it will not be compiled and checked. If no preconditions, no postconditions, and no invariants are checked (<code>DBC_CHECK_REQUIRE</code>, <code>DBC_CHECK_ENSURE</code>, and <code>DBC_CHECK_INVARIANT</code> are all not defined), this macro trivially expands to just the body code block and no contract code is compiled and checked. See <a class="el" href="Writing_Contracts.html#Optional_Contract_Compilation">Optional Contract Compilation</a>. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>Different macros <code><a class="el" href="mfun_8hpp.html#11cd5419adfe39cba4983b81dca63a71" title="This macro must follow the constructor declaration matching the specified signature...">DBC_CONSTRUCTOR()</a></code> and <code><a class="el" href="mfun_8hpp.html#a8a977641739ad90988dccb3bac04a13" title="This macro must follow the destructor declaration matching the specified signature...">DBC_DESTRUCTOR()</a></code> need to be used for constructor and destructor contracts because of their different DBC call semantics. <p>
<code><a class="el" href="invariant_8hpp.html#fd939e7c1754a61a57c20bb7c6422ed4" title="This macro must be used within the class declaration and it specifies the invariants...">DBC_INVARIANT()</a></code> to specify class invariants. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Jun 17 15:39:36 2009 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
