<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Annex: Known Bugs</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="bug">Annex: Known Bugs </a></h1>List of library known bugs.<p>
<ol type=1>
<li>I have seen GCC internal segfaul error if DBC_CONFIG_MAX_ARGC is more than 3 some some of the DBC++ test programs... I wonder is the compiler gets confused by fun&lt;...&gt; instead of fun0, fun1, ... (maybe the template specialization with partial default argument is not properly supported...). <br>
<br>
</li><li>When invoking parent's function directly from overriden function, must use <a class="el" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">DBC_BODY()</a> to avoid infinite recursive checking of contract. See NameList example. <div class="fragment"><pre class="fragment">    <span class="keyword">struct </span>B <a class="code" href="object_8hpp.html#126883cfec96cafb25d481c5b1e6df61" title="This macro must follow the class type name and it privately derives the class from...">DBC_INHERIT_OBJECT</a>(B) {
        <span class="keyword">virtual</span> <span class="keywordtype">void</span> f() <a class="code" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN</a>(..., {})
        ...
    };
    <span class="keyword">struct </span>D: <span class="keyword">public</span> B DBC_TRAILING_OJECT(D) {
        <span class="keyword">virtual</span> <span class="keywordtype">void</span> f() <a class="code" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN</a>(..., { <a class="code" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">B::DBC_BODY</a>(f)(); })
        <span class="comment">// This instead, will cause infinite contract checking recursion.</span>
        <span class="keyword">virtual</span> <span class="keywordtype">void</span> f() <a class="code" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN</a>(..., { B::f(); })
        ...
    };
</pre></div> <div class="fragment"><pre class="fragment">
Begin program:
#876 0x0804948c in main () at ./test/Subcontracting/class_subcontracts_class.cpp:7

Call to f(x) on an instance of derived:
#875 0x08050386 in derived::f (this=0xffd3bb38, x=@0xffd3bb4c) at ./test/Subcontracting/class_subcontracts_class.hpp:12

Check invariant
#874 0x0804ebca in dbc::fun&lt;int, int const&amp;, dbc::none_, dbc::none_&gt;::mem&lt;derived const, base::dbc_f_x&gt;::operator() (this=0xffd3bae4, self=@0xffd3bb38,
    body=&amp;virtual derived::dbc_body_f_(int const&amp;) const, arg0=@0xffd3bb4c, the_fun_name=@0xffd3baf8) at ./include/dbc/fun.hpp:228

Check requires contract:
#873 0x0804e93a in dbc::fun&lt;int, int const&amp;, dbc::none_, dbc::none_&gt;::mem&lt;derived const, base::dbc_f_x&gt;::call (this=0xffd3bae4, self=@0xffd3bb38,
    body=&amp;virtual derived::dbc_body_f_(int const&amp;) const, arg0=@0xffd3bb4c, the_fun_name=@0xffd3baf8, pre_invariant_check=@0xffd3ba97,
    require_check=@0xffd3ba96, post_invariant_check=@0xffd3ba95, ensure_check=@0xffd3ba94) at ./include/dbc/fun.hpp:465

Run actual body of DBC, which calls base's f(x):
#872 0x0804a1bc in derived::dbc_body_f_ (this=0xffd3bb38, x=@0xffd3bb4c) at ./test/Subcontracting/class_subcontracts_class.hpp:28

Call to f(x) on base class:
#871 0x0804a126 in base::f (this=0xffd3bb38, x=@0xffd3bb4c) at ./test/Subcontracting/base_class.hpp:11	

Check invariant (skips because it's nested):
#870 0x0804d5be in dbc::fun&lt;int, int const&amp;, dbc::none_, dbc::none_&gt;::mem&lt;base const, dbc::fun&lt;int, int const&amp;, dbc::none_, dbc::none_&gt;::no_base&lt;base const&gt; &gt;::operator() (this=0xffd3b844, self=@0xffd3bb38, body=&amp;virtual base::dbc_body_f_(int const&amp;) const, arg0=@0xffd3bb4c, the_fun_name=@0xffd3b858)
    at ./include/dbc/fun.hpp:228

Check requires on base:
#869 0x0804d32e in dbc::fun&lt;int, int const&amp;, dbc::none_, dbc::none_&gt;::mem&lt;base const, dbc::fun&lt;int, int const&amp;, dbc::none_, dbc::none_&gt;::no_base&lt;base const&gt; &gt;::call (this=0xffd3b844, self=@0xffd3bb38, body=&amp;virtual base::dbc_body_f_(int const&amp;) const, arg0=@0xffd3bb4c, the_fun_name=@0xffd3b858,
    pre_invariant_check=@0xffd3b7f7, require_check=@0xffd3b7f6, post_invariant_check=@0xffd3b7f5, ensure_check=@0xffd3b7f4) at ./include/dbc/fun.hpp:465

PROBLEM: base's f(x) is defined as: { return dbc_f_x()(*this, &amp;base::DBC_BODY(f), x, "f"); } - but since dbc_f_x() is getting a reference to the function, it follows the
trail of virtual inheritance and actually calls derived's f(x):
#868 0x0804a1bc in derived::dbc_body_f_ (this=0xffd3bb38, x=@0xffd3bb4c) at ./test/Subcontracting/class_subcontracts_class.hpp:28	

We ran derived's body, so now we're back at base and the recursion begins:
#867 0x0804a126 in base::f (this=0xffd3bb38, x=@0xffd3bb4c) at ./test/Subcontracting/base_class.hpp:11
</pre></div> This is quite annoying as a small developper error in omitting <a class="el" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">DBC_BODY()</a> in this context will result in a infinite recursion a run-time!!! Can I avoid this somehow??? Can I check it a compile-time? Can I make it work even if calling w/out <a class="el" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">DBC_BODY()</a>? Also, what happens if the body function is not declared virtual but only the actual function is declared virtual? More in general than above todo, how shall DbC handle recursion? Shall contract checking always be disabled when a function recursively invokes itself? Maybe not, since it might invoke itself w/ different arguments and w/ obj in a different state (is it is not a const mem fun)... What is Eiffel policy on DbC and recursion? <br>
<br>
</li><li>When constrcutor contract is delegated to init() initializer, the contract does not show up in Doxygen... that is because constr (which are public) have no contract, while init() has the contract but it is private... is there a way around this? Since Doxygen reports the header files, the contract code (for init() also) is in the reported header but that's not ideal... It'd be nice if I could say in the Doxyfile to report init() (and del()) doc even if they are private... <br>
<br>
</li><li>Investigate limitation when subcontracting with multiple inheritance from base templates with same variable name (as its type depends on template param). This currently requires either direct use of <a class="el" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">DBC_BODY()</a> (which prevents further subcontracting) or use of code API... but macro APIs fail. </li></ol>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Nov 21 11:16:02 2009 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
