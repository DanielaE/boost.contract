<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>dbc::fun&lt; R, A0, A1, &gt;::destr&lt; C &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacedbc.html">dbc</a>::<a class="el" href="classdbc_1_1fun.html">fun</a>::<a class="el" href="classdbc_1_1fun_1_1destr.html">destr</a>
  </div>
</div>
<div class="contents">
<h1>dbc::fun&lt; R, A0, A1, &gt;::destr&lt; C &gt; Class Template Reference</h1><!-- doxytag: class="dbc::fun::destr" -->Template used by the code-based API to specify contracts for the destructor of the given class.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;fun.hpp&gt;</code>
<p>

<p>
<a href="classdbc_1_1fun_1_1destr-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classdbc_1_1fun_1_1destr.html">destr</a>&lt; C &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1destr.html#75f54e05fcd1beff2b46acfd8278129f">this_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type resulting from this template instantiation.  <a href="#75f54e05fcd1beff2b46acfd8278129f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
remove_copyable_const_ref_&lt; C &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1destr.html#58bc700f36164a52bb11bcdb29d1bf2e">basic_class_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class ype without <code>const</code>, <code>&amp;</code>, and <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code>.  <a href="#58bc700f36164a52bb11bcdb29d1bf2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef remove_const_ref_&lt; C &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1destr.html#11602ec86e6137a980793329cadcef92">copyable_class_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class type without <code>const</code> and <code>&amp;</code> qualifiers.  <a href="#11602ec86e6137a980793329cadcef92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef remove_copyable_ref_&lt; C &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1destr.html#6606fb62bfa2b6a5460f0d5b98f8ffe6">uncopyable_class_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class type without <code>&amp;</code> and <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code> qualifiers.  <a href="#6606fb62bfa2b6a5460f0d5b98f8ffe6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(uncopyable_class_type::*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1destr.html#8df3018ccfe1145e06ab9ad791476bcd">mem_fun_type</a> )()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Member function pointer type.  <a href="#8df3018ccfe1145e06ab9ad791476bcd"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1destr.html#a7e80dd0f5e602ebf589bb03de5e0905">call</a> (<a class="el" href="classdbc_1_1fun_1_1destr.html#6606fb62bfa2b6a5460f0d5b98f8ffe6">uncopyable_class_type</a> &amp;self, <a class="el" href="classdbc_1_1fun_1_1destr.html#8df3018ccfe1145e06ab9ad791476bcd">mem_fun_type</a> body, const std::string &amp;name=&quot;&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check this contract and execute the specified body accordingly to the <a class="el" href="Quick_Start.html#Destructor_Call_Semantics">DBC Destructor Call Semantics</a>.  <a href="#a7e80dd0f5e602ebf589bb03de5e0905"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename R, typename A0 = none_, typename A1 = none_, ...&gt;<br>
template&lt;class C&gt;<br>
 class dbc::fun&lt; R, A0, A1, &gt;::destr&lt; C &gt;</h3>

Template used by the code-based API to specify contracts for the destructor of the given class. 
<p>
This template is present only if <em>R</em> is <code>void</code> and no argument type <em>A0</em>, <em>A1</em>, ... is specified because destructors have no return value and no argument.<p>
Destructor contracts have no preconditions or postconditions so this class does not declares the <code>require()</code> and <code>ensure()</code> pure virtual functions.<p>
There is no base contract parameter <em>B</em> as destructor do not subcontract directly (the base class destructor contract is implicitly checked by C++ destruction mechanism). <dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>C</em>&nbsp;</td><td>Class of which the contracted destructor is member of. This type cannot be specified <a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">copyable</a> via <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code> because destructors do not check postconditions. This class type <em>C</em> must privately inherit from <code>dbc::object&lt;C&gt;</code> (see <code><a class="el" href="object_8hpp.html#126883cfec96cafb25d481c5b1e6df61" title="This macro must follow the class type name and it privately derives the class from...">DBC_INHERIT_OBJECT()</a></code>) and it must specify invariants (see <code><a class="el" href="invariant_8hpp.html#fd939e7c1754a61a57c20bb7c6422ed4" title="This macro must be used within the class declaration and it specifies the invariants...">DBC_INVARIANT()</a></code>). </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>See <a class="el" href="classdbc_1_1fun_1_1mem.html" title="Template used by the code-based API to specify contracts for functions members of...">dbc::fun::mem</a> for more detailed documentation for member function contracts. <p>
<a class="el" href="Writing_Contracts.html#Code_Based_API">Code-Based API</a> for an example. </dd></dl>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="75f54e05fcd1beff2b46acfd8278129f"></a><!-- doxytag: member="dbc::fun::destr::this_type" ref="75f54e05fcd1beff2b46acfd8278129f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename A0 = none_, typename A1 = none_, ... &gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classdbc_1_1fun_1_1destr.html">destr</a>&lt;C&gt; <a class="el" href="classdbc_1_1fun.html">dbc::fun</a>&lt; R, A0, A1, &gt;::<a class="el" href="classdbc_1_1fun_1_1destr.html">destr</a>&lt; C &gt;::<a class="el" href="classdbc_1_1fun_1_1destr.html">this_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type resulting from this template instantiation. 
<p>

</div>
</div><p>
<a class="anchor" name="58bc700f36164a52bb11bcdb29d1bf2e"></a><!-- doxytag: member="dbc::fun::destr::basic_class_type" ref="58bc700f36164a52bb11bcdb29d1bf2e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename A0 = none_, typename A1 = none_, ... &gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef remove_copyable_const_ref_&lt;C&gt; <a class="el" href="classdbc_1_1fun.html">dbc::fun</a>&lt; R, A0, A1, &gt;::<a class="el" href="classdbc_1_1fun_1_1destr.html">destr</a>&lt; C &gt;::<a class="el" href="classdbc_1_1fun_1_1destr.html#58bc700f36164a52bb11bcdb29d1bf2e">basic_class_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Class ype without <code>const</code>, <code>&amp;</code>, and <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code>. 
<p>

</div>
</div><p>
<a class="anchor" name="11602ec86e6137a980793329cadcef92"></a><!-- doxytag: member="dbc::fun::destr::copyable_class_type" ref="11602ec86e6137a980793329cadcef92" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename A0 = none_, typename A1 = none_, ... &gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef remove_const_ref_&lt;C&gt; <a class="el" href="classdbc_1_1fun.html">dbc::fun</a>&lt; R, A0, A1, &gt;::<a class="el" href="classdbc_1_1fun_1_1destr.html">destr</a>&lt; C &gt;::<a class="el" href="classdbc_1_1fun_1_1destr.html#11602ec86e6137a980793329cadcef92">copyable_class_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Class type without <code>const</code> and <code>&amp;</code> qualifiers. 
<p>

</div>
</div><p>
<a class="anchor" name="6606fb62bfa2b6a5460f0d5b98f8ffe6"></a><!-- doxytag: member="dbc::fun::destr::uncopyable_class_type" ref="6606fb62bfa2b6a5460f0d5b98f8ffe6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename A0 = none_, typename A1 = none_, ... &gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef remove_copyable_ref_&lt;C&gt; <a class="el" href="classdbc_1_1fun.html">dbc::fun</a>&lt; R, A0, A1, &gt;::<a class="el" href="classdbc_1_1fun_1_1destr.html">destr</a>&lt; C &gt;::<a class="el" href="classdbc_1_1fun_1_1destr.html#6606fb62bfa2b6a5460f0d5b98f8ffe6">uncopyable_class_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Class type without <code>&amp;</code> and <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code> qualifiers. 
<p>

</div>
</div><p>
<a class="anchor" name="8df3018ccfe1145e06ab9ad791476bcd"></a><!-- doxytag: member="dbc::fun::destr::mem_fun_type" ref="8df3018ccfe1145e06ab9ad791476bcd" args=")()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename A0 = none_, typename A1 = none_, ... &gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef void(uncopyable_class_type::*  <a class="el" href="classdbc_1_1fun.html">dbc::fun</a>&lt; R, A0, A1, &gt;::<a class="el" href="classdbc_1_1fun_1_1destr.html">destr</a>&lt; C &gt;::<a class="el" href="classdbc_1_1fun_1_1destr.html#8df3018ccfe1145e06ab9ad791476bcd">mem_fun_type</a>)()          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Member function pointer type. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a7e80dd0f5e602ebf589bb03de5e0905"></a><!-- doxytag: member="dbc::fun::destr::call" ref="a7e80dd0f5e602ebf589bb03de5e0905" args="(uncopyable_class_type &amp;self, mem_fun_type body, const std::string &amp;name=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename A0 = none_, typename A1 = none_, ... &gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdbc_1_1fun.html">dbc::fun</a>&lt; R, A0, A1, &gt;::<a class="el" href="classdbc_1_1fun_1_1destr.html">destr</a>&lt; C &gt;::call           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdbc_1_1fun_1_1destr.html#6606fb62bfa2b6a5460f0d5b98f8ffe6">uncopyable_class_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdbc_1_1fun_1_1destr.html#8df3018ccfe1145e06ab9ad791476bcd">mem_fun_type</a>&nbsp;</td>
          <td class="paramname"> <em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check this contract and execute the specified body accordingly to the <a class="el" href="Quick_Start.html#Destructor_Call_Semantics">DBC Destructor Call Semantics</a>. 
<p>
This call will only throw if the body throws. The body is specified by the user and to comply with C++ STL it should not throw (but it is up to the user to full fill the STL requirement or not). However, if the contract fails during this call, no exception will be thrown and <code><a class="el" href="namespacedbc.html#d6b88f4dab92db77200e6e2c2d41f662" title="The default handler called if destructor contract violation attempts to throw an...">dbc::broken_destructor_invariant()</a></code> will be called instead (or the user's defined handler for this condition, see <code><a class="el" href="namespacedbc.html#a94307ba6289b29ef1d36bcfcd400498" title="Register user defined function to handle attempt to throw exception on destructor...">dbc::set_broken_destructor_invariant()</a></code>). Therefore, this libray comply with C++ STL exception safety requirements.<p>
In addition, if this function is called when calling the destructor during stack unwinding while there is an unhandled exception, this call will simply log a message in case of contract failure. (This is necessary because the class contract does not need to hold if the system is already in a failure status because of an unhandled exception.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td>A reference to the <a class="el" href="classdbc_1_1object.html" title="Any class with a contract must privately inherit from this base object class.">object</a> (use <code>*this</code> from the contracted destructor). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>A pointer to function implementing the body. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>The function name (optional, used for log messages). </td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>There is no function argument type because destructors take no argument. <p>
This call returns <code>void</code> because destructors return no value. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>dbc/<a class="el" href="fun_8hpp.html">fun.hpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Nov 21 11:16:02 2009 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
