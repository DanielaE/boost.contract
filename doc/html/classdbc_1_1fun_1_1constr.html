<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>dbc::fun&lt; R, A0, A1, &gt;::constr&lt; C &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacedbc.html">dbc</a>::<a class="el" href="classdbc_1_1fun.html">fun</a>::<a class="el" href="classdbc_1_1fun_1_1constr.html">constr</a>
  </div>
</div>
<div class="contents">
<h1>dbc::fun&lt; R, A0, A1, &gt;::constr&lt; C &gt; Class Template Reference</h1><!-- doxytag: class="dbc::fun::constr" -->Template used by the code-based API to specify contracts for constructors of the given class.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;fun.hpp&gt;</code>
<p>

<p>
<a href="classdbc_1_1fun_1_1constr-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classdbc_1_1fun_1_1constr.html">constr</a>&lt; C &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1constr.html#5071ea1faffa69238f67c1d011f1bb78">this_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type resulting from this template instantiation.  <a href="#5071ea1faffa69238f67c1d011f1bb78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
remove_copyable_const_ref_&lt; C &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1constr.html#b10a7b659fe568ba2c09847b1bfa1c2a">basic_class_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class ype without <code>const</code>, <code>&amp;</code>, and <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code>.  <a href="#b10a7b659fe568ba2c09847b1bfa1c2a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef remove_const_ref_&lt; C &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1constr.html#c90d7b69c82c18b30ede5ea20fda8006">copyable_class_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class type without <code>const</code> and <code>&amp;</code> qualifiers.  <a href="#c90d7b69c82c18b30ede5ea20fda8006"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef remove_copyable_ref_&lt; C &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1constr.html#5ddcf15b0cb441aff74f239628bf7a64">uncopyable_class_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class type without <code>&amp;</code> and <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code> qualifiers.  <a href="#5ddcf15b0cb441aff74f239628bf7a64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(uncopyable_class_type::*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1constr.html#fdbe73768438bb6458a691894998195c">mem_fun_type</a> )(uncopyable_arg1_type, uncopyable_arg1_type,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Member function pointer type.  <a href="#fdbe73768438bb6458a691894998195c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1constr.html#523d7b8a24b7689f2e288dd850dee23f">call</a> (<a class="el" href="classdbc_1_1fun_1_1constr.html#5ddcf15b0cb441aff74f239628bf7a64">uncopyable_class_type</a> &amp;self, <a class="el" href="classdbc_1_1fun_1_1constr.html#fdbe73768438bb6458a691894998195c">mem_fun_type</a> body, <a class="el" href="classdbc_1_1fun.html#e9d5c76bfcc289385d827bd293b1ff59">uncopyable_arg0_type</a> arg0, <a class="el" href="classdbc_1_1fun.html#e9d5c76bfcc289385d827bd293b1ff59">uncopyable_arg0_type</a> arg1,..., const std::string &amp;name=&quot;&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check this contract and execute the specified body accordingly to the <a class="el" href="Quick_Start.html#Constructor_Call_Semantics">DBC Constructor Call Semantics</a>.  <a href="#523d7b8a24b7689f2e288dd850dee23f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1constr.html#407758982bebeb0dcc41d7e27e387415">require</a> (const <a class="el" href="classdbc_1_1fun.html#ebf252ec04b04ddc780c8b4d283e959e">basic_arg0_type</a> &amp;arg0, const basic_arg1_type &amp;arg1,...)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The user must implement this function specifying the <em>preconditions</em> required by the constructor contract.  <a href="#407758982bebeb0dcc41d7e27e387415"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1constr.html#70dabbda7a03be65624fc93b72460c4c">ensure</a> (const <a class="el" href="classdbc_1_1post.html">post</a>&lt; <a class="el" href="classdbc_1_1fun_1_1constr.html#c90d7b69c82c18b30ede5ea20fda8006">copyable_class_type</a> &gt; &amp;self, const <a class="el" href="classdbc_1_1post.html">post</a>&lt; <a class="el" href="classdbc_1_1fun.html#9a83e31b04c23152aa8ba6e7cb59f024">copyable_arg0_type</a> &gt; &amp;arg0, const <a class="el" href="classdbc_1_1post.html">post</a>&lt; copyable_arg1_type &gt; &amp;arg1,...)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The user must implement this function specifying the <em>postconditions</em> ensured by the constructor contract.  <a href="#70dabbda7a03be65624fc93b72460c4c"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename R, typename A0 = none_, typename A1 = none_, ...&gt;<br>
template&lt;class C&gt;<br>
 class dbc::fun&lt; R, A0, A1, &gt;::constr&lt; C &gt;</h3>

Template used by the code-based API to specify contracts for constructors of the given class. 
<p>
The contracted constructor must be for the class <em>C</em>, and argument types <em>A0</em>, <em>A1</em>, ... .<p>
This template is present only if <em>R</em> is <code>void</code> because constructors do not return a value.<p>
There is no base contract parameter <em>B</em> as constructor do not subcontract directly (the base class constructor contract is implicitly checked by C++ construction mechanism). <dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>C</em>&nbsp;</td><td>Class of which the contracted constructor is member of. This type cannot be specified <a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">copyable</a> via <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code> because there is no <a class="el" href="classdbc_1_1object.html" title="Any class with a contract must privately inherit from this base object class.">object</a> before constructor body execution so the "old" postfix is never available in constructor postconditions. This class type <em>C</em> must privately inherit from <code>dbc::object&lt;C&gt;</code> (see <code><a class="el" href="object_8hpp.html#126883cfec96cafb25d481c5b1e6df61" title="This macro must follow the class type name and it privately derives the class from...">DBC_INHERIT_OBJECT()</a></code>) and it must specify invariants (see <code><a class="el" href="invariant_8hpp.html#fd939e7c1754a61a57c20bb7c6422ed4" title="This macro must be used within the class declaration and it specifies the invariants...">DBC_INVARIANT()</a></code>). </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>See <a class="el" href="classdbc_1_1fun_1_1mem.html" title="Template used by the code-based API to specify contracts for functions members of...">dbc::fun::mem</a> for more detailed documentation for member function contracts. <p>
<a class="el" href="Writing_Contracts.html#Code_Based_API">Code-Based API</a> for an example. </dd></dl>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="5071ea1faffa69238f67c1d011f1bb78"></a><!-- doxytag: member="dbc::fun::constr::this_type" ref="5071ea1faffa69238f67c1d011f1bb78" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename A0 = none_, typename A1 = none_, ... &gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classdbc_1_1fun_1_1constr.html">constr</a>&lt;C&gt; <a class="el" href="classdbc_1_1fun.html">dbc::fun</a>&lt; R, A0, A1, &gt;::<a class="el" href="classdbc_1_1fun_1_1constr.html">constr</a>&lt; C &gt;::<a class="el" href="classdbc_1_1fun_1_1constr.html">this_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type resulting from this template instantiation. 
<p>

</div>
</div><p>
<a class="anchor" name="b10a7b659fe568ba2c09847b1bfa1c2a"></a><!-- doxytag: member="dbc::fun::constr::basic_class_type" ref="b10a7b659fe568ba2c09847b1bfa1c2a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename A0 = none_, typename A1 = none_, ... &gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef remove_copyable_const_ref_&lt;C&gt; <a class="el" href="classdbc_1_1fun.html">dbc::fun</a>&lt; R, A0, A1, &gt;::<a class="el" href="classdbc_1_1fun_1_1constr.html">constr</a>&lt; C &gt;::<a class="el" href="classdbc_1_1fun_1_1constr.html#b10a7b659fe568ba2c09847b1bfa1c2a">basic_class_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Class ype without <code>const</code>, <code>&amp;</code>, and <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code>. 
<p>

</div>
</div><p>
<a class="anchor" name="c90d7b69c82c18b30ede5ea20fda8006"></a><!-- doxytag: member="dbc::fun::constr::copyable_class_type" ref="c90d7b69c82c18b30ede5ea20fda8006" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename A0 = none_, typename A1 = none_, ... &gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef remove_const_ref_&lt;C&gt; <a class="el" href="classdbc_1_1fun.html">dbc::fun</a>&lt; R, A0, A1, &gt;::<a class="el" href="classdbc_1_1fun_1_1constr.html">constr</a>&lt; C &gt;::<a class="el" href="classdbc_1_1fun_1_1constr.html#c90d7b69c82c18b30ede5ea20fda8006">copyable_class_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Class type without <code>const</code> and <code>&amp;</code> qualifiers. 
<p>

</div>
</div><p>
<a class="anchor" name="5ddcf15b0cb441aff74f239628bf7a64"></a><!-- doxytag: member="dbc::fun::constr::uncopyable_class_type" ref="5ddcf15b0cb441aff74f239628bf7a64" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename A0 = none_, typename A1 = none_, ... &gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef remove_copyable_ref_&lt;C&gt; <a class="el" href="classdbc_1_1fun.html">dbc::fun</a>&lt; R, A0, A1, &gt;::<a class="el" href="classdbc_1_1fun_1_1constr.html">constr</a>&lt; C &gt;::<a class="el" href="classdbc_1_1fun_1_1constr.html#5ddcf15b0cb441aff74f239628bf7a64">uncopyable_class_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Class type without <code>&amp;</code> and <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code> qualifiers. 
<p>

</div>
</div><p>
<a class="anchor" name="fdbe73768438bb6458a691894998195c"></a><!-- doxytag: member="dbc::fun::constr::mem_fun_type" ref="fdbe73768438bb6458a691894998195c" args=")(uncopyable_arg1_type, uncopyable_arg1_type,...)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename A0 = none_, typename A1 = none_, ... &gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef void(uncopyable_class_type::*  <a class="el" href="classdbc_1_1fun.html">dbc::fun</a>&lt; R, A0, A1, &gt;::<a class="el" href="classdbc_1_1fun_1_1constr.html">constr</a>&lt; C &gt;::<a class="el" href="classdbc_1_1fun_1_1constr.html#fdbe73768438bb6458a691894998195c">mem_fun_type</a>)(uncopyable_arg1_type, uncopyable_arg1_type,...)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Member function pointer type. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="523d7b8a24b7689f2e288dd850dee23f"></a><!-- doxytag: member="dbc::fun::constr::call" ref="523d7b8a24b7689f2e288dd850dee23f" args="(uncopyable_class_type &amp;self, mem_fun_type body, uncopyable_arg0_type arg0, uncopyable_arg0_type arg1,..., const std::string &amp;name=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename A0 = none_, typename A1 = none_, ... &gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdbc_1_1fun.html">dbc::fun</a>&lt; R, A0, A1, &gt;::<a class="el" href="classdbc_1_1fun_1_1constr.html">constr</a>&lt; C &gt;::call           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdbc_1_1fun_1_1constr.html#5ddcf15b0cb441aff74f239628bf7a64">uncopyable_class_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdbc_1_1fun_1_1constr.html#fdbe73768438bb6458a691894998195c">mem_fun_type</a>&nbsp;</td>
          <td class="paramname"> <em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdbc_1_1fun.html#e9d5c76bfcc289385d827bd293b1ff59">uncopyable_arg0_type</a>&nbsp;</td>
          <td class="paramname"> <em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdbc_1_1fun.html#e9d5c76bfcc289385d827bd293b1ff59">uncopyable_arg0_type</a>&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check this contract and execute the specified body accordingly to the <a class="el" href="Quick_Start.html#Constructor_Call_Semantics">DBC Constructor Call Semantics</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td>A reference to the <a class="el" href="classdbc_1_1object.html" title="Any class with a contract must privately inherit from this base object class.">object</a> (use <code>*this</code> from the contracted constructor). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>A pointer to function implementing the body. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg0,arg1,...</em>&nbsp;</td><td>The function arguments. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>The function name (optional, used for log messages). </td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This call return type is <code>void</code> because constructors return no value. </dd></dl>

</div>
</div><p>
<a class="anchor" name="407758982bebeb0dcc41d7e27e387415"></a><!-- doxytag: member="dbc::fun::constr::require" ref="407758982bebeb0dcc41d7e27e387415" args="(const basic_arg0_type &amp;arg0, const basic_arg1_type &amp;arg1,...)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename A0 = none_, typename A1 = none_, ... &gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdbc_1_1fun.html">dbc::fun</a>&lt; R, A0, A1, &gt;::<a class="el" href="classdbc_1_1fun_1_1constr.html">constr</a>&lt; C &gt;::require           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdbc_1_1fun.html#ebf252ec04b04ddc780c8b4d283e959e">basic_arg0_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const basic_arg1_type &amp;&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The user must implement this function specifying the <em>preconditions</em> required by the constructor contract. 
<p>
If the contract does not require any precondition, simply implement this pure virtual function as <code>{}</code>. All these arguments are constant references so the contract cannot modify the argument values by mistake. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg0,arg1,...</em>&nbsp;</td><td>Constant references to the argument values (present only if <em>A0</em>, <em>A1</em>, ... have been specified). </td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>There is no <code>self</code> argument as there is no <a class="el" href="classdbc_1_1object.html" title="Any class with a contract must privately inherit from this base object class.">object</a> before constructor body execution so the preconditions cannot access any <a class="el" href="classdbc_1_1object.html" title="Any class with a contract must privately inherit from this base object class.">object</a> value. </dd></dl>

</div>
</div><p>
<a class="anchor" name="70dabbda7a03be65624fc93b72460c4c"></a><!-- doxytag: member="dbc::fun::constr::ensure" ref="70dabbda7a03be65624fc93b72460c4c" args="(const post&lt; copyable_class_type &gt; &amp;self, const post&lt; copyable_arg0_type &gt; &amp;arg0, const post&lt; copyable_arg1_type &gt; &amp;arg1,...)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename A0 = none_, typename A1 = none_, ... &gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdbc_1_1fun.html">dbc::fun</a>&lt; R, A0, A1, &gt;::<a class="el" href="classdbc_1_1fun_1_1constr.html">constr</a>&lt; C &gt;::ensure           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdbc_1_1post.html">post</a>&lt; <a class="el" href="classdbc_1_1fun_1_1constr.html#c90d7b69c82c18b30ede5ea20fda8006">copyable_class_type</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdbc_1_1post.html">post</a>&lt; <a class="el" href="classdbc_1_1fun.html#9a83e31b04c23152aa8ba6e7cb59f024">copyable_arg0_type</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdbc_1_1post.html">post</a>&lt; copyable_arg1_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The user must implement this function specifying the <em>postconditions</em> ensured by the constructor contract. 
<p>
If the contract does not ensure any postcondition, simply implement this pure virtual function as <code>{}</code>. All these arguments are constant references so the contract cannot modify the <a class="el" href="classdbc_1_1object.html" title="Any class with a contract must privately inherit from this base object class.">object</a>, and argument values by mistake. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>self</em>&nbsp;</td><td>Constant reference to the <a class="el" href="classdbc_1_1object.html" title="Any class with a contract must privately inherit from this base object class.">object</a> <em>post-value</em>. This post-value only allows to access the current <a class="el" href="classdbc_1_1object.html" title="Any class with a contract must privately inherit from this base object class.">object</a> value (after the body execution) via <code>self.now</code> because <em>C</em> cannot be specified <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code> for constructors. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg0,arg1,...</em>&nbsp;</td><td>Constant references to the argument post-values (present only if <em>A0</em>, <em>A1</em>, ... have been specified). As for <em>self</em>, <code>arg0.now</code> is used to access the argument value after body execution and <code>arg0.old</code> is used to assess the value before body execution if the argument type was specified <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code> (and similarly for the other argument numbers). </td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>There is no <em>result</em> argument because constructors return no value. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>dbc/<a class="el" href="fun_8hpp.html">fun.hpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Nov 21 11:16:02 2009 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
