<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Writing Contracts</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="Writing_Contracts">Writing Contracts </a></h1><div align="right"><small> <a class="el" href="Design_By_Contract.html">Previous</a> </small></div><p>
This library provides both a <em>macro-based</em> API and a <em>code-based</em> API to write contracts. This section gives an overview of both types of API, the actual API function and macro documentation should studied as well in order to understand how to use this library to write contracts.<p>
In general, it is strongly recommended to use the macro-based API. The code-based API may occasionally be needed in special cases where the macro-based API does not suffice. The following is a summary of pro (+) and cons (-) of the two API.<p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<th>Characteristic </th><th>Macro-Based API <em>(recommended)</em> </th><th>Code-Based API </th></tr>
<tr>
<td>Require extra code to "setup" the contract. </td><td><b>+</b> No extra code required (the "setup" code is generated automatically by the macros). </td><td><b>-</b> The programmer has to manually write quite a bit of extra "setup" code. </td></tr>
<tr>
<td>Enhance code readability. </td><td><b>+</b> After about 1 week of use, you will become familiar with the macro syntax and the code will be easy to read. </td><td><b>-</b> The extra "setup" code reduces the contract readability. </td></tr>
<tr>
<td>Automatically document contracts. </td><td><b>+</b> Yes. </td><td><b>-</b> No (unless programmers also manually program code to write the documentation using the <code>DBC_CONFIG_DOC_</code>... macros but this will require a significant extra effort). </td></tr>
<tr>
<td>Require extra syntax to become familiar with. </td><td><b>-</b> Programmers need to become familiar with the syntax used to specify the member function <em>signature</em> in <code><a class="el" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN()</a></code> and similar macros (this usually only requires about 1 week of using the library). </td><td><b>+</b> No special syntax is introduced (just common C++ code structures). </td></tr>
<tr>
<td>Allow to easily understand how the library works. </td><td><b>-</b> The mechanisms used by the library to check the contracts are hidden within the code automatically generated by the macros. </td><td><b>+</b> The code allows to have a better understanding of how the library checks contracts at least at high level. </td></tr>
<tr>
<td>Provide extra flexibility to handle special cases. </td><td><b>-</b> The code generated by the macros can handle most library uses but not necessarily all. </td><td><b>+</b> Programmers have full control of the contract code as they are writing it manually. This extra flexibility might occasionally be needed to handle special cases (e.g., special C++ program structures, workaround internal compiler errors, etc). <br>
 <em>In these special and rare cases, it is appropriate to use the code-based API instead of the macro-based API.</em> </td></tr>
</table>
<h2><a class="anchor" name="Macro_Based_API">
Macro-Based API</a></h2>
The library macro-based API uses the <code><a class="el" href="mfun_8hpp.html#11cd5419adfe39cba4983b81dca63a71" title="This macro must follow the constructor declaration matching the specified signature...">DBC_CONSTRUCTOR()</a></code>, <code><a class="el" href="mfun_8hpp.html#a8a977641739ad90988dccb3bac04a13" title="This macro must follow the destructor declaration matching the specified signature...">DBC_DESTRUCTOR()</a></code>, and <code><a class="el" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN()</a></code> macros to specify contracts for constructors, destructor, and member functions respectively.<h2><a class="anchor" name="Invariants">
Invariants</a></h2>
The <code><a class="el" href="invariant_8hpp.html#fd939e7c1754a61a57c20bb7c6422ed4" title="This macro must be used within the class declaration and it specifies the invariants...">DBC_INVARIANT()</a></code> macro is used to specify the class invariants.<p>
It is also possible to write the function that checks the class invariants directly naming it using the <code><a class="el" href="invariant_8hpp.html#2fd19290c885c7d229480c3c58e40ac3">DBC_INVARIANT_FUN</a></code> macro. However, this approach is highly discourage and <code><a class="el" href="invariant_8hpp.html#fd939e7c1754a61a57c20bb7c6422ed4" title="This macro must be used within the class declaration and it specifies the invariants...">DBC_INVARIANT()</a></code> should be used whenever possible.<h2><a class="anchor" name="Base_Object">
Base Object</a></h2>
All classes for which a contract is specified must privately inherit from the <code><a class="el" href="classdbc_1_1object.html" title="Any class with a contract must privately inherit from this base object class.">dbc::object</a></code> class. This is achieved using the <code><a class="el" href="object_8hpp.html#126883cfec96cafb25d481c5b1e6df61" title="This macro must follow the class type name and it privately derives the class from...">DBC_INHERIT_OBJECT()</a></code> macro, or the <code><a class="el" href="object_8hpp.html#64d183bdaf93713b7beb33fa120c27c9" title="This macro must follow the last base class type name and if privately derives the...">DBC_MULTI_INHERIT_OBJECT()</a></code> macro in case of multiple inheritance.<h2><a class="anchor" name="Macro_Parameters_with_Commas">
Macro Parameters with Commas</a></h2>
The <code><a class="el" href="mparam_8hpp.html#8ee8cdd53b9cc3060ecef82fc02a8a4a" title="This macro is used to pass macro parameters containing commas.">DBC_MPARAM()</a></code> macro can be used to pass a macro parameter with one or more comma <code>","</code> . (This is required because of a limitation of the C++ preprocessor that only recognizes the <code>()</code> parenthesis so a comma in a macro parameter not wrapped by these parenthesis will split the parameter into two different macro parameters.)<h2><a class="anchor" name="Assertions">
Assertions</a></h2>
The <code>DBC_ASSERTION()</code> macro can be used to specify contract assertions. The <code>DBC_ASSERTION_STREAM()</code> macro can also be used and it allows the programmers to specify a more verbose error message and an action (throw, terminate, or exit) different from <code><a class="el" href="config_8hpp.html#4c2d172f06a44c30de7aed37fe0815c3">DBC_CONFIG_DEFAULT_ON_ASSERTION_VIOLATION</a></code> to take in case of an assertion failure.<p>
Run-time assertion checking can be selectively turned on or off depending on the action in case of assertion failure using <code><a class="el" href="config_8hpp.html#b7cecf0c16a98a89c47bba54e42d4038">DBC_CONFIG_ENABLE_THROWING_ASSERTIONS</a></code>, <code><a class="el" href="config_8hpp.html#eee7f07c926bac9fb2cedf21403d59f9">DBC_CONFIG_ENABLE_EXITING_ASSERTIONS</a></code>, or <code>DBC_CONFIG_ENABLE_TEMNINATING_ASSERTIONS</code>.<p>
These macros are wrappers around <code><a class="el" href="classdbc_1_1assertion.html" title="Class to write assertions.">dbc::assertion</a></code> and <code><a class="el" href="classdbc_1_1oassertionstream.html" title="Class to write assertions reporting verbose error messages.">dbc::oassertionstream</a></code>. These assertion classes can be used directly but it is recommended to use the macros whenever possible to gain the benefits of automatic contract documentation, run-time assertion checking enabling and disabling using <code>DBC_CONFIG_ENABLE_..._ASSERTIONS</code>, etc.<h2><a class="anchor" name="Default_Exceptions">
Default Exceptions</a></h2>
By default, a precondition failure throws a <code><a class="el" href="classdbc_1_1precondition__violation.html" title="Exception thrown by default on precondition failure.">dbc::precondition_violation</a></code> exception, a postcondition failure throws a <code><a class="el" href="classdbc_1_1postcondition__violation.html" title="Exception thrown by default on postcondition failure.">dbc::postcondition_violation</a></code> exception, and an invariant violation throws a <code>dbc::invariant_violation</code> exception. All these exceptions inherit from <code><a class="el" href="classdbc_1_1condition__violation.html" title="Base class for all contract violation exceptions.">dbc::condition_violation</a></code> which in turns inherits from <code>std::logic_exception</code>.<p>
In case an invariant failure attempts to throw an exception when checked by the destructor, no exception is thrown and <code><a class="el" href="namespacedbc.html#d6b88f4dab92db77200e6e2c2d41f662" title="The default handler called if destructor contract violation attempts to throw an...">dbc::broken_destructor_invariant()</a></code> is called instead (this is to comply with C++ STL exception safety requirements). The <code><a class="el" href="namespacedbc.html#a94307ba6289b29ef1d36bcfcd400498" title="Register user defined function to handle attempt to throw exception on destructor...">dbc::set_broken_destructor_invariant()</a></code> can be used to specify a different function to be executed to handle this case.<h2><a class="anchor" name="Separating_Declaration_and_Definition">
Separating Declartion and Definition</a></h2>
Contracts are written together with the class declaration as they are part of the class specification. The member function definition (the body) can either be provided together with the contract in the class declaration or the <code><a class="el" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">DBC_BODY()</a></code> macro can be used to separate the function definition from its declaration.<p>
Similarly, the <code><a class="el" href="body_8hpp.html#b2a724cce3b64ae6dc5d91c7f4ce8f26" title="This macro expands to the destructor body function name, it is used to separate the...">DBC_DESTRUCTOR_BODY()</a></code> and <code><a class="el" href="body_8hpp.html#e057f8723886dbe188046aeea280e730" title="This macro expands to the operator body function name, it is used to separate the...">DBC_OPERATOR_BODY()</a></code> macros can be used to separate body definitions from contract declarations for destructor and member operators respectively. For constructors, the special <code>init()</code> function should be used instead -- see <code><a class="el" href="mfun_8hpp.html#11cd5419adfe39cba4983b81dca63a71" title="This macro must follow the constructor declaration matching the specified signature...">DBC_CONSTRUCTOR()</a></code> for more detail.<p>
In general, it is recommended to split body definitions from contract declarations when possible as this will make the class declaration simpler and easier to read plus the compile-time errors in the body code will be more readable because the code will not be passed as a single-lined macro parameter.<h2><a class="anchor" name="The_old_Postfix">
The "old" Postfix</a></h2>
In the <em>signature</em> argument of the macro-based API, the <code><a class="el" href="post_8hpp.html#b10fbb20732d114633c59fa07be8222a" title="This macro marks the specified type copyable so its value before the body execution...">DBC_COPYABLE()</a></code> macro is used to indicate either a copyable class or function argument type for which the value before the body execution needs to be accessed in the postconditions using the "old" postfix. For the code-based API, <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code> should be used instead.<p>
In general, indicating a type copyable adds the extra requirement that the type must have a copy constructor and it has an impact on performances due the CPU time and memory required for the copy. Therefore, a type should be indicated copyable only if the "old" prefix for the variable of that type is needed to write the postconditions.<h2><a class="anchor" name="Subcontracting">
Subcontracting</a></h2>
In the <em>signature</em> argument of the code-based API, the <code><a class="el" href="mfun_8hpp.html#1c6dab06912180abfed3dc7f5b3006e3" title="This macro specifies the base class from which an overriding member function is subcontracting...">DBC_BASE()</a></code> macro is used to specify a base class from which the contract is subcontracted. For the code-based API, the <em>B</em> argument of <code><a class="el" href="classdbc_1_1fun_1_1mem.html" title="Template used by the code-based API to specify contracts for functions members of...">dbc::fun::mem</a></code> should be used instead.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>When invoking the base class member function from the overriding function, you must use the <code><a class="el" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">DBC_BODY()</a></code> macro to refer to the base function in order to avoid infinite recursion. The library implementation might change in the future so to relax this requirement.</dd></dl>
<h2><a class="anchor" name="Optional_Contract_Compilation">
Optional Contract Compilation</a></h2>
The <code>DBC_NO</code>, <code>DBC_CHECK_REQUIRE</code>, <code>DBC_CHECK_ENSURE</code>, <code>DBC_CHECK_INVARIANT</code>, and <code>DBC_ALL</code> macro symbols can be used to respectively compile and check either nothing, preconditions, postcondition, invariants, or all the above. If on of these macro symbols is defined, the relative contract part (preconditions, postconditions, or invariants) are compiled and checked, otherwise the relative contract part is not compiled at all and it will not be part of the object code (therefore, it will not be checked).<p>
Any logically consistent combination of these macro symbols can be used as well. For example, defining both <code>DBC_CHECK_REQUIRE</code> and <code>DBC_CHECK_INVARIANT</code> will compile and check both preconditions and invariants. However, defining <code>DBC_NO</code> and <code>DBC_CHECK_REQUIRE</code> will cause a compile-time error as this is an logically inconsistent combination.<h2><a class="anchor" name="Configuration">
Configuration</a></h2>
The library can be configured at compile-time defining the <code>DBC_CONFIG_</code>... macro symbols. If defined by the user, these symbols must be defined either in the code before the <em>first</em> inclusion of the library or by the compiler (use the <code>-D</code> and <code>-U</code> options for <code>g++</code>). If the user does not define these symbols, the library uses default values.<p>
These configuration symbols allow to highly customize the library behaviour, indicating what type of assertion to check at run-time, where to log messages, the log verbosity level, how to automatically generate documentation (to use a documentation tool different from <a class="el" href="Bibliography.html#doxygen">doxygen</a>), what is the maximum number of function arguments for which contracts should be supported, etc.<p>
See the <code><a class="el" href="config_8hpp.html" title="Header file to only include library configuration symbols.">dbc/config.hpp</a></code> documentation for details.<h2><a class="anchor" name="Code_Based_API">
Code-Based API</a></h2>
The code-based API uses <code><a class="el" href="classdbc_1_1fun_1_1constr.html" title="Template used by the code-based API to specify contracts for constructors of the...">dbc::fun::constr</a></code>, <code><a class="el" href="classdbc_1_1fun_1_1destr.html" title="Template used by the code-based API to specify contracts for the destructor of the...">dbc::fun::destr</a></code>, and <code><a class="el" href="classdbc_1_1fun_1_1mem.html" title="Template used by the code-based API to specify contracts for functions members of...">dbc::fun::mem</a></code> directly to write contracts (instead of using the <code><a class="el" href="mfun_8hpp.html#11cd5419adfe39cba4983b81dca63a71" title="This macro must follow the constructor declaration matching the specified signature...">DBC_CONSTRUCTOR()</a></code>, <code><a class="el" href="mfun_8hpp.html#a8a977641739ad90988dccb3bac04a13" title="This macro must follow the destructor declaration matching the specified signature...">DBC_DESTRUCTOR()</a></code>, and <code><a class="el" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN()</a></code> of the macro-based API). However, the use of the macro-based API is preferred and the code-based API should only be used when the macro-based API does not suffice.<p>
When using the code-based API, it is recommended to use the <code><a class="el" href="fun_8hpp.html#07c9630a559bd48c2615225a0b18b4ae" title="This macro expands to the contract class name for code-based API.">DBC_CONTRACT()</a></code> macro to name the contract class as this will allow to subcontract between contracts written with the code-based API and others written with the macro-based API.<p>
The following is the same example introduced in <a class="el" href="Quick_Start.html#A_Complete_Example">A Complete Example</a> but rewritten to use the code-based API instead of the macro-based API (from <code>"example/str/str-codeapi.cpp"</code>).<p>
<div class="fragment"><pre class="fragment"><span class="comment">/**</span>
<span class="comment"> * @file</span>
<span class="comment"> * @author Copyright (C) 2009 Lorenzo Caminiti.</span>
<span class="comment"> *  Distributed under DBC++ Software License (see file LICENSE_1_0.txt).</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;<a class="code" href="dbc_8hpp.html" title="Header file to include the entire Design By Contract for C++ library.">dbc.hpp</a>&gt;</span>
<span class="preprocessor">#include &lt;cstring&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="comment"></span>
<span class="comment">/** </span>
<span class="comment"> * Demonstrate DBC code API usage implementing a simple of string type. </span>
<span class="comment"> * Code API gives much more control to programmer, allows to see how library </span>
<span class="comment"> * works respect to macro API, but it requires to write much more "setup" </span>
<span class="comment"> * code and does not provide automatic contract documentation. </span>
<span class="comment"> */</span>
<span class="keyword">class </span>str <a class="code" href="object_8hpp.html#126883cfec96cafb25d481c5b1e6df61" title="This macro must follow the class type name and it privately derives the class from...">DBC_INHERIT_OBJECT</a>(str) { <span class="comment">// Derive from dbc::object (using macro).</span>
<span class="keyword">public</span>:<span class="comment"></span>
<span class="comment">    /** Max limit on string length. */</span>
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> MAX_SIZE = 16000;
<span class="comment"></span>
<span class="comment">    /**</span>
<span class="comment">     * Construct from C-style null-terminated string.</span>
<span class="comment">     * @param[in] chars C-style null-terminated string.</span>
<span class="comment">     */</span>
    str(<span class="keyword">const</span> <span class="keywordtype">char</span>* chars): size_(), chars_()
    <span class="comment">// Instead of DBC_CONSTRUCTOR( (public) (str)( (const char*)(chars) ), ... .</span>
#ifdef DBC <span class="comment">// Complely remove contract from object code if no DBC_CHECK_... .</span>
        <span class="comment">// Using DBC_CONTRACT() macro to name contract classes ensures allows</span>
        <span class="comment">// subcontracting between contracts specified with macro and code API.</span>
        { <a class="code" href="fun_8hpp.html#07c9630a559bd48c2615225a0b18b4ae" title="This macro expands to the contract class name for code-based API.">DBC_CONTRACT</a>(init, (chars))().call(*<span class="keyword">this</span>, &amp;<a class="code" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">str::DBC_BODY</a>(init), 
        chars, <span class="stringliteral">"init"</span>); }
<span class="keyword">protected</span>:
    <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="fun_8hpp.html#07c9630a559bd48c2615225a0b18b4ae" title="This macro expands to the contract class name for code-based API.">DBC_CONTRACT</a>(init, (chars)); <span class="comment">// Not need on modern compilers.</span>
    <span class="keyword">class </span><a class="code" href="fun_8hpp.html#07c9630a559bd48c2615225a0b18b4ae" title="This macro expands to the contract class name for code-based API.">DBC_CONTRACT</a>(init, (chars)): <span class="keyword">public</span> dbc::fun&lt;void, 
            const char*&gt;::constr&lt;str&gt; {
        <span class="keywordtype">void</span> require(<span class="comment">/* no self */</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* chars) {
            <span class="comment">// Constructor preconditions.</span>
            <span class="keywordtype">size_t</span> len = strlen(chars); <span class="comment">// Code allowed (but keep it simple).</span>
            <span class="comment">// Use DBC_ASSERT() or DBC_ASSERT_STREAM() to assert conditions.</span>
            <a class="code" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT</a>(len &gt;= 0 &amp;&amp; len &lt; str::MAX_SIZE, <span class="stringliteral">"size in range"</span>);
        }
        <span class="keywordtype">void</span> ensure(<span class="keyword">const</span> <a class="code" href="classdbc_1_1post.html" title="Postcondition argument types to support the &amp;quot;old&amp;quot; postfix.">dbc::post&lt;str&gt;</a>&amp; <span class="keyword">self</span>,
                <span class="keyword">const</span> <a class="code" href="classdbc_1_1post.html" title="Postcondition argument types to support the &amp;quot;old&amp;quot; postfix.">dbc::post&lt;char*&gt;</a>&amp; chars) {
            <span class="comment">// Constructor postconditions.</span>
            <a class="code" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT</a>(<span class="keyword">self</span>.now.size() == strlen(chars.<a class="code" href="classdbc_1_1post.html#3564fd8680a1a0e791ef46b6bf20c881" title="Current argument value.">now</a>), <span class="stringliteral">"size set"</span>);
            <a class="code" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT</a>(strcmp(<span class="keyword">self</span>.now.chars_, chars.<a class="code" href="classdbc_1_1post.html#3564fd8680a1a0e791ef46b6bf20c881" title="Current argument value.">now</a>) == 0, <span class="stringliteral">"chars set"</span>);
        }
    };
    <span class="comment">// Body function named using DBC_BODY() macro.</span>
    <span class="keywordtype">void</span> <a class="code" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">DBC_BODY</a>(init)(<span class="keyword">const</span> <span class="keywordtype">char</span>* chars)
#endif <span class="comment">// DBC</span>
    { <span class="comment">// Use ';' for body impl. when separating declaration from definition.</span>
        <span class="comment">// Constructor body.</span>
        size_ = strlen(chars);
        chars_ = <span class="keyword">new</span> <span class="keywordtype">char</span>[size_ + 1];
        strcpy(chars_, chars);
    }
<span class="keyword">public</span>: <span class="comment">// Restore original access level.</span>
    <span class="comment"></span>
<span class="comment">    /** Destroy. */</span>
    <span class="keyword">virtual</span> ~str()
    <span class="comment">// Instead of DBC_DESTRUCTOR( (public) (virtual) (str)(), ...).</span>
<span class="preprocessor">#ifdef DBC</span>
<span class="preprocessor"></span>        { <a class="code" href="fun_8hpp.html#07c9630a559bd48c2615225a0b18b4ae" title="This macro expands to the contract class name for code-based API.">DBC_CONTRACT</a>(del, ())().call(*<span class="keyword">this</span>, &amp;<a class="code" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">str::DBC_BODY</a>(del), <span class="stringliteral">"del"</span>); }
    <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="fun_8hpp.html#07c9630a559bd48c2615225a0b18b4ae" title="This macro expands to the contract class name for code-based API.">DBC_CONTRACT</a>(del, ());
    <span class="keyword">class </span><a class="code" href="fun_8hpp.html#07c9630a559bd48c2615225a0b18b4ae" title="This macro expands to the contract class name for code-based API.">DBC_CONTRACT</a>(del, ()): <span class="keyword">public</span> dbc::fun&lt;void&gt;::destr&lt;str&gt; {
        <span class="comment">// No preconditions and no postconditions.</span>
    };
    <span class="keywordtype">void</span> <a class="code" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">DBC_BODY</a>(del)()
#endif <span class="comment">// DBC</span>
    { <span class="keyword">delete</span>[] chars_; } <span class="comment">// Invariant already checked chars_ != 0.</span>
<span class="keyword">public</span>: <span class="comment">// Restore original access level.</span>
<span class="comment"></span>
<span class="comment">    /**</span>
<span class="comment">     * Return character at specified index.</span>
<span class="comment">     * @param[in] index Index position.</span>
<span class="comment">     * @return str's character at specified position.</span>
<span class="comment">     */</span>
    <span class="keywordtype">char</span>&amp; operator[](<span class="keyword">const</span> <span class="keywordtype">size_t</span>&amp; index)
    <span class="comment">// Instead of DBC_MEM_FUN( (public) (char&amp;) DBC_COPYABLE(str) (operator_at)</span>
    <span class="comment">// ( (const size_t&amp;)(index) ), ...).</span>
<span class="preprocessor">#ifdef DBC</span>
<span class="preprocessor"></span>        { <span class="keywordflow">return</span> <a class="code" href="fun_8hpp.html#07c9630a559bd48c2615225a0b18b4ae" title="This macro expands to the contract class name for code-based API.">DBC_CONTRACT</a>(operator_at, (index))().call(*<span class="keyword">this</span>, 
        &amp;<a class="code" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">str::DBC_BODY</a>(operator_at), index, <span class="stringliteral">"operator_at"</span>); }
<span class="keyword">protected</span>:
    <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="fun_8hpp.html#07c9630a559bd48c2615225a0b18b4ae" title="This macro expands to the contract class name for code-based API.">DBC_CONTRACT</a>(operator_at, (index));
    <span class="keyword">class </span><a class="code" href="fun_8hpp.html#07c9630a559bd48c2615225a0b18b4ae" title="This macro expands to the contract class name for code-based API.">DBC_CONTRACT</a>(operator_at, (index)): <span class="keyword">public</span> dbc::fun&lt;char&amp;, 
            <span class="comment">// dbc::copyable&lt;&gt; used instead of DBC_COPYABLE().</span>
            const size_t&amp;&gt;::mem&lt;dbc::copyable&lt;str&gt; &gt; {
        <span class="keywordtype">void</span> require(<span class="keyword">const</span> str&amp; <span class="keyword">self</span>, <span class="keyword">const</span> <span class="keywordtype">size_t</span>&amp; index) {
            <span class="comment">// Member function preconditions.</span>
            <a class="code" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT</a>(index &gt;= 0 &amp;&amp; index &lt; <span class="keyword">self</span>.size(), <span class="stringliteral">"index in range"</span>);
        }
        <span class="keywordtype">void</span> ensure(<span class="keyword">const</span> <a class="code" href="classdbc_1_1post.html" title="Postcondition argument types to support the &amp;quot;old&amp;quot; postfix.">dbc::post</a>&lt;<a class="code" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &amp;quot;old&amp;quot; postfix in...">dbc::copyable&lt;str&gt;</a> &gt;&amp; <span class="keyword">self</span>, 
                <span class="keyword">const</span> <a class="code" href="classdbc_1_1post.html" title="Postcondition argument types to support the &amp;quot;old&amp;quot; postfix.">dbc::post&lt;size_t&gt;</a>&amp; index, <span class="keyword">const</span> <span class="keywordtype">char</span>&amp; result) {
            <span class="comment">// Member function postconditions.</span>
            <span class="comment">// Not a const mem fun, use 'self.old' for object before body.</span>
            <a class="code" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT</a>(result == <span class="keyword">self</span>.old.chars_[index.<a class="code" href="classdbc_1_1post.html#3564fd8680a1a0e791ef46b6bf20c881" title="Current argument value.">now</a>],
                    <span class="stringliteral">"returning char at index"</span>);
        }
    };
    <span class="keywordtype">char</span>&amp; <a class="code" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">DBC_BODY</a>(operator_at)(<span class="keyword">const</span> <span class="keywordtype">size_t</span>&amp; index)
#endif <span class="comment">// DBC</span>
    {
        <span class="comment">// Member function body.</span>
        <span class="keywordflow">return</span> chars_[index];
    }
<span class="keyword">public</span>: <span class="comment">// Restore original access level.</span>
<span class="comment"></span>
<span class="comment">    /**</span>
<span class="comment">     * Return size (total number of characters).</span>
<span class="comment">     * @return str's size.</span>
<span class="comment">     */</span>
    <span class="keywordtype">size_t</span> size() const
    <span class="comment">// Instead of DBC_MEM_FUN( (public) (size_t) (str) (size)() (const), ...).</span>
<span class="preprocessor">#ifdef DBC</span>
<span class="preprocessor"></span>        { <span class="keywordflow">return</span> <a class="code" href="fun_8hpp.html#07c9630a559bd48c2615225a0b18b4ae" title="This macro expands to the contract class name for code-based API.">DBC_CONTRACT</a>(size, ())().call(*<span class="keyword">this</span>, &amp;<a class="code" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">str::DBC_BODY</a>(size), 
        <span class="stringliteral">"size"</span>); }
<span class="keyword">protected</span>:
    <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="fun_8hpp.html#07c9630a559bd48c2615225a0b18b4ae" title="This macro expands to the contract class name for code-based API.">DBC_CONTRACT</a>(size, ()); <span class="comment">// No need on moder compilers.</span>
    <span class="keyword">class </span><a class="code" href="fun_8hpp.html#07c9630a559bd48c2615225a0b18b4ae" title="This macro expands to the contract class name for code-based API.">DBC_CONTRACT</a>(size, ()): <span class="keyword">public</span> dbc::fun&lt;size_t&gt;::mem&lt;
            const str <span class="comment">/* const class type because const mem fun */</span>&gt; {
        <span class="keywordtype">void</span> require(<span class="keyword">const</span> str&amp; <span class="keyword">self</span>) {} <span class="comment">// No preconditions.</span>
        <span class="keywordtype">void</span> ensure(<span class="keyword">const</span> <a class="code" href="classdbc_1_1post.html" title="Postcondition argument types to support the &amp;quot;old&amp;quot; postfix.">dbc::post&lt;str&gt;</a>&amp; <span class="keyword">self</span>, <span class="keyword">const</span> <span class="keywordtype">size_t</span>&amp; result) {
            <a class="code" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT</a>(result == <span class="keyword">self</span>.now.size_, <span class="stringliteral">"returning size"</span>);
        }
    };
    <span class="keywordtype">size_t</span> <a class="code" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">DBC_BODY</a>(size)() <span class="keyword">const</span>
#endif <span class="comment">// DBC</span>
        { <span class="keywordflow">return</span> size_; }
<span class="keyword">public</span>: <span class="comment">// Restore original access level.</span>

<span class="keyword">private</span>:<span class="comment"></span>
<span class="comment">    /** Internal string size. */</span>
    <span class="keywordtype">size_t</span> size_; <span class="comment">// Unsgined so size_ &gt;= 0 check could be removed...</span><span class="comment"></span>
<span class="comment">    /** Internal string representation. */</span>
    <span class="keywordtype">char</span>* chars_;

    <span class="comment">// Invariants are still specified using macro.</span>
    <a class="code" href="invariant_8hpp.html#fd939e7c1754a61a57c20bb7c6422ed4" title="This macro must be used within the class declaration and it specifies the invariants...">DBC_INVARIANT</a>(str, {
        <span class="comment">// Invariants.</span>
        <a class="code" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT</a>(<span class="keyword">self</span>.chars_ != 0, <span class="stringliteral">"chars exist"</span>);
        <a class="code" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT</a>(<span class="keyword">self</span>.size_ &gt;= 0 &amp;&amp; <span class="keyword">self</span>.size_ &lt; str::MAX_SIZE,
                <span class="stringliteral">"size in range"</span>);
        <span class="comment">// Assertions above passed, chars_[size_] can be accessed.</span>
        <a class="code" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT</a>(<span class="keyword">self</span>.chars_[<span class="keyword">self</span>.size_] == <span class="charliteral">'\0'</span>, <span class="stringliteral">"null-terminated"</span>);
    })
};
<span class="comment"></span>
<span class="comment">/** Main program. */</span>
<span class="keywordtype">int</span> main() {
    std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"init()..."</span> &lt;&lt; std::endl;
    str s(<span class="stringliteral">"Galileo Galilei"</span>);

    std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"operator[](0)..."</span> &lt;&lt; std::endl;
    std::cout &lt;&lt; s[0] &lt;&lt; std::endl;

    std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"del()..."</span> &lt;&lt; std::endl;
    <span class="keywordflow">return</span> 0;
}

</pre></div><p>
On Linux, it can be complied and executed similarly to <a class="el" href="Quick_Start.html#A_Complete_Example">A Complete Example</a>.<p>
Comparing it with the same example written the macro-based API, note how the code-based API introduce much more code that reduce the contract readability, it requires much more work for the programmer, it does not automatically document the contract but it allows to better understand how the library checks the contracts.<p>
<div align="right"><small> <a class="el" href="Design_By_Contract.html">Previous</a> </small></div> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Jun 17 15:39:36 2009 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
