<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Annex: Work In Progress</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="todo">Annex: Work In Progress </a></h1>List of library to-dos.<p>
<ol type=1>
<li>Revisit the source to sync it with the doc (especially type traits). <br>
<br>
</li><li>Make library thread-safe if DBC_THREADING is "#define". In this case: DbC++ will also require Boost.Threading. sync_&lt;&gt; must have mutex. dbc_global_checking_ must have a mutex. Executing inv+require+body+inv+ensure must be atomic (sync'd by a mutex) so that effectively only 1 operation at the time for class can be exec among the operations w/ contracts. Consider impl waiting pre/post conditions. What would this do to performances? This will add quite a bit on sync at the class level but also at a global level via dbc_global_checking_... <br>
<br>
</li><li>Fix all Boost.MPL static assertions in dbc::fun&lt;&gt;. Do I need to add any more static assertions? <br>
<br>
</li><li>Indicate vimrc config to avoid red curly brackets {} when passing code blocks as macro params. <br>
<br>
</li><li>Read and refer DBC for C++ Std proposal rev 4 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html</a> <br>
<br>
</li><li>Use boost::mpl::void_ (or dbc::void_ as it is done by Boost.Parameter -- why Boost.Parameter does not use boost::mpl::void_?) instead of dbc::none_. <br>
<br>
</li><li>Decide how to handle contracts for non-member functions and static member functions. Shall these be handeled the same? Maybe, bacause for both it might only make sense to check pre and post conditions (no invariants), self is not available, and what about subcontracts for static mem-fun?? What does Eiffel do (does it allow static mem-fun?)? Does any of the C++ std proposal, D, etc say anything about this? <br>
<br>
</li><li>Support contracts for template member functions. class F1 { public: template&lt;typename X&gt; void f(X x); }; and what about template&lt;typename Y&gt; class F2 { public: template&lt;typename X&gt; Y f(X x); }; This will probably require to allow (template) not just before class type but also before function name, and to allos to specify tparam names. Now: [(template)](class-type) ... (fun-name) Maybe fix: [(template)](class-type) ... [(template)(X)](fun-name) What about template variables? Can DBC handle them? template&lt;typename Y, Y y0 = Y()&gt; class F2 { public: template&lt;typename X, X x0 = X()&gt; Y f(X x); }; <br>
<br>
</li><li>Support contracts for non-member functions (via dbc::fun&lt;&gt; and DBC_FUN()) and for static member functions (probably still via dbc::fun&lt;&gt; but allowing (static) instead of (virtual) in <a class="el" href="mfun_8hpp.html#2872f212b72c32e6254e34086e9714bf" title="This macro must follow the member function declaration matching the specified signature...">DBC_MEM_FUN()</a>). Can I handle static mem fun as non-mem fun via same dbc::fun&lt;&gt;? One difference is that static mem fun could still check a "static" invariant while no invariant can be checked for non-mem fun. However, this would require the introdution of a DBC_STATIC_INVARIANT() (without the self arg) that should be checked in and any time <a class="el" href="invariant_8hpp.html#fd939e7c1754a61a57c20bb7c6422ed4" title="This macro must be used within the class declaration and it specifies the invariants...">DBC_INVARIANT()</a> is checked, it should be checked alone for static mem fun, it shoudl be "optional" but I cannot see how that could be... user will have to always say DBC_STATIC_INVARIANT(class-name, {}) even if there is no static mem-fun with a contract if the static inv is checked in and with the inv... <br>
<br>
</li><li>Suggest code of script to ignore g++ "duplicate friend" warning (from bin). <br>
<br>
</li><li>Renamed "include/ dir to src/ dir." <br>
<br>
</li><li>DBC++ is currently using BOOST_PP_IS_UNARY() to recognize keywords (public, virtual, const, etc) when parsing macro-based API function signatures. BOOST_PP_IS_UNARY() is NOT part of Boost.Preprocessor public API (it is instead in boost/preprocessor/detail) because of compiler compatibility issues (I think just with an old version of the C++ Borland compiler...). Other Boost libraries that use BOOST_PP_IS_UNARY() are: boost/typeof/template_encoding.hpp boost/spirit/home/classic/utility/rule_parser.hpp boost/range/detail/microsoft.hpp How much complier compatibility issues does the use of BOOST_PP_IS_UNARY() really raise? Is there a work-around to implement BOOST_PP_IS_UNARY? <br>
<br>
</li><li>Allow runtime pre/post/inv checking enable/disable based on class name. What for non-member functions? Use Case. I have a template library that is well tested so I want to disable postcondition checking. However, that is a template so it cannot be precompiled into a separate .so with postconditions off. I must compile it together witht the rest of the code. Therefore, if the rest of the code needs to check postconditions, I must check postconditions for the template library as well! I could do this a run time using a map&lt;class-name, enable-or-diable&gt; then providing macros ENABLE_PRE(class-name) that set the map. Can I do this a compile-time (better so I do not have to compile post if I do not check them)? Maybe I can using a ifdef CONFIG_ENABLE_PRE_class-name and the user will have to define CONFIG_ENABLE_PRE_class-name... look more into this. Does Eiffel allow enable/disable pre/post/inv per class? pre function? per compilation unit? (Current DBC++ allows this only pre compilation unit but that's not enough because template libraries need to be recompiled into every compilation unit as indicated by the use case above.) <br>
<br>
</li><li>Consider value in addition contracts to all STL classes. For example a dbc::list&lt;&gt; class can wrap std::list&lt;&gt; and add contracts to it. Post/Inv checking here is likely not interesting given that STL code is well tested to work. Pre checking might be interesting instead. <br>
<br>
</li><li>[Ottosen2006] suggests to OR pre / AND post from *all* base classes in case of multiple inheritance. DBC++ currently only allow subcontracting from one specific base mem fun but not from multiple ones... what does Eiffel do? I might be able to allow DBC_BASES(3, (baseA, baseB, baseC)) and then OR/AND *all* base pre/post (but what about invariants? AND all base inv?). Is this usefull? <br>
<br>
</li><li>[Ottosen2006] indicates that "old" values should be copied *after* pre checking and *before* body execution so to avoid the copy in case of errors. This makes sense. DBC++ currently copies the "old" values, then checks Inv, checks Pre, exec Body, etc. This should be changed to: Check Inv, check Pre, copy "old" values, exec Body, etc (its trivial to change but test it!). <br>
<br>
</li><li>[Ottosen2006] allows "old" only for types that have a copy constructor taking a const&amp;. This makes sense as the copy operation must not alter self or the arg. DBC++ currently does not enforce this. For example, self for non mem-fun is not const&amp; (but just &amp;) in exec() and that is passed to the copy contructor that could eventually modify self (same if for arg that are not const). This is essentially a bug!! Fix it! (The fix should be trivial, either cast to const&amp; or better declare a "const Class&amp; const_ref_self" and copy const_ref_self instead of self, same for arg.) <br>
<br>
</li><li>[Ottosen2006] requires Inv to be checked also by mem fun that exit abnormally via an exception (understand exactly why, ther is reference [5] that I need to study...). DBC++ currently does not do that but this should be easy to implement in exec() handling excetions (different from conditions_violation) and checking Inv in that case. However, if Inv is violated shall I throw invariant_violation or the originally exection raised by Body? I think the invariant_violation because if Inv terminates or exit that takes precendence over reporting Body exception (so Inv throw should also take precende over Body throw). However, I think it would be good to log the Body throw in this case so it is not lost because of the overriding Inv throw, terminate, or exit... think about this more... <br>
<br>
</li><li>Understand the relationship between contracts and concepts ([Ottosen2006] cites all concepts C++ proposals as being affected by the contract proposal). <br>
<br>
</li><li>Would it be easier to avoid to forget .now/.old in postconditions if also pre/inv required .now? Currently, I occasionally use self/arg without .now in postconditions and I get cryptic compiler errors "undefined operator for type ...". For consistency, I could require .now all the times also in pre and inv, then I could offer .old only in post for copyable types. Would that be better? (If so, also "result" should really be "result.now".) <br>
<br>
</li><li>Consider the addition of a DBC_CONFIG_AUTO_SIGNATURE that if defined by the user requires the library to generate the function signaures automatically. I intentionally required the user to write the signature before the macro-based API because I think the code is more readable that way. However, that requires more effort for programmers and given the code duplication of the signature it allows for errors (most signature missmatches will generate compile-time errors but not necessarly all). <br>
<br>
</li><li>Document MSVC error "warning ... not enough actual parameters for macro 'BOOST_PP_SEQ...'" repeated many, many times when using "(f)( )" instead of "(f)( (void) )" to specify empty argument list. <br>
<br>
</li><li>Shall I try to compile on MSVC with /Wall?? It gives a LOT of warning also in Boost... (It compiles with no warnings but the "already friend" one on g++ with -Wall!) <br>
<br>
</li><li>Adopt a more consistent macro syntax: 1) Change the macro syntax so token apper in the exact same order as they appear in the class declaration (NO EXCETION). This way I don't have to remember in which order the tokens come. 2) Adopt the use of '.now' every where (pre/post/inv). In post, .old is availabe for copyable&lt;&gt; types only. (In the code, I make all pre and inv args of type nowof&lt;T&gt; instead of T, for post I just rename post&lt;&gt; to oldof&lt;&gt;. oldof&lt;T&gt; for non copyable&lt;T&gt; is same as nowof&lt;T&gt;.) This way I do not have to remember when to use .now -- I should always use it! 3) Also change "err" stream variable in DBC_ASSERT_STREAM to "violation". For example:</li></ol>
<p>
include &lt;contract.hpp&gt; include &lt;iostream&gt; include &lt;string&gt;<p>
Token Order Rule This way token in the macro syntax "simply" follow the order in which they appear in the class definition (no need to refer to the class delcaration).<p>
(inherit) Order Following the token order rule above, (inherit)(base-class-type) should came after the class-type (template) and before the access (public), (protected), or (private) because that is the order in which the base class appear in the class declaration. Note ':' is not a valid macro token so (inherit) is used instead.<p>
(template) for Class-Type If C++0x will allow to use 'typename' outside templates, the leading (template) referring to the class-type (which is already optional) will no longer be needed (but it may still be specified to ensure backward compatibility).<p>
template&lt;typename D&gt; class converter: public abstract_converter, public lengther_interface /* Removed need for _INHERIT_OBJECT </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Nov 21 11:16:02 2009 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
