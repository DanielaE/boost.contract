<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Design By Contract</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="Design_By_Contract">Design By Contract </a></h1><div align="right"><small> <a class="el" href="Quick_Start.html">Previous</a> | <a class="el" href="Writing_Contracts.html">Next</a> </small></div><p>
This section gives some background on Design By Contract (DBC) and points to references that can be used to learn more on the topic.<h2><a class="anchor" name="Benefits">
Benefits</a></h2>
The main use of DBC is to improve software quality. [<a class="el" href="Bibliography.html#Mey97">Mey97</a>] discusses how DBC can be used as the basic tool to write "correct" software. The following is a short summary of benefits associated with using DBC mainly taken from [<a class="el" href="Bibliography.html#Ott04">Ott04</a>]. See also [<a class="el" href="Bibliography.html#Str97">Str97</a>] for more discussion on the key importance of class invariants and on advantages and disadvantages of using preconditions and postconditions.<p>
<ol type=1>
<li>Using DBC preconditions and postconditions, the programmer can give a precise semantic description of what a function requires at its entry and what it ensures under its (normal) exit. In particular, using the "old" postfix in postconditions, DBC provides a mechanism that allows the programmer to compare values of an expression before and after the executions of the function's body. This mechanism is powerful enough to enable the programmer to express many constraints in the code -- constraints that would otherwise have to be captured at the best only informally by the code documentation. <br>
 <br>
</li><li>In addition, using DBC invariants, the programmer can describe what to expect from a class and logic dependencies between class's member functions and variables. It is the job of the constructor to ensure that the invariants are satisfied when the object is first created. Then the implementation of the member functions can be largely simplified as they can be written knowing that the invariants are satisfied as DBC checks them before and after the execution of every member function body. Finally, the destructor makes sure the invariants hold for the entire object life-cycle checking the invariants one last time before destroying the object. <br>
 <br>
</li><li>This library automatically extracts the contract assertions and makes them integral part of the class source documentation. Because contracts are embedded directly into the source code, they are executed and verified at run-time so they are always up to date and the related documentation can be trusted. <br>
 <br>
</li><li>DBC can provide a powerful debugging facility because, if contracts are well written, bugs will cause contract assertions to fail exactly where the problem first occurs instead that in some later stage of the program in an apparently unrelated manner. In general, a precondition failure points to a bug in the class user that called one of the member function with invalid parameters. A postcondition failure points instead to a bug in the class member function's implementation. Furthermore, in case of a contract assertion failure, this library provides a detailed log messages that greatly helps debugging. <br>
 <br>
 <dl class="note" compact><dt><b>Note:</b></dt><dd>Of course, if the contract is ill written then DBC is of little use. However, it is less likely to have a bug in both the contract and the body than in the body only. That is especially true if contracts are kept simple and they only spell out the semantics of the class design via a concise list of assertions. For example, consider the validation of a result in postconditions. Validating the return value might seem redundant, but in this case we actually want that redundancy. When programmers write a function, there is a certain probability that they make an error implementing the function body. When they specify the result of the function in the postconditions, there is also a certain probability that they make an error again in writing the contract. However, the probability that they make an error twice (in the body and the contract) is lower than the probability that the error is made once (only in the body). <br>
 <br>
</dd></dl>
</li><li>DBC complements testing because a contract also specify specifies what a test should check. For example, preconditions of a function state which input causes the function to throw (or simply fail) and postconditions state which input causes it to exit normally. <br>
 <br>
</li><li>DBC can serve to reduce the gap between designer and programmer by providing a precise and unambiguous specification language. Moreover, contracts can make code reviews easier. <br>
 <br>
</li><li>DBC formalizes the overriding mechanism of virtual member functions via the concept of subcontracting. This keeps the base class programmer in control as any derived functions still has to fully satisfy the base class contract. <br>
 However, this library leaves it up to the programmer of the derived class whether to subcontract the base class or not. The derived class contract clearly states if it is bypassing the base class contract or not but this weakens the benefit listed above -- it is strongly recommend to always subcontract when overriding virtual member functions. <br>
 <br>
</li><li>DBC assertions replace checks commonly used for <em>defensive programming</em> making the code more readable.</li></ol>
<h2><a class="anchor" name="Costs">
Costs</a></h2>
The above DBC benefits come to the cost of performance as discussed in detail in both [<a class="el" href="Bibliography.html#Str97">Str97</a>] and [<a class="el" href="Bibliography.html#Mey97">Mey97</a>].<p>
The run-time performances are impacted by DBC mainly because of the followings.<ol type=1>
<li>The extra processing required to check the assertions.</li><li>The extra processing required by the additional function calls (additional functions are invoked to check preconditions, postconditions, and invariants).</li><li>The extra processing required to copy the object and function arguments that were made copyable using <code><a class="el" href="post_8hpp.html#b10fbb20732d114633c59fa07be8222a" title="This macro marks the specified type copyable so its value before the body execution...">DBC_COPYABLE()</a></code> or <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code> to support the "old" postfix in postconditions.</li></ol>
<p>
The library implementation tries to minimize the performance impact using <code>inline</code> functions and not compiling at all the parts of the contracts that are disabled using <code>DBC_CHECK_</code>... .<p>
A reasonable approach is to:<ol type=1>
<li>Always write contracts to clarify the semantics of your design embedding them directly into the code and its documentation.</li><li>Enable preconditions, postconditions, and invariants during early testing.</li><li>Enable only preconditions (and possibly invariants) during release testing and in the final program release. (Postconditions are usually more expensive to check.)</li></ol>
<p>
In reality, you will have to decide based on the performance trade-off required by your system.<p>
Compile-time performances are also impacted by this library because the library implementation extensively uses C++ preprocessor and template metaprogramming. The use of metapgramming turned out to be essential to support the "old" postfix for non-copyable types and a variable number of function arguments without code duplication. Testing showed that the increase in CPU time and memory required by the preprocessor is minimal. However, the increase in CPU time and memory used by the compiler might be very significant depending on your program structure. Improving the library implementation to reduce compilation-time is an ongoing activity so check future releases of this library for an hopefully faster compilation of your contracts (these future implementation optimization will introduce no change in the library public API).<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>At the moment, C++ compilers are usually not optimized for metaprogramming (see [<a class="el" href="Bibliography.html#Abr05">Abr05</a>]). However, the C++ standard committee is considering adding metaprogramming libraries to STL (e.g., type traits). This could serve as an incentive for future C++ compiler implementations to more efficiently compile metaprograms.</dd></dl>
In general, DBC is an essential approach to improve software quality even if it comes at a performance cost. While performance trade offs should be carefully considered depending on the application domain, software quality cannot be sacrificed -- it is difficult to see the value of a system that quickly and efficiently provides the incorrect output.<h2><a class="anchor" name="Other_Approaches">
Other Approaches</a></h2>
DBC is built into Eiffel [<a class="el" href="Bibliography.html#Mey97">Mey97</a>] and D [<a class="el" href="Bibliography.html#Bri04a">Bri04a</a>] programming languages, and the Digital Mars C++ compiler has it as an extension [<a class="el" href="Bibliography.html#Bri04b">Bri04b</a>]. There are tools for different languages that try to emulate DBC (notably, iContract for the Java programming language). See [<a class="el" href="Bibliography.html#Ott04">Ott04</a>] for more information.<p>
At the point when this library was developed, there was no publicly available tool for C++ providing all DBC features supported by Effiel. Existing tools lacked of support for either the "old" postfix in postconditions, subcontracting, automatic contract documentation, or a combination of the above. Therefore this library was developed to provide all Eiffel DBC features for C++.<p>
The following table compares DBC features among different languages, libraries, and tools (similar to the comparison presented in [<a class="el" href="Bibliography.html#Ott04">Ott04</a>]). Some level of detail is provided on <em>how</em> this library implements the listed DBC features.<p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<th rowspan="2">Design By Contract (DBC) Feature </th><th colspan="2">This DBC Library </th><th rowspan="2">Eiffel [<a class="el" href="Bibliography.html#Mey97">Mey97</a>] </th><th rowspan="2">D [<a class="el" href="Bibliography.html#Bri04a">Bri04a</a>] </th><th rowspan="2">Proposal to add DBC to C++ [<a class="el" href="Bibliography.html#Ott04">Ott04</a>] </th></tr>
<tr>
<td><em>Support</em></td><td><em>Detail</em> </td></tr>
<tr>
<td><em>Keywords</em> </td><td>Not apply to a library. </td><td>Code-based API (no keywords) follow Eiffel names: <code>require()</code>, <code>ensure()</code>, <code><a class="el" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">DBC_BODY()</a></code>, <code>.old</code> (and <code>.now</code>), and <code><a class="el" href="invariant_8hpp.html#fd939e7c1754a61a57c20bb7c6422ed4" title="This macro must be used within the class declaration and it specifies the invariants...">DBC_INVARIANT()</a></code>. </td><td><code>require</code>, <code>ensure</code>, <code>do</code>, <code>require else</code>, <code>ensure then</code>, <code>old</code>, <code>invariant</code>, and <code>result</code>. </td><td><code>in</code>, <code>out</code>, <code>body</code>, <code>invariant</code>, and <code>assert</code>. </td><td><code>in</code>, <code>out</code>, <code>do</code>, <code>invariant</code>, and <code>return</code>. </td></tr>
<tr>
<td><em>On condition violation</em> </td><td>Throw (by default), terminate, or exit. </td><td>Programmer can select action on violation using <code><a class="el" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT()</a></code> and <code><a class="el" href="assertion_8hpp.html#7f1678c1e2a86b6d044d8a90af6a81ff" title="Assert the specified condition allowing to indicate the action to take in case the...">DBC_ASSERT_STREAM()</a></code>. </td><td>Throw exception. </td><td>Throw exception. </td><td>Terminate (by default), might throw or exit. </td></tr>
<tr>
<td><em>Return value evaluation</em> </td><td>Yes. </td><td><code>result</code> argument of <code>ensure()</code> (only if postconditions compiled in object code). </td><td>Yes, <code>result</code> keyword. </td><td>No. </td><td>Yes, <code>return</code> keyword. </td></tr>
<tr>
<td><em>Expression copying in postconditions</em> </td><td>Yes. </td><td>For object and function arguments declared <code><a class="el" href="post_8hpp.html#b10fbb20732d114633c59fa07be8222a" title="This macro marks the specified type copyable so its value before the body execution...">DBC_COPYABLE()</a></code> or <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code>, accessed via <code>.old</code> (only if postconditions compiled in object code). </td><td>Yes, <code>old</code> keyword. </td><td>No. </td><td>Yes, <code>in</code> keyword. </td></tr>
<tr>
<td><em>Subcontracting</em> </td><td>Yes. </td><td>Use <code><a class="el" href="mfun_8hpp.html#1c6dab06912180abfed3dc7f5b3006e3" title="This macro specifies the base class from which an overriding member function is subcontracting...">DBC_BASE()</a></code> or <code>B</code> template parameter of <code><a class="el" href="classdbc_1_1fun_1_1mem.html" title="Template used by the code-based API to specify contracts for functions members of...">dbc::fun::mem</a></code> (but derived class programmer can decide to subcontract or not, recommended to always subcontract). </td><td>Yes. </td><td>Yes. </td><td>Yes. </td></tr>
<tr>
<td><em>Assertion nameing</em> </td><td>Yes. </td><td>A string passed to <code><a class="el" href="assertion_8hpp.html#393d8bc235939371624484cdda853395" title="Assert the specified condition, intended to be used to assert preconditions, postconditions...">DBC_ASSERT()</a></code> and <code><a class="el" href="assertion_8hpp.html#7f1678c1e2a86b6d044d8a90af6a81ff" title="Assert the specified condition allowing to indicate the action to take in case the...">DBC_ASSERT_STREAM()</a></code>. </td><td>Yes. </td><td>No. </td><td>No. </td></tr>
<tr>
<td><em>Arbitrary code in contracts</em> </td><td>Yes. </td><td>But recommended to keep contract code simple, ideally limit it to a list of assertions. </td><td>No. </td><td>Yes. </td><td>No. </td></tr>
<tr>
<td><em>Contract for abstract functions</em> </td><td>Yes. </td><td>When body is defined pure virtual by <code>"= 0;"</code>. </td><td>Yes. </td><td>No. </td><td>Yes. </td></tr>
<tr>
<td><em>Code ordering</em> </td><td>Order: Preconditions, postconditions, and body. </td><td>For macro-based API only. </td><td>Order: Preconditions, body, and postconditions. </td><td>Order: Preconditions, postconditions, and body. </td><td>Order: Preconditions, postconditions, and body. </td></tr>
<tr>
<td><em>Static assertions</em> </td><td>Yes. </td><td>Use C++ metaprogramming (e.g., the <a class="el" href="Bibliography.html#Boost">Boost.MPL</a> library). </td><td>No. </td><td>Yes. </td><td>Yes. </td></tr>
<tr>
<td><em>Prevent contract side-effects</em> </td><td>Yes. </td><td>Use constant (<code>const</code>) code block, object <code>self</code>, function arguments, and <code>result</code> to limit unintended contract side side-effects. </td><td>Yes. </td><td>No. </td><td>No. </td></tr>
<tr>
<td><em>Contracts removable from object code</em> </td><td>Yes. </td><td>Compilation and checking of preconditions, postconditions, invariants, and any of their combination can be enabled or disabled using the <code>DBC_CHECK_</code>... macros. </td><td>Not preconditions. </td><td>Yes. </td><td>Only default assertions. </td></tr>
<tr>
<td><em>Check invariants</em> </td><td>At end of constructors, at beginning and end of member functions, and at beginning of destructor (if programmer specifies contracts for those). </td><td>E.g., programmer may omit contract for all private member functions so their calls will not check invariants. Furthermore, invariant checking in destructor is disabled during stack unwinding because of an unhandled exceptions (as contracts themselves can throw). </td><td>At end of constructors, at beginning and end of public member functions. </td><td>At end of constructors, at beginning and end of public member functions, and at beginning of destructor. </td><td>At end of constructors, at beginning and end of public member functions, and at beginning of destructor. </td></tr>
<tr>
<td><em>Disabling assertion checking within assertions</em> </td><td>Yes. </td><td>To prevent infinite recursion when checking contracts. </td><td>Yes. </td><td>No. </td><td>Yes. </td></tr>
<tr>
<td><em>In nested function calls</em> </td><td>Disable invariants only. </td><td>To prevent infinite recursion when checking contracts. </td><td>Disable all assertions. </td><td>Disable nothing. </td><td>Disable invariants only. </td></tr>
<tr>
<td><em>Concurrency</em> </td><td>Not yet. </td><td>On roadmap to implement this similarly to Eiffel (i.e., making this library thread-safe and supporting waiting conditions). </td><td>Yes (implements waiting conditions). </td><td>No. </td><td>No. </td></tr>
<tr>
<td><em>Automatic contract documentation</em> </td><td>Yes. </td><td><a class="el" href="Bibliography.html#doxygen">doxygen</a> is used by default (see <code>DBC_CONFIG_DOC_</code>...). </td><td>Yes (contracts are part of the class <em>short form</em>). </td><td>No with existing documentation tools. </td><td>No with existing documentation tools. </td></tr>
</table>
<p>
The design of this library was somewhat inspired by:<ul>
<li>[<a class="el" href="Bibliography.html#Mal99">Mal99</a>] in how to implement optional contract compilation and subcontracting (however because this library uses preprocessor and template metaprogramming the actual implementation of these features now differs quite a bit from the approach proposed by [<a class="el" href="Bibliography.html#Mal99">Mal99</a>]).</li><li>[<a class="el" href="Bibliography.html#Tan04">Tan04</a>] in the use of <a class="el" href="Bibliography.html#doxygen">doxygen</a> for automatic contract documentation.</li></ul>
<p>
<div align="right"><small> <a class="el" href="Quick_Start.html">Previous</a> | <a class="el" href="Writing_Contracts.html">Next</a> </small></div> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Jun 17 15:39:36 2009 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
