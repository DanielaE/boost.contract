<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>dbc::fun&lt; R, A0, A1, &gt;::mem&lt; C, B &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacedbc.html">dbc</a>::<a class="el" href="classdbc_1_1fun.html">fun</a>::<a class="el" href="classdbc_1_1fun_1_1mem.html">mem</a>
  </div>
</div>
<div class="contents">
<h1>dbc::fun&lt; R, A0, A1, &gt;::mem&lt; C, B &gt; Class Template Reference</h1><!-- doxytag: class="dbc::fun::mem" -->Template used by the code-based API to specify contracts for functions members of the given class and eventually subcontracting from the given base contract class.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;fun.hpp&gt;</code>
<p>

<p>
<a href="classdbc_1_1fun_1_1mem-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classdbc_1_1fun_1_1mem.html">mem</a>&lt; C, B &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1mem.html#79ff340cae9cb607445fbab134e31c0e">this_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type resulting from this template instantiation.  <a href="#79ff340cae9cb607445fbab134e31c0e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="06cb1bf0af6cb2727d94c8f2829b5469"></a><!-- doxytag: member="dbc::fun::mem::basic_class_type" ref="06cb1bf0af6cb2727d94c8f2829b5469" args="" -->
typedef <br>
remove_copyable_const_ref_&lt; C &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1mem.html#06cb1bf0af6cb2727d94c8f2829b5469">basic_class_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class type without <code>const</code>, <code>&amp;</code>, and <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code> qualifiers. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cf3fad43f63c4a171b7a4cd4bd06bf16"></a><!-- doxytag: member="dbc::fun::mem::copyable_class_type" ref="cf3fad43f63c4a171b7a4cd4bd06bf16" args="" -->
typedef remove_const_ref_&lt; C &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1mem.html#cf3fad43f63c4a171b7a4cd4bd06bf16">copyable_class_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class type without <code>const</code> and <code>&amp;</code> qualifiers (but keeps eventual <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code> qualifier). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ce93949be4a4d03d015e8dbfb8a3958b"></a><!-- doxytag: member="dbc::fun::mem::uncopyable_class_type" ref="ce93949be4a4d03d015e8dbfb8a3958b" args="" -->
typedef remove_copyable_ref_&lt; C &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1mem.html#ce93949be4a4d03d015e8dbfb8a3958b">uncopyable_class_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class type without <code>&amp;</code> and <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code> qualifiers (but keeps eventual <code>const</code> qualifier). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef R(uncopyable_class_type::*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1mem.html#4a506ae20f8dc61be4d2b4e2c35c45d0">mem_fun_type</a> )(<a class="el" href="classdbc_1_1fun.html#e9d5c76bfcc289385d827bd293b1ff59">uncopyable_arg0_type</a>, uncopyable_arg1_type,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Member function pointer type.  <a href="#4a506ae20f8dc61be4d2b4e2c35c45d0"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual R&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1mem.html#6045047603196318db87095af6a00dc8">call</a> (<a class="el" href="classdbc_1_1fun_1_1mem.html#ce93949be4a4d03d015e8dbfb8a3958b">uncopyable_class_type</a> &amp;self, <a class="el" href="classdbc_1_1fun_1_1mem.html#4a506ae20f8dc61be4d2b4e2c35c45d0">mem_fun_type</a> body, <a class="el" href="classdbc_1_1fun.html#e9d5c76bfcc289385d827bd293b1ff59">uncopyable_arg0_type</a> arg0, <a class="el" href="classdbc_1_1fun.html#e9d5c76bfcc289385d827bd293b1ff59">uncopyable_arg0_type</a> arg1,..., const std::string &amp;name=&quot;&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check this contract and execute the specified body accordingly to the <a class="el" href="Quick_Start.html#Member_Function_Call_Semantics">DBC Member Function Call Semantics</a>.  <a href="#6045047603196318db87095af6a00dc8"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1mem.html#24adf1f45e517092b99fa24084492ac1">require</a> (const <a class="el" href="classdbc_1_1fun_1_1mem.html#06cb1bf0af6cb2727d94c8f2829b5469">basic_class_type</a> &amp;self, const <a class="el" href="classdbc_1_1fun.html#ebf252ec04b04ddc780c8b4d283e959e">basic_arg0_type</a> &amp;arg0, const basic_arg1_type &amp;arg1,...)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The user must implement this function specifying the <em>preconditions</em> required by the member function contract.  <a href="#24adf1f45e517092b99fa24084492ac1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdbc_1_1fun_1_1mem.html#fc00820aeae815d42a40118f96cb7563">ensure</a> (const <a class="el" href="classdbc_1_1post.html">post</a>&lt; <a class="el" href="classdbc_1_1fun_1_1mem.html#cf3fad43f63c4a171b7a4cd4bd06bf16">copyable_class_type</a> &gt; &amp;self, const <a class="el" href="classdbc_1_1post.html">post</a>&lt; <a class="el" href="classdbc_1_1fun.html#9a83e31b04c23152aa8ba6e7cb59f024">copyable_arg0_type</a> &gt; &amp;arg0, const <a class="el" href="classdbc_1_1post.html">post</a>&lt; copyable_arg1_type &gt; &amp;arg1,..., const <a class="el" href="classdbc_1_1fun.html#4959ebd8b3e603a0c25181c815c547e0">basic_result_type</a> &amp;result)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The user must implement this function specifying the <em>postconditions</em> ensured by the member function contract.  <a href="#fc00820aeae815d42a40118f96cb7563"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename R, typename A0 = none_, typename A1 = none_, ...&gt;<br>
template&lt;class C, class B = no_base_&gt;<br>
 class dbc::fun&lt; R, A0, A1, &gt;::mem&lt; C, B &gt;</h3>

Template used by the code-based API to specify contracts for functions members of the given class and eventually subcontracting from the given base contract class. 
<p>
The contracted function must be a member of the class <em>C</em>, with return type <em>R</em>, argument types <em>A0</em>, <em>A1</em>, ..., and optionally subcontracting from the base contract class <em>B</em>. <dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>C</em>&nbsp;</td><td>Class of which the contracted function is member of. This class type <em>C</em> must privately inherit from <code>dbc::object&lt;C&gt;</code> (see <code><a class="el" href="object_8hpp.html#126883cfec96cafb25d481c5b1e6df61" title="This macro must follow the class type name and it privately derives the class from...">DBC_INHERIT_OBJECT()</a></code>) and it must specify invariants (see <code><a class="el" href="invariant_8hpp.html#fd939e7c1754a61a57c20bb7c6422ed4" title="This macro must be used within the class declaration and it specifies the invariants...">DBC_INVARIANT()</a></code>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>Base contract class from which the contract function is subcontracting. This must be of a type derived from <code><a class="el" href="classdbc_1_1fun_1_1mem.html" title="Template used by the code-based API to specify contracts for functions members of...">dbc::fun::mem</a></code> so to be a valid contract. If the contracted member function is not subcontracting, this parameter can be left unspecified). </td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>In general, to allow subcontracting it is necessary to make <code><a class="el" href="classdbc_1_1fun_1_1mem.html" title="Template used by the code-based API to specify contracts for functions members of...">dbc::fun::mem</a></code> and <code><a class="el" href="classdbc_1_1post.html" title="Postcondition argument types to support the &quot;old&quot; postfix.">dbc::post</a></code> friends for the contracted class (e.g., when subcontracting from private base class). This is automatically done by the macro-based API (and causes the annoying multiple friend compiler warning) but it must be done manually when using the code-based API. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="Writing_Contracts.html#Code_Based_API">Code-Based API</a> for an example. </dd></dl>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="79ff340cae9cb607445fbab134e31c0e"></a><!-- doxytag: member="dbc::fun::mem::this_type" ref="79ff340cae9cb607445fbab134e31c0e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename A0 = none_, typename A1 = none_, ... &gt; </div>
<div class="memtemplate">
template&lt;class C, class B = no_base_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classdbc_1_1fun_1_1mem.html">mem</a>&lt;C, B&gt; <a class="el" href="classdbc_1_1fun.html">dbc::fun</a>&lt; R, A0, A1, &gt;::<a class="el" href="classdbc_1_1fun_1_1mem.html">mem</a>&lt; C, B &gt;::<a class="el" href="classdbc_1_1fun_1_1mem.html">this_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type resulting from this template instantiation. 
<p>
This is needed when writing contracts for functions member of a <em>template</em> class type <em>C</em>. <div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="dbc_8hpp.html" title="Header file to include the entire Design By Contract for C++ library.">dbc.hpp</a>&gt;</span>

  teamplate&lt;typename T&gt;
  <span class="keyword">class </span>C <a class="code" href="object_8hpp.html#64d183bdaf93713b7beb33fa120c27c9" title="This macro must follow the last base class type name and if privately derives the...">DBC_MULTI_INHERIT_OBJECT</a>(C&lt;T&gt;) {
  <span class="keyword">public</span>:
      T f(<span class="keyword">const</span> T&amp; x) <span class="keyword">const</span>
<span class="preprocessor">  #ifdef DBC</span>
<span class="preprocessor"></span>      { <span class="keywordflow">return</span> <a class="code" href="fun_8hpp.html#07c9630a559bd48c2615225a0b18b4ae" title="This macro expands to the contract class name for code-based API.">DBC_CONTRACT</a>(f, (x))().<a class="code" href="classdbc_1_1fun_1_1mem.html#6045047603196318db87095af6a00dc8" title="Check this contract and execute the specified body accordingly to the DBC Member...">call</a>(*<span class="keyword">this</span>, &amp;<a class="code" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">C::DBC_BODY</a>(f),
          x, <span class="stringliteral">"f"</span>); }
  <span class="keyword">protected</span>:
      <span class="keyword">class </span><a class="code" href="fun_8hpp.html#07c9630a559bd48c2615225a0b18b4ae" title="This macro expands to the contract class name for code-based API.">DBC_CONTRACT</a>(f, (x)): <span class="keyword">public</span> dbc::fun&lt;T, const T&amp;&gt;::
              template <span class="comment">// Need to explicitly indicate template.</span>
              mem&lt;const C&gt;::<a class="code" href="classdbc_1_1fun_1_1mem.html#79ff340cae9cb607445fbab134e31c0e" title="Type resulting from this template instantiation.">this_type</a> { <span class="comment">// Need instantiated type.</span>
          <span class="keywordtype">void</span> <a class="code" href="classdbc_1_1fun_1_1mem.html#24adf1f45e517092b99fa24084492ac1" title="The user must implement this function specifying the preconditions required by the...">require</a>(<span class="keyword">const</span> C&amp; <span class="keyword">self</span>, <span class="keyword">const</span> T&amp; x) {
              <span class="comment">// Preconditions.</span>
          }
          <span class="keywordtype">void</span> <a class="code" href="classdbc_1_1fun_1_1mem.html#fc00820aeae815d42a40118f96cb7563" title="The user must implement this function specifying the postconditions ensured by the...">ensure</a>(<span class="keyword">const</span> <a class="code" href="classdbc_1_1post.html" title="Postcondition argument types to support the &amp;quot;old&amp;quot; postfix.">dbc::post&lt;C&gt;</a>&amp; <span class="keyword">self</span>,
                  <span class="keyword">const</span> <a class="code" href="classdbc_1_1post.html" title="Postcondition argument types to support the &amp;quot;old&amp;quot; postfix.">dbc::post&lt;T&gt;</a>&amp; x) {
              <span class="comment">// Postconditions.</span>
          }
      };
      T <a class="code" href="body_8hpp.html#ea7a98c2dc3935885607e58813225e60" title="This macro expands to the body function name, it is used to separate the body implementation...">DBC_BODY</a>(f)(<span class="keyword">const</span> T&amp; x) <span class="keyword">const</span>
  #endif <span class="comment">// DBC</span>
      ; <span class="comment">// Body definition split from contract declaration.</span>
  <span class="keyword">public</span>:
      
      ...
  };
</pre></div> 
</div>
</div><p>
<a class="anchor" name="4a506ae20f8dc61be4d2b4e2c35c45d0"></a><!-- doxytag: member="dbc::fun::mem::mem_fun_type" ref="4a506ae20f8dc61be4d2b4e2c35c45d0" args=")(uncopyable_arg0_type, uncopyable_arg1_type,...)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename A0 = none_, typename A1 = none_, ... &gt; </div>
<div class="memtemplate">
template&lt;class C, class B = no_base_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef R(uncopyable_class_type::*  <a class="el" href="classdbc_1_1fun.html">dbc::fun</a>&lt; R, A0, A1, &gt;::<a class="el" href="classdbc_1_1fun_1_1mem.html">mem</a>&lt; C, B &gt;::<a class="el" href="classdbc_1_1fun_1_1mem.html#4a506ae20f8dc61be4d2b4e2c35c45d0">mem_fun_type</a>)(<a class="el" href="classdbc_1_1fun.html#e9d5c76bfcc289385d827bd293b1ff59">uncopyable_arg0_type</a>, uncopyable_arg1_type,...)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Member function pointer type. 
<p>
Note that the eventual <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code> qualifier is removed from the function argument and class types as it does not appear in the actual member function signature. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="6045047603196318db87095af6a00dc8"></a><!-- doxytag: member="dbc::fun::mem::call" ref="6045047603196318db87095af6a00dc8" args="(uncopyable_class_type &amp;self, mem_fun_type body, uncopyable_arg0_type arg0, uncopyable_arg0_type arg1,..., const std::string &amp;name=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename A0 = none_, typename A1 = none_, ... &gt; </div>
<div class="memtemplate">
template&lt;class C, class B = no_base_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual R <a class="el" href="classdbc_1_1fun.html">dbc::fun</a>&lt; R, A0, A1, &gt;::<a class="el" href="classdbc_1_1fun_1_1mem.html">mem</a>&lt; C, B &gt;::call           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdbc_1_1fun_1_1mem.html#ce93949be4a4d03d015e8dbfb8a3958b">uncopyable_class_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdbc_1_1fun_1_1mem.html#4a506ae20f8dc61be4d2b4e2c35c45d0">mem_fun_type</a>&nbsp;</td>
          <td class="paramname"> <em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdbc_1_1fun.html#e9d5c76bfcc289385d827bd293b1ff59">uncopyable_arg0_type</a>&nbsp;</td>
          <td class="paramname"> <em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdbc_1_1fun.html#e9d5c76bfcc289385d827bd293b1ff59">uncopyable_arg0_type</a>&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check this contract and execute the specified body accordingly to the <a class="el" href="Quick_Start.html#Member_Function_Call_Semantics">DBC Member Function Call Semantics</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td>A reference to the <a class="el" href="classdbc_1_1object.html" title="Any class with a contract must privately inherit from this base object class.">object</a> (use <code>*this</code> from the contracted member function). The eventual <code>const</code> qualifier is kept for the class type to properly handle constant member functions. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>A pointer to function implementing the body. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg0,arg1,...</em>&nbsp;</td><td>The function arguments. The eventual <code>const</code> qualifiers are kept to properly handle constant arguments. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>The function name (optional, used for log messages). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value returned by the body (could be <code>void</code>). </dd></dl>

</div>
</div><p>
<a class="anchor" name="24adf1f45e517092b99fa24084492ac1"></a><!-- doxytag: member="dbc::fun::mem::require" ref="24adf1f45e517092b99fa24084492ac1" args="(const basic_class_type &amp;self, const basic_arg0_type &amp;arg0, const basic_arg1_type &amp;arg1,...)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename A0 = none_, typename A1 = none_, ... &gt; </div>
<div class="memtemplate">
template&lt;class C, class B = no_base_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdbc_1_1fun.html">dbc::fun</a>&lt; R, A0, A1, &gt;::<a class="el" href="classdbc_1_1fun_1_1mem.html">mem</a>&lt; C, B &gt;::require           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdbc_1_1fun_1_1mem.html#06cb1bf0af6cb2727d94c8f2829b5469">basic_class_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdbc_1_1fun.html#ebf252ec04b04ddc780c8b4d283e959e">basic_arg0_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const basic_arg1_type &amp;&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The user must implement this function specifying the <em>preconditions</em> required by the member function contract. 
<p>
If the contract does not require any precondition, simply implement this pure virtual function as <code>{}</code>. All these arguments are constant references so the contract cannot modify the <a class="el" href="classdbc_1_1object.html" title="Any class with a contract must privately inherit from this base object class.">object</a> and argument values by mistake. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>self</em>&nbsp;</td><td>Constant reference to the <a class="el" href="classdbc_1_1object.html" title="Any class with a contract must privately inherit from this base object class.">object</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg0,arg1,...</em>&nbsp;</td><td>Constant references to the argument values (present only if <em>A0</em>, <em>A1</em>, ... have been specified).</td></tr>
  </table>
</dl>
<small> <dl class="note" compact><dt><b>Note:</b></dt><dd>Defining this function pure virtual instead of virtual <code>{}</code> allows to check at compile-time that the use is overriding the proper virtual function to specify the contract (otherwise an error in specifying the function signature would result in declaring a different virtual function and silently not checking the user defined contracts).</dd></dl>
</small> 
</div>
</div><p>
<a class="anchor" name="fc00820aeae815d42a40118f96cb7563"></a><!-- doxytag: member="dbc::fun::mem::ensure" ref="fc00820aeae815d42a40118f96cb7563" args="(const post&lt; copyable_class_type &gt; &amp;self, const post&lt; copyable_arg0_type &gt; &amp;arg0, const post&lt; copyable_arg1_type &gt; &amp;arg1,..., const basic_result_type &amp;result)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename A0 = none_, typename A1 = none_, ... &gt; </div>
<div class="memtemplate">
template&lt;class C, class B = no_base_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdbc_1_1fun.html">dbc::fun</a>&lt; R, A0, A1, &gt;::<a class="el" href="classdbc_1_1fun_1_1mem.html">mem</a>&lt; C, B &gt;::ensure           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdbc_1_1post.html">post</a>&lt; <a class="el" href="classdbc_1_1fun_1_1mem.html#cf3fad43f63c4a171b7a4cd4bd06bf16">copyable_class_type</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdbc_1_1post.html">post</a>&lt; <a class="el" href="classdbc_1_1fun.html#9a83e31b04c23152aa8ba6e7cb59f024">copyable_arg0_type</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdbc_1_1post.html">post</a>&lt; copyable_arg1_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdbc_1_1fun.html#4959ebd8b3e603a0c25181c815c547e0">basic_result_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The user must implement this function specifying the <em>postconditions</em> ensured by the member function contract. 
<p>
If the contract does not ensure any postcondition, simply implement this pure virtual function as <code>{}</code>. All these arguments are constant references so the contract cannot modify the <a class="el" href="classdbc_1_1object.html" title="Any class with a contract must privately inherit from this base object class.">object</a>, argument, and returned values by mistake. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>self</em>&nbsp;</td><td>Constant reference to the <a class="el" href="classdbc_1_1object.html" title="Any class with a contract must privately inherit from this base object class.">object</a> <em>post-value</em>. The post-value allows to access the current <a class="el" href="classdbc_1_1object.html" title="Any class with a contract must privately inherit from this base object class.">object</a> value (after the body execution) via <code>self.now</code>. Furthermore, if the <a class="el" href="classdbc_1_1object.html" title="Any class with a contract must privately inherit from this base object class.">object</a> type <code>C</code> was specified <a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">copyable</a> using <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code> then also the old <a class="el" href="classdbc_1_1object.html" title="Any class with a contract must privately inherit from this base object class.">object</a> value (<em>before</em> the body execution) can be accessed via <code>self.old</code> (this requires the type to have a copy constructor and will impact performances with an extra copy of the <a class="el" href="classdbc_1_1object.html" title="Any class with a contract must privately inherit from this base object class.">object</a>, use it only when the old value is really needed in postconditions, see <code><a class="el" href="post_8hpp.html#b10fbb20732d114633c59fa07be8222a" title="This macro marks the specified type copyable so its value before the body execution...">DBC_COPYABLE()</a></code>). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg0,arg1,...</em>&nbsp;</td><td>Constant references to the argument post-values (present only if <em>A0</em>, <em>A1</em>, ... have been specified). As for <em>self</em>, <code>arg0.now</code> is used to access the argument value after body execution and <code>arg0.old</code> is used to assess the value before body execution if the argument type was specified <code><a class="el" href="classdbc_1_1copyable.html" title="Indicate the specified type is copyable to support the &quot;old&quot; postfix in...">dbc::copyable</a></code> (and similarly for the other argument numbers). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>result</em>&nbsp;</td><td>Constant reference to the value being returned (present only if <em>R</em> is not <code>void</code>).</td></tr>
  </table>
</dl>
<small> <dl class="note" compact><dt><b>Note:</b></dt><dd>Defining this function pure virtual instead of virtual <code>{}</code> allows to check at compile-time that the use is overriding the proper virtual function to specify the contract (otherwise an error in specifying the function signature would result in declaring a different virtual function and silently not checking the user defined contracts).</dd></dl>
</small> 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>dbc/<a class="el" href="fun_8hpp.html">fun.hpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Nov 21 11:16:02 2009 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
