
[/ Copyright (C) 2008-2016 Lorenzo Caminiti]
[/ Distributed under the Boost Software License, Version 1.0 (see accompanying]
[/ file LICENSE_1_0.txt or a copy at http://www.boost.org/LICENSE_1_0.txt).]
[/ See: http://www.boost.org/doc/libs/release/libs/contract/doc/html/index.html]

[section Introduction]

Contract Programming allows to specify preconditions, postconditions, and class invariants that are automatically checked when functions are executed at run-time.
These conditions assert program specifications within the source code itself allowing to find bugs more quickly during testing, making the code self-documenting, and increasing overall software quality (see __Contract_Programming_Overview__).

For example, consider the following function `inc` that increments its argument `x` by `1` and let's write its contract using code comments (see also [@../../example/features/introduction_comments.cpp =introduction_comments.cpp=]):

[import ../example/features/introduction_comments.cpp]
[introduction_comments]

The precondition states that at function entry the argument `x` must be strictly smaller than the maximum allowable value of its type (so it can be increased by `1` without overflowing).
The postcondition states that at function exit the argument `x` must be incremented by `1` with respect to the value it had before executing the function `old(x)` (but noting that postconditions are checked only when the execution of the function body did not throw an exception).

Now let's program this function and its contract using this library (see also [@../../example/features/introduction.cpp introduction.cpp]):

[import ../example/features/introduction.cpp]
[introduction]

When the above function `inc` is called, this library will:

* First, execute the functor passed to `.precondition(...)` that asserts `inc` preconditions.
* Then, execute `inc` body (i.e., all the code that follows the `boost::contract::check c = ...` declaration).
* Last, execute the functor passed to `.postcondition(...)` that asserts `inc` postconditions (unless `inc` body threw an exception).

For example, if there is a bug in the code calling `inc` so that the function is called with `x` greater than or equal to `std::numeric_limits<int>::max()` then the program will terminate with an error message similar to the following (so it will be evident that the bug is in the calling code):

[pre
precondition assertion "x < std::numeric_limits<int>::max()" failed: file "introduction.cpp", line 17
]

Instead, if there is a bug in the implementation of `inc` so that `x` is not increased by `1` after the execution of the function body then the program will terminate with an error message similar to the following (so it will be evident that the bug is in `inc` body):
[footnote
In this example the function body is composed of a single trivial instruction `++x` so it easy to check by visual inspection that it does not contain any bug and it will always increment `x` by `1` thus the function postcondition will never fail.
In real code, function bodies are rarely this simple and can hide bugs that make checking postconditions useful.
]

[pre
postcondition assertion "x == *old_x + 1" failed: file "introduction.cpp", line 20
]

By default, when an assertion fails this library prints an error message such the above to the standard error `std::cerr` and terminates the program calling `std::terminate` (but this behaviour can be customized to take any user-specified action including throwing exceptions, see __Throw_on_Failure__).
Note that the error messages printed by this library contain all the information necessary to easily and uniquely identify the point in the code at which the contract assertions fail.
[footnote
*Rationale:*
The assertion failure message printed by this library follows a format similar to the message printed by Clang when the C-style `assert` macro fails.
]

In addition to contracts for simple non-member functions as shown the in the example above, this library allows to program contracts for constructors, destructors, and member functions.
These can check class invariants and can also /subcontract/ inheriting and extending contracts for derived classes (see __Tutorial__ and also __Advanced_Topics__).

[note
C++11 lambda functions are necessary to use this library without having to manually program a significant amount of boiler-plate code (see __No_Lambda_Functions__).
Otherwise this library does not use other C++11 features and should work on most modern C++ compilers (see __Getting_Started__).
]

[endsect]

