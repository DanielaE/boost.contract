
/** @todo[LC] Revisit the source to sync it with documentation (especially
type traits... */

/** @todo[LC] Add short table with source dir structure mentioning examples
and tests (suggest to look a key examples). */

/** @todo[LC] Investigate limitation when subcontracting with multiple
inheritance from base templates with same variable name (as its type depends on
template param). This currently requires either direct use of DBC_BODY() (which
prevents further subcontracting) or use of code API... but macro APIs fail. */

/** @todo[LC] Make library thread-safe if DBC_THREADING is #define.
In this case: DbC++ will also require Boost.Threading. sync_<> must have mutex.
dbc_global_checking_ must have a mutex. Exectuiong inv+require+body+inv+ensure
must be atomic (sync'd by a mutex) so that effectivelly only 1 operation at the
time for class can be exec among the operations w/ contracts. Consider impl
waiting pre/post conditions. What would this do to performances? This will add
quite a bit on sync at the class level but also at a global level via
dbc_global_checking_... */

/** @todo[LC] Fix all Boost.MPL static assertions in dbc::fun<>. Do I need to
add any more static assertions? */

/** @todo[LC] When subcontracting, shall I check derived or base inv/pre/post
first? Now first derived inv/pre/post is checked then base inv/pre/post are
checked (see test/Subcontracting/deep_subcontracting) -- that's probably OK to 
check derived conditions before base conditions but this way derived conditions 
cannot assume base conditions hold... if we checked base conditions first it 
might be better but when checking "or" in cortocircuito for preconditions I 
shall check mine first (shall I?)... think more about this. */

/** @bug[LC] I have seen GCC internal segfaul error if DBC_CONFIG_MAX_ARGC is
more than 3 some some of the DBC++ test programs... I wonder is the compiler 
gets confused by fun<...> instead of fun0, fun1, ... (maybe the template
specialization with partial default argument is not properly supported...). */

/** @bug[LC] When invoking parent's function directly from overriden function,
must use DBC_BODY() to avoid infinite recursive checking of contract. See
NameList example.
@code
    struct B DBC_INHERIT_OBJECT(B) {
        virtual void f() DBC_MEM_FUN(..., {})
        ...
    };
    struct D: public B DBC_TRAILING_OJECT(D) {
        virtual void f() DBC_MEM_FUN(..., { B::DBC_BODY(f)(); })
        // This instead, will cause infinite contract checking recursion.
        virtual void f() DBC_MEM_FUN(..., { B::f(); })
        ...
    };
#endcode
This is quite annoying as a small developper error in omitting DBC_BODY() in 
this context will result in a infinite recursion a run-time!!! Can I avoid this
somehow??? Can I check it a compile-time? Can I make it work even if calling 
w/out DBC_BODY()? Also, what happens if the body function is not declared 
virtual but only the actual function is declared virtual?
More in general than above todo, how shall DbC handle recursion?
Shall contract checking always be disabled when a function recursively invokes
itself? Maybe not, since it might invoke itself w/ different arguments and w/
obj in a different state (is it is not a const mem fun)... What is Eiffel
policy on DbC and recursion? */

/** @bug[LC] When constrcutor contract is delegated to init() initializer, the
contract does not show up in Doxygen... that is because constr (which are 
public) have no contract, while init() has the contract but it is private...
is there a way around this? Since Doxygen reports the header files, the contract
code (for init() also) is in the reported header but that's not ideal... It'd be
nice if I could say in the Doxyfile to report init() (and del()) doc even if
they are private... */

