
[/ Copyright (C) 2008-2016 Lorenzo Caminiti]
[/ Distributed under the Boost Software License, Version 1.0 (see accompanying]
[/ file LICENSE_1_0.txt or a copy at http://www.boost.org/LICENSE_1_0.txt).]
[/ See: http://www.boost.org/doc/libs/release/libs/contract/doc/html/index.html]

[section Advanced Topics]

This section illustrates more advanced uses of this library.

[section Pure Virtual Public Functions]

In C++, pure virtual functions are allowed to have a /default implementation/ as long as such implementation is programmed out-of-line so defined outside the class declaring the `virtual ... = 0;` pure virtual function.

Contracts for pure virtual public functions are programmed using the [funcref boost::contract::public_function] function like for (non-pure) virtual public functions (all consideration made in __Virtual_Public_Functions__ apply).
However, contracts have to be programmed out-of-line, in the default implementation of the pure virtual function.
For example (see also [@../../example/features/pure_virtual_public.cpp =pure_virtual_public.cpp=]):

[import ../example/features/pure_virtual_public.cpp]
[pure_virtual_public_base]
[pure_virtual_public_impl]
[pure_virtual_public_derived]

This library will never actually execute the pure virtual function body while it is calling the pure virtual function default implementation to check contracts for subcontracting.
Therefore, programmers can safely `assert(false)` at the beginning of the body if they intend for that body to never be executed (or they can program a working body in case they need to use C++ pure virtual function default implementation outside of what strictly required by this library).

[import ../example/features/named_override.cpp]
[note
As seen in __Public_Function_Overrides__, preconditions of overriding public functions are checked in __OR__ with preconditions of overridden virtual public functions.
Therefore, if a virtual public function in a base class specifies no precondition then preconditions specified by all its overriding functions in derived classes will have no effect (because when checked in __OR__ with the overridden function from the base class that has no preconditions, they will always pass).
This correctly reflects the fact that the overridden function in the base class can be called from any context (because it has no precondition) and so must all its overriding functions in all derived classes in accordance with the __substitution_principle__.

That said, it is sometimes useful for a base class to declare a pure virtual function with a single precondition `BOOST_CONTRACT_ASSERT(false)` that will always fail.
This indicates that the pure virtual function can never be called unless it is redefined in a derived class (which is always the case with C++ pure virtual functions) and also that the base class designer has intentionally left it up to derived classes to specify preconditions for the pure virtual function in question.
This technique makes sense only for preconditions of pure virtual public functions (otherwise `BOOST_CONTRACT_ASSERT(false)` will prevent calling virtual public functions in concrete bases).
For example (see also [@../../example/features/named_override.cpp =named_override.cpp=]):

[named_override_pure_virtual_assert_false]
]

[endsect]

[section Optional Return Value]

It is possible to use `boost::optional` to handle return values when programmers cannot construct the result variable at its point of declaration before the contract (e.g., because an appropriate constructor for the return type is not available at that point, or just because it would be too expensive to execute an extra initialization of the return value at run-time).
[footnote
*Rationale:*
`boost::optional` is used instead of `std::optional` because `std::optional` is not part of C++ standards prior to C++17.
]
For example (see also [@../../example/features/optional_result.cpp =optional_result.cpp=]):

[import ../example/features/optional_result.cpp]
[optional_result]

In this example the return type is a reference so it does not have default constructor that can be used to initialize `result` when it is declared before the contract declaration.
In addition, `Index` needs to be validated to be smaller than `size()` by the precondition before it can be used to retrieve the reference to be assigned to `result` so `vect[Index]` cannot be used either to initialize `result` when it is declared before the contract declaration.
Therefore, `boost::optional` is used to defer `result` proper initialization until the execution of the function body after the contract declaration when `Index` has been validated by the preconditions and `vect[Index]` can be safely evaluated to initialize `result`.

As seen in __Return_Value__, it is the responsibility of the programmers to ensure that `result` is always set to the return value when the function exits without trowing an exception.
This also ensures that `result` is always set before the postconditions are checked so programmers can always dereference `result` in postconditions to access the return value (using `operator*` and `operator->` as usual with `boost::optional`, and without having to explicitly check if `result` is an empty `boost::optional` object).
This can be easily done by making sure that /all/ return statements in the function are of the form:
    
    boost::optional<...> result;
    ...
    return *(result = ...); // Assign `result` at each return.

[heading Virtual Public Functions]

Similarly, `boost::optional` can be used to handle the return value passed to contracts of virtual public functions (pure or not) and of public function overrides.
As seen in __Pure_Virtual_Public_Functions__, __Virtual_Public_Functions__, and __Public_Function_Overrides__, in these cases the return value `result` must be passed as a parameter to [funcref boost::contract::public_function] right after the parameter `v` of type [classref boost::contract::virtual_]`*`.
Then the functor passed to `.postcondition(...)` takes one single parameter of type `boost::optional<`[^['result-type]]` const&> const&`.
For example (see also [@../../example/features/optional_result_virtual.cpp =optional_result_virtual.cpp=]):

[import ../example/features/optional_result_virtual.cpp]
[optional_result_virtual]
    
The inner `const&` in the postcondition functor parameter type `boost::optional<... const&> ...` is mandatory (the outer `const&` in the postcondition functor parameter type `boost::optional<...> const&` is not).
[footnote
*Rationale:*
This library requires the postcondition functor parameter to be of type `boost::optional<... const&>` so the return value does not have to be copied (because of `&`) while postconditions are still prevented from changing it (because of `const`, see also __Constant_Correctness__).
In addition, programmers are encouraged to declare the postcondition functor to take its argument also as a (constant) reference `boost::optional<... const&> const&` to avoid possibly expensive copies of the `boost::optional` type.
]

[endsect]

[section Private and Protected Functions]

Private and protected member functions do not check class invariants (because they are not part of the public class interface) and they do not subcontract (because they are not accessible at the calling site where the __substitution_principle__ applies, see also __Function_Calls__).
However, programmers may still want to specify preconditions and postconditions for private and protected member functions if they want to check correctness of their implementation and use from within the class, base classes, and friend classes or functions.
When programmers decide to specify contracts for private and protected member functions, they can use [funcref boost::contract::function] (like for non-member functions).
For example (see also [@../../example/features/private_protected.cpp =private_protected.cpp=]):

[import ../example/features/private_protected.cpp]
[private_protected]

The same considerations made in __Non_Member_Functions__ apply.
See __Constructors__ and __Destructors__ for notes on how to program contracts for private and protected constructors and destructors instead.

[heading Virtual Private and Protected Functions]

When private and protected member functions are virtual they should still declare the extra parameter of type [classref boost::contract::virtual_]`*` with default value `0` (see __Virtual_Public_Functions__) even if [funcref boost::contract::function] never accepts that parameter as an argument (so this parameter will remain unused and it does not need a name).
Otherwise, the private and protected virtual functions cannot be overridden by public functions in the derived classes that specify contracts for the overriding functions (because C++ uses also default parameters to match signatures of overriding functions).
For example (see also [@../../example/features/private_protected_virtual.cpp =private_protected_virtual.cpp=]):

[import ../example/features/private_protected_virtual.cpp]
[private_protected_virtual_counter]

However, public functions in derived classes overriding private or protected virtual functions from base classes will not specify the extra `override_...` template parameter to [funcref boost::contract::public_function] (because the overridden functions are private or protected thus not being public they do not participate to subcontracting), for example (see also [@../../example/features/private_protected_virtual.cpp =private_protected_virtual.cpp=]):

[private_protected_virtual_counter10]

Furthermore, using multiple inheritance it is possible to override functions that are private or protected from one base but public from another base.
In this case, overriding public functions in derived classes will specify the extra `override_...` template parameter to [funcref boost::contract::public_function] (because the overridden functions are private or protected in one base and those do not participate to subcontracting, but public in another base and these participate to subcontracting instead).
For example (see also [@../../example/features/private_protected_virtual_multi.cpp =private_protected_virtual_multi.cpp=]):

[import ../example/features/private_protected_virtual_multi.cpp]
[private_protected_virtual_multi_countable]
[private_protected_virtual_multi_counter10]

[warning
Unfortunately, the code above does not compile on MSVC (at least up to Visual Studio 2015) because MSVC incorrectly gives a compile-time error when SFINAE fails due to private or protected access levels.
Instead, GCC and Clang correctly implement SFINAE failures due to private and protected member functions so the code above correctly complies on GCC and Clang.

Therefore, currently it is not possible to override a member that is public in one base but private or protected in other base using this library on MSVC, that can be done instead on GCC or CLang.
]

[endsect]

[section Friend Functions]

Friend functions are not member functions so [funcref boost::contract::function] can used to program contracts for them and all considerations made in __Non_Member_Functions__ apply.
For example (see also [@../../example/features/friend.cpp =friend.cpp=]):

[import ../example/features/friend.cpp]
[friend_byte]
[friend_bytes]

However, in some cases a friend function might take an object as parameter and it can be logically considered an extension of the object's public interface (essentially at the same level as the object's public member functions).
In these cases, programmers might chose to program the friend function contracts using [funcref boost::contract::public_function] (instead of [funcref boost::contract::function]) so to also check the class invariants of the object (and not just the pre- and postconditions of the friend function).
For example (see also [@../../example/features/friend_invariant.cpp =friend_invariant.cpp=]):
[footnote
*Rationale:*
Contract programming proposals for C++ like __N1962__ do not provide a mechanism for friend functions to check class invariants of objects passed as parameters.
In other words, these proposals do not allow contracts to recognize that some friend functions logically act as if they were part of the public interface of the objects they take as parameters.
This is reasonable for proposals that add contracts to the core language because friend functions are not always meant to extend an object public interface and C++ does not provide a mechanism to programmatically specify when they do.
However, this library (not being meant to be a revision of the C++ standard itself) has the flexibility to let programmers manually specify when friend functions should also check class invariants of the objects they take as parameters.
]

[import ../example/features/friend_invariant.cpp]
[friend_invariant]

This technique can also be extended to friend functions that take multiple objects as parameters and can be logically considered extensions to the public interfaces of each of these objects, for example:

    friend void f(class1& object1, class2* object2, type3& value3) {
        // Check just preconditions.
        boost::contract::check pre = boost::contract::function()
            .precondition([&] {
                BOOST_CONTRACT_ASSERT(object2 != nullptr);
                ...
            })
        ;
        // Check class invariants for each object (programmers chose the order).
        boost::contract::check inv1 = boost::contract::public_function(&object1);
        boost::contract::check inv2 = boost::contract::public_function(object2);
        // Check just postconditions.
        boost::contract::check post = boost::contract::function()
            .postcondition(...)
        ;

        ... // Function body.
    }

Changing the order of the [classref boost::contract::check] declarations above, programmers can chose the order for checking class invariants among the different objects passed to the friend function and also whether to check these invariants before or after pre- and postconditions at function entry and exit respectively (see __Non_Member_Functions__ and __Public_Functions__ for information on how the RAII objects returned by [funcref boost::contract::function] and [funcref boost::contract::public_function] check contract conditions).
The example above is programmed to check `class1` invariants before `class2` invariants (but the order could have been inverted if programmers so chose).
Also the example above is programmed to check preconditions before class invariants so the objects passed to the friend function can be validated by the preconditions before they are passed as pointers to [funcref boost::contract::public_function] (e.g., check `object2` is not null).
[footnote
Within member functions instead the object pointer `this` is always well-formed, its validation is never needed, and [funcref boost::contract::public_function] checks class invariants before checking preconditions so programming preconditions can be simplified assuming the class invariants are satisfied already (see __Public_Function_Calls__).
]

[endsect]

[section Function Overloads]

As seen in __Public_Function_Overrides__, [funcref boost::contract::public_function] takes a pointer to the enclosing function as a parameter when used in public function overrides.
When names of public function overrides are overloaded, the function pointer cannot be automatically deduced by the compiler so programmers have to use `static_cast` to resolve ambiguities (as usual with pointers to overloaded functions in C++).
[footnote
*Rationale:*
In order to avoid copies, this library takes all function arguments and the return value passed to [funcref boost::contract::public_function] as references when used within public function overrides.
Therefore, the library cannot differentiate when the actual function argument and return types are passed by reference and when they are not.
As a result, the library cannot automatically reconstruct the type of the enclosing public function so this type must be deduced from the function pointer explicitly passed by programmers to [funcref boost::contract::public_function].
When this automatic deduction is not possible due to overloaded function names, programmers must explicitly use `static_cast` to resolve ambiguities as usual in C++ with pointers to overloaded functions.
]
For example, note how `static_cast` is used in the following calls to [funcref boost::contract::public_function] (see also [@../../example/features/overload.cpp =overload.cpp=]):

[import ../example/features/overload.cpp]
[overload]

Overloaded functions have the same function name so the same [^override_['function-name]] type can be used as template parameter for all [funcref boost::contract::public_function] calls.
Therefore, [macroref BOOST_CONTRACT_OVERRIDE] only needs to be invoked once for any given function name even when the function name is overloaded (as shown in the example above).

[endsect]

[section Lambdas, Loops, Code Blocks, Etc.]

So far we have been focused on specifying contracts for function and class interfaces.
While contracts are in general most useful when used to specify interfaces, this library also allows to check contract conditions for implementation code (lambda functions, code blocks, loops, etc.).

Lambda functions are not member functions, they are not part of a class public interface so they do not check class invariants or participate int subcontracting, but they can use [funcref boost::contract::function] to specify preconditions, postconditions, and exception guarantees (all considerations made in __Non_Member_Functions__ apply).
For example (see also [@../../example/features/lambda.cpp =lambda.cpp=]):

[import ../example/features/lambda.cpp]
[lambda]

Similarly, [funcref boost::contract::function] can be used to program preconditions, postconditions, and exception guarantees for loops.
For example, for a for-loop but same for while- and all other loops (see also [@../../example/features/loop.cpp =loop.cpp=]):

[import ../example/features/loop.cpp]
[loop]

More in general, [funcref boost::contract::function] can be used to program preconditions, postconditions, and exception guarantees of any block of code in a function implementation.
For example (see also [@../../example/features/code_block.cpp =code_block.cpp=]):

[import ../example/features/code_block.cpp]
[code_block]

Finally, this library does not support contracts for functions declared `constexpr`.
[footnote
*Rationale:*
In general, it might be useful to specify contracts for constexpr functions and literal classes.
However, the implementation of this library cannot support contracts for these functions and classes because C++ does not currently allow constexpr function to do the following:
Declare local variables of (literal) types with non-trivial constexpr destructors (this RAII technique is used by this library to check invariants, postconditions, and exceptions guarantees at exit);
Call other constexpr functions using try-catch statements (used by this library to report contract assertion failures and catch any other exception that might be thrown when evaluating the asserted conditions);
Use lambda functions (used by this library for convenience to program functors that that check preconditions, postconditions, and exception guarantees).
Also note that even if supported, contracts for constexpr functions probably would not use old values (because `constexpr` prevents functions from having any side effect visible to the caller and variables recording such side-effects are usually the candidates for old value copies) and subcontracting (because constexpr functions cannot be virtual).
]

[endsect]

[section Implementation Checks]

This library provides a mechanism to check assertions within implementation code outside of preconditions, postconditions, exceptions guarantees, and class invariants.
These implementation checks can be programmed using [macroref BOOST_CONTRACT_ASSERT] in a nullary functor that is directly assigned to [classref boost::contract::check] at the place within the code where the checks have to be executed, for example (see also [@ ../../example/features/check.cpp =check.cpp=]):

[import ../example/features/check.cpp]
[check_class]

Alternatively, this library provides the [macroref BOOST_CONTRACT_CHECK] macro that allows to completely remove compile-time and run-time overhead of implementation checks when [macroref BOOST_CONTRAT_NO_CHECKS] is defined (see __Disable_Contract_Checking__ and __Disable_Contract_Compilation__ for similar considerations for all other contract conditions supported by this library), for example (see also [@ ../../example/features/check.cpp =check.cpp=]):

[check_macro]

These implementation checks are essentially equivalent to using the C-style `assert` macro but with the following differences:

* A failure of these implementation checks will call [funcref boost::contract::check_failure] (see also [funcref boost::contract::set_check_failure] and [funcref boost::contract::get_check_failure]).
* These implementation checks are automatically disabled when other contract conditions specified using this libraries are being checked already (to avoid infinite recursion).
* These implementation checks are disabled defining [macroref BOOST_CONTRACT_NO_CHECKS] (instead of `NDEBUG` for disabling `assert`).

[endsect]

[section Old Values at Body]

In the examples seen so far old value variables of type [classref boost::contract::old_ptr] are initialized to a copy of the expression passed to [macroref BOOST_CONTRACT_OLDOF] at the point of their declaration.
This is correctly done before the function body is executed but it is also done before the contract is executed, therefore even before class invariants at function entry and preconditions are checked.

This might work well in most cases, however in general old values should be copied before executing the function body but after checking entry class invariants and preconditions (see __Assertions__).
There can be cases in which it makes sense to evaluate the expressions passed to [macroref BOOST_CONTRACT_OLDOF] only assuming that the assertions programmed in the class invariants and preconditions are first checked to be true.

For that, this library also allows to construct [classref boost::contract::old_ptr] variables using their default constructor (equivalent to a null pointer) and to assign them later to a copy of the expression passed to [macroref BOOST_CONTRACT_OLDOF] in a nullary functor [^['h]]`()` passed to `.old(`[^['h]]`)`.
The functor [^['h]]`()` is called by this library before the function body is executed but only after class invariants and preconditions are checked:
[footnote
*Rationale:*
Functors for preconditions, old value assignments, postconditions, and exception guarantees are all optional but when specified, they must be specified in that order.
Such order is enforced by the fact that [classref boost::contract::specify_precondition_old_postcondition_except], [classref boost::contract::specify_old_postcondition_except], [classref boost::contract::specify_postcondition_except], [classref boost::contract::specify_except], and [classref boost::contract::specify_nothing] provide a progressively decreasing subset of the `.precondition(...)`, `.old(...)`, `.postcondition(...)`, and `.except(...)` member functions.
The enforced order for specifying preconditions, old value assignments, postconditions, and exception guarantees makes logical sense because it follows the order at which these are executed at run-time.
Other contract programming frameworks allow to mix this order, that could have been implemented for this library as well but it would have complicated somewhat the library implementation while adding no real value (arguably creating confusion in user code by not enforcing a consistent order for specifying contract conditions).
]

    boost::contract::old_ptr<...> old_``[^['name]]``;                 // Default constructor (i.e., null pointer).
    ...
    boost::contract::guard c = boost::contract::function()  // Same for all other contracts.
        ...
        .old([&] {                                          // Capture by reference...
            old_``[^['name]]`` = BOOST_CONTRACT_OLDOF(``[^['expression]]``);    // ...but modify only old values.
            ...
        })
        .postcondition([&] {
            BOOST_CONTRACT_ASSERT(*old_``[^['name]]`` ...);           // Never null here.
            ...
        })
        .except([&] {
            BOOST_CONTRACT_ASSERT(*old_``[^['name]]`` ...);           // Never null here.
            ...
        })
    ;

For example, the following old value expression `s[index]` passed to [macroref BOOST_CONTRACT_OLDOF] is valid only after the precondition has checked that `index` is within range `index < s.size()`.
Therefore, `old_y` is first declared using its default constructor (i.e., initialized to a null pointer) and later assigned to a copy of `s[index]` in `.old(...)` after the precondition has checked that `index` is in range (see also [@../../example/features/old.cpp =old.cpp=]):

[import ../example/features/old.cpp]
[old]

The functor passed to `.old(...)` should capture all variables it needs to evaluate and copy old value expressions.
In general, these variables should be captured by reference and not by value (because old values need to make copies of the values the captured variables will have just before executing the function body, and not copy the values these variables had when the functor passed to `.old(...)` was first declared).
In any case, the functor passed to `.old(...)` should modify only old values and not the values of other captured variables (see also __Constant_Correctness__).

This library will automatically call the failure handler [funcref boost::contract::old_failure] if calling the functor specified via `.old(...)` throws an exception (by default, this handler prints an error message to `std::cerr` and terminates the program calling `std::terminate`, but see __Throw_on_Failure__ to throw exceptions, exit the program with an error code, etc.).

[note
If old value pointers are initialized at the point of their construction instead of using `.old(...)` then an exception thrown by the old value expression [macroref BOOST_CONTRACT_OLDOF], or more in general any exception thrown by the old value pointer initialization, will result in that exception being thrown up the stack by the enclosing user-defined function.
This is arguably less correct than calling [funcref boost::contract::old_failure] because an exception thrown by an old value copy causes the program to fail checking its postconditions and exception guarantees but should not automatically causes the enclosing user-defined function to thrown an exception (this might not be a significant difference in practice, or it could be an additional reason to use `.old(...)` instead of copying old values when they are declared before the contract).
[footnote
*Rationale:*
It would be possible to wrap all old value operations ([classref boost::contract::old_ptr] copy constructor, [funcref boost::contract::make_old], etc.) in try-catch statements so this library will call [funcref boost::contract::postcondition_failure] also when old values are copied when they are constructed outside `.old(...)`.
However, that will prevent this library from knowing the [enumref boost::contract::from] parameter which will not be viable (specifically because destructors can have postconditions so that parameter is necessary to make sure user-defined failure handlers can be programmed to never throw from destructors as C++ requires).
]
]

[endsect]

[section Named Overrides]

The function names passed to [macroref BOOST_CONTRACT_OVERRIDE] and [macroref BOOST_CONTRACT_OVERRIDES] should never start with an underscore to avoid generating names containing double underscores `override__...` (which are reserved by the C++ standard).
There is a separate macro [macroref BOOST_CONTRACT_NAMED_OVERRIDE] that can be used to explicitly specify the name of the type that will be passed to [funcref boost::contract::public_function] as a template argument:
[footnote
*Rationale:*
A different macro [macroref BOOST_CONTRACT_NAMED_OVERRIDE] is used instead of overloading [macroref BOOST_CONTRACT_OVERRIDE] using variadic macros because the override macros cannot be programmed manually by the users so making them variadic would prevent to use this library on compilers that do not support variadic macros (see also __No_Macros__).
]

    BOOST_CONTRACT_OVERRIDE(``[^['function-name]]``)                  // Generate `override_...`.
    BOOST_CONTRACT_NAMED_OVERRIDE(``[^['type-name]]``, ``[^['function-name]]``) // Generate `type-name`.

For example, the following public function override is named `_1` so `BOOST_CONTRACT_OVERRIDE(_1)` would generate a type named `override__1` (which is reserved in C++ because it contains double underscores `__`), `BOOST_CONTRACT_NAMED_OVERRIDE(override1, _1)` is used to name the type `override1` instead (see also [@../../example/features/named_override.cpp =named_override.cpp=]):

[named_override]

The [macroref BOOST_CONTRACT_NAMED_OVERRIDE] macro can also be used when the name `override_`[^['function-name]] generated by [macroref BOOST_CONTRACT_OVERRIDE] would clash with other names in user code, to generate names in CamelCase or in any other style, in any other case when programmers need or want to generate names different from `override_...`.

Note that there is not a `BOOST_CONTRACT_NAMED_OVERRIDES` macro so [macroref BOOST_CONTRACT_NAMED_OVERRIDE] needs to be invoked separately on each function name (there is instead a [macroref BOOST_CONTRACT_OVERRIDES] macro as seen in __Public_Function_Overrides__).
[footnote
*Rationale:*
The syntax for invoking a possible `BOOST_CONTRACT_NAMED_OVERRIDES` macro would need to be something like `BOOST_CONTRACT_NAMED_OVERRIDES((`[^['type-name1]]`, `[^['function-name1]]`), (`[^['type-name2]]`, `[^['function-name2]]`), ...)`.
The authors felt this syntax is more cumbersome than repeating single `BOOST_CONTRACT_NAMED_OVERRIDE` invocations `BOOST_CONTRACT_NAMED_OVERRIDE(`[^['type-name1]]`, `[^['function-name1]]`) BOOST_CONTRACT_NAMED_OVERRIDE(`[^['type-name2]]`, `[^['function-name2]]`) ...` so decided not to provide the `BOOST_CONTRACT_NAMED_OVERRIDES` macro.
]

[endsect]

[section Access Specifiers]

As we have seen so far, programmers are required to decorate their classes declaring extra members that are internally used by this library to check contracts:

* The `invariant` and `static_invariant` member functions (used to check class invariants, see also __Class_Invariants__).
* The `base_types` member type declared via [macroref BOOST_CONTRACT_BASE_TYPES] (used to implement subcontracting, see also __Public_Function_Overrides__).
* The `override_...` member types declared via [macroref BOOST_CONTRACT_OVERRIDE], [macroref BOOST_CONTRACT_NAMED_OVERRIDE], and [macroref BOOST_CONTRACT_OVERRIDES] (used to implement subcontracting for overriding functions, see also __Public_Function_Overrides__).
[footnote
*Rationale:*
The internals of the `override_...` type generated by [macroref BOOST_CONTRACT_OVERRIDE] use names reserved by this library to users should not actually use such a type even when it is defined `public`.
(On a related note, in theory using C++14 generic lambdas, the [macroref BOOST_CONTRACT_OVERRIDE] macro could be re-implemented in a way so it can be expanded at function scoped, instead of class scoped.)
]

In general, these members must be declared `public` in the user class in order for this library to access them.
[footnote
There is some variability among compiler implementations:
the `base_types` member type needs to be declared `public` on all MSVC, GCC, ang CLang;
the `invariant` and `static_invariant` member functions need to be declared `public` on MSVC, but not on GCC and CLang;
the `override_...` member types do not have to be declared `public` on any compiler.
In any case, declaring the [classref boost::contract::access] class `friend` allows to always declare all these extra members `private` on all compilers.
]
However, programmers might need to more precisely control the public members of their classes to prevent incorrect access of encapsulated members.
All these members can be declared `private` as long as the [classref boost::contract::access] class is declared as `friend` of the user class, for example (see also [@../../example/features/access.cpp =access.cpp=]):

[import ../example/features/access.cpp]
[access]

This technique is not used in most examples of this documentation only for brevity, but programmers are encouraged to use it in real code.

[warning
Not declaring this class friend of user-defined classes will cause compiler errors on some compilers (e.g., MSVC) because the private members needed to check the contracts will not be accessible.
On other compilers (e.g., GCC and CLang), the private access will instead fail SFINAE and no compiler error will be reported while invariants and subcontracting will be silently skipped at run-time.
Therefore, programmers must make sure to either declare invariant functions and base types @c typedef as public members or to declare this class as friend.
]

[endsect]

[section Throw on Failure]

If a conditions checked using [macroref BOOST_CONTRACT_ASSERT] is evaluated to be `false` or more in general if any of the specified contract code throws an exception (in fact, [macroref BOOST_CONTRACT_ASSERT] simply expands to code that throws a [classref boost::contract::assertion_failure] exception, see also __No_Macros__), this library will call an appropriate /contract failure handler/ function as follow:

# False [macroref BOOST_CONTRACT_ASSERT] assertions and exceptions thrown from preconditions `.precondition(...)` call [funcref boost::contract::precondition_failure].
# False [macroref BOOST_CONTRACT_ASSERT] assertions and exceptions thrown from postconditions `.postcondition(...)` call [funcref boost::contract::postcondition_failure].
# False [macroref BOOST_CONTRACT_ASSERT] assertions and exceptions thrown from exception guarantees `.except(...)` call [funcref boost::contract::except_failure].
# False [macroref BOOST_CONTRACT_ASSERT] assertions and exceptions thrown from class invariants `invariant()` and `static_invariant()` call [funcref boost::contract::entry_invariant_failure] when checked at function entry and [funcref boost::contract::exit_invariant_failure] when checked at function exit.
# Exceptions thrown from old value copies at body `.old(...)` call [funcref boost::contract::old_failure].
# False [macroref BOOST_CONTRACT_ASSERT] assertions and exceptions thrown from implementation checks `boost::contract::check c = `[^['nullary-functor]] and [macroref BOOST_CONTRACT_CHECK] call [funcref boost::contract::check_failure].

By default, these contract failure handlers print a message to the standard error `std::cerr` and then terminate the program calling `std::terminate`.
[footnote
*Rationale:*
In general, when a contract fails the only safe thing to do is to terminate program execution (because the contract failure indicates a bug in the program, and in general the program is in a state for which no operation can be successfully performed, so the program should be stopped).
Therefore, this library terminates the program by default.
However, for specific applications, programmers could implement some fail-safe mechanism for which some mission-critical operation can always be performed upon handling failures so this library allows programmers to override the default contract failure handlers to fully customize how to handle contract failures.
]
However, programmers can override the default contract failure handlers to perform any custom action on contract failure using the following functions respectively:

# [funcref boost::contract::set_precondition_failure]
# [funcref boost::contract::set_postcondition_failure]
# [funcref boost::contract::set_except_failure]
# [funcref boost::contract::set_entry_invariant_failure] and [funcref boost::contract::set_exit_invariant_failure], or [funcref boost::contract::set_invariant_failure] (to set both entry and exit invariant failure handlers at once for convenience)
# [funcref boost::contract::set_old_failure]
# [funcref boost::contract::set_check_failure]

These `set_..._failure(`[^['f]]`)` function calls return the contract failure handler functor [^['f]] that they take as input parameter, for example (see also [@../../example/features/throw_on_failure.cpp =throw_on_failure.cpp=]):
[footnote
*Rationale:*
Even if somewhat different from `std::set_terminate`, the `set_..._failure` functions take a functor as parameter (so to handle not just function pointers, but also lambdas, binds, etc.) and return this same functor as result (so they can be concatenated).
The related `get_..._failure` functions can be used to query the functors currently set for each contract.
]

[import ../example/features/throw_on_failure.cpp]
[throw_on_failure_handlers]

When programming custom failure handlers that trow exceptions instead of terminating the program, programmers should be wary of the following:

* In order to comply with C++ and STL exception safety, destructors should never throw.
This library passes a [classref boost::contract::from] parameter to the contract failure handlers for preconditions ([funcref boost::contract::precondition_failure]), postconditions ([funcref boost::contract::postcondition_failure]), class invariants ([funcref boost::contract::entry_invariant_failure] and [funcref boost::contract::exit_invariant_failure]), and old value copies at body ([funcref boost::contract::old_failure]).
This [classref boost::contract::from] parameter indicates if the contract failure occurred in a destructor, constructor, or function call so programmers can use it code custom contract failure hander functions that never throw from destructors (in the example above, contract failures from destructors are simply ignored even if that is probably never a safe thing to do in real code).
* C++ stack-unwinding will executed base class destructors even when the derived class destructor trows an exception.
Therefore, the contracts of base class destructors will continue to be checked when contract failure handlers are programmed to throw exceptions on contract failures from destructors.
* Implementation checks can appear in any code, including destructor implementation code, so [funcref boost::contract::check_failure] should also never throw, or implementation checks should never be used in destructors.
* The contract failure handler for exception guarantees [funcref boost::contract::except_failure] should also never throw (regardless of its [classref boost::contract::from] parameter).
That is because when [funcref boost::contract::except_failure] is called there is already an active exception on the stack, the exception that triggered the exception guarantees to be checked in the first place (throwing an exception while there is already an active exception will force C++ to terminate the program).

[note
It is the responsibility of the programmers to decide how to handle contract failures from destructors when they program custom contract failure handlers that throw exceptions instead of terminating the program (given that C++ and STL exception safety rules requires destructors to never throw).
This is not a simple dilemma and it might be one more reason to terminate the program instead of throwing exceptions when assertions fail in C++ (as this library and also the C-style `assert` do by default).
]

Contract assertions can be programmed to throw [classref boost::contract::assertion_failure] using [macroref BOOST_CONTRACT_ASSERT]`(`[^['condition]]`)` as we have seen so far (see also __No_Macros__).
Alternatively, contract assertions can be programmed to throw any other exception (including user-defined exceptions) using code similar to the following:

    if(!``[^['condition]]``) throw ``[^['exception-object]]``;

For example, if the following precondition functor throws the user-defined exception `too_large_error` then the contract failure handler [funcref boost::contract::precondition_failure] will be called (same as when preconditions programmed using [macroref BOOST_CONTRACT_ASSERT] fails, see also [@../../example/features/throw_on_failure.cpp =throw_on_failure.cpp=]):

[throw_on_failure_class_begin]
[throw_on_failure_ctor]
[throw_on_failure_class_end]

Finally, note that the exception specifiers `noexcept` (and `throw`, deprecated since C++11) of the enclosing operation declaring the contract apply to the contract code itself.
Therefore, even if the contract failure handlers are reprogrammed to throw exceptions in case of contract failures, such exception will never be thrown outside the context of the enclosing operation if that is not in accordance with the exception specifiers of such operation (notably all destructors are implicitly declared `noexcept(true)` in C++11).
For example, the following code will never throw from the destructor, not even if the class invariants checked at destructor entry throw `too_large_error` and the contract failure handlers for invariants are programmed to throw from destructors as well (the program will always terminate in this case instead, see also [@../../example/features/throw_on_failure.cpp =throw_on_failure.cpp=]):

[throw_on_failure_class_begin]
[throw_on_failure_dtor]
[throw_on_failure_class_end]
[throw_on_failure_bad_handler]

[endsect]

[endsect]

