
[section Advanced Topics]

This section illustrates more advanced uses of this library.

[section Optional Return Value]

It is possible to use `boost::optional` to handle the return value when programmers cannot construct the result variable at its point of declaration before the contract (e.g., because an appropriate constructor for the return type is not available at that point, or just because it would be too expensive to execute an extra initialization of the result value at run-time).
[footnote
*Rationale.*
`boost::optional` was used instead of `std::optional` because this library is designed to work well with Boost and because `std::optional` is not part of the C++ standard yet.
]
For example (see also [@../../example/features/optional_result.cpp =optional_result.cpp=]):

[import ../example/features/optional_result.cpp]
[optional_result]

In this example the return type `surface` does not have a default constructor that can be used to initialize `result` when it is first declared.
The `surface` non-default constructor should not be used to initialize `result` by passing it `edge * edge` and `edge * 4` because such operations are logically the responsibility of the function body (in fact, it makes logical sense to do such multiplications only after `edge` has been checked to be positive by the preconditions).
Therefore, instead of initializing `result` with some arbitrary `area` and `perimeter` values (e.g., `0` and `0`, or `-1` and `-1`), `boost::optional` is used in this example to not initialize `result` with a return value when it is first declared before the contract.
`result` is initialized later in the function body when the function is about to return and directly using the correct return value `result = surface(edge * edge, edge * 4)`.

When this technique is used, programmers have to make sure that each return statement in the function is of the form:
    
    boost::optional<...> result;
    ...
    return *(result = ...);

This also ensures that `result` is always set to the return value before the postconditions are checked.
Therefore, programmers can always dereference `result` in postconditions to access the return value (using `operator*` and `operator->` as usual with `boost::optional`, and without having to explicitly check if `result` is an empty `boost::optional` object).

Similarly, `boost::optional` can be used for return values passed to virtual and overriding functions (see __Pure_Virtual_Public_Functions__ for an example).

[endsect]

[section Pure Virtual Public Functions]

In C++, pure virtual functions are allowed to have a /default implementation/ as long as such implementation is programmed out-of-line and defined outside the class declaring the pure virtual function as `virtual ... = 0;`.
Contracts for pure virtual public functions are programmed using the [funcref boost::contract::public_function] function very much like contracts for virtual public functions, so all consideration made in __Virtual_Public_Functions__ apply.
However, in this case contracts are always programmed out-of-line, in the default implementation of the pure virtual function.

For example, note how the following `shape::area` default implementation (which is used to program the contract) must be defined out-of-line and therefore outside the `shape` class declaration (see also [@../../example/features/pure_virtual.cpp =pure_virtual.cpp=]):

[import ../example/features/pure_virtual.cpp]
[pure_virtual]

This library will never actually execute the pure virtual function body while it is calling the pure virtual function default implementation to check its contract for subcontracting.
Therefore, programmers can safely `assert(false)` at the beginning of the body if they intend for that body to never be executed (or they can program a working body in case they want to take full advantage of C++ pure virtual function default implementation outside of what strictly needed by this library).
Finally, in this example, the pure virtual function does not have enough information to meaningfully initialize the return value `result` (it is missing the actual shape dimensions like edges, radius, etc.) so `boost::optional` is used to declare the return value (see also __Optional_Return_Value__).

As already discussed in __Private_and_Protected_Functions__, private and protected member functions do not check class invariants and do not subcontract (not even when they are virtual or pure virtual).
Therefore, no contract is ever programmed for a private or protected pure virtual function (because that contract would never be checked during subcontracting anyway).

[endsect]

[section Overloads and Named Overrides]

Calls to [funcref boost::contract::public_function] from different overloaded functions reuse the same `override_`[^['function-name]] template argument.
Therefore, [macroref BOOST_CONTRACT_OVERRIDE][^(['function-name])] is used only once in a given class even when [^['function-name]] is overloaded.
For example (see also [@../../example/features/override_overload.cpp =override_overload.cpp=]):

[import ../example/features/override_overload.cpp]
[override_overload]

Note that the function name passed to [macroref BOOST_CONTRACT_OVERRIDE] should never start with an underscore to avoid generating names containing double underscores `override__...` that are reserved by the C++ standard.
There is a separate macro [macroref BOOST_CONTRACT_NAMED_OVERRIDE] that can be used to explicitly specify the name of the type that will be passed to [funcref boost::contract::public_function] as a template argument:
[footnote
*Rationale.*
It is best to use a different macro name [macroref BOOST_CONTRACT_NAMED_OVERRIDE] instead of overloading [macroref BOOST_CONTRACT_OVERRIDE] using variadic macros because the override macros cannot be programmed manually by the users so making them variadic macros would prevent using this library on compilers that do not support variadic macros (see also __No_Macros__).
]

    BOOST_CONTRACT_OVERRIDE(``[^['function-name]]``) // Generate `override_...`.
    BOOST_CONTRACT_NAMED_OVERRIDE(``[^['type-name]]``, ``[^['function-name]]``)

This second macro can be used for function names that start with an underscore `_...`, when the name `override_`[^['function-name]] clashes with another name the user class, or in any other case when programmers need to generate a name different than `override_...`.
For example (see also [@../../example/features/named_override.cpp =named_override.cpp=]):

[import ../example/features/named_override.cpp]
[named_override]

[endsect]

[section Volatile Public Functions]

TODO

[endsect]

[section Old Values at Body]

TODO

[import ../example/features/old.cpp]
[old]

[endsect]

[section Assertion Requirements (Static-If)]

In general, assertions can introduce a new set of requirements on the types used by the program: Some of the type requirements might be necessary only to program the assertions and they would not be required by the program otherwise.

* In some cases it might be acceptable, or even desirable, to cause a compile-time error when a program uses types that do not provide all the operations needed to check contract assertions (because it is not possible to fully check the correctness of the program as stated by the contracts).
In these cases, programmers can specify contract assertions as we have seen so far, and compilation will fail if user types do not provide all operations necessary to check the contracts.
* However, in other cases it might be desirable that adding contracts to a program does not alter its type requirements and that assertions are simply not checked when user types do not provide all the operations necessary to check them.
With this library, this can be done using [funcref boost::contract::call_if] and [funcref boost::contract::call_if_c].

For example, let's consider the STL `vector<T>` class template.
This class template (as specified by the STL without the contracts) does not normally require that `T` has an equality operator `==` (it only requires `T` to be copy constructible).
However, the full contracts of the `vector<T>::push_back(value)` member function include a postcondition `back() == value` which introduces the new requirement that `T` must have an equality operator `==`.
Programmers can specify this postcondition as-is an let the program fail to compile when users instantiate this template with a type `T` that does not provide an equality operator `==`.
Otherwise, programmers can specify this postcondition using [funcref boost::contract::call_if] so to check the assertion only for types `T` that have an equality operator `==`, and trivially check `true` otherwise (see also [@../../example/features/call_if.cpp =call_if.cpp=]):

[import ../example/features/call_if.cpp]
[call_if]

[funcref boost::contract::call_if] takes a condition template parameter as a boolean meta-function.
It takes a "then" nullary functor `t`, it calls and returns `t()` when the boolean meta-function evaluates to `true` at compile-time (thus `t()` must be valid code only in this case).
It provides an `else_` member to specify an "else" nullary functor `e`, it calls and returns `e()` when the boolean meta-function evaluates to `false` at compile-time (thus `e()` must be valid code only in this case).
It also provides an `else_if` member that can be used (multi times) to specify other boolean meta-function conditions and "then" and "else" nullary functors to be evaluated and valid only when the boolean meta-function is `false` at compile-time.
`else_` and `else_if` are optional if `t()` return value is `void` (otherwise the return types of `t()`, `e()`, and all the other nullary functors passed to `else_if` must all be compatible).
(There are also alternative versions named [funcref boost::contract::call_if_c] and `else_if_c` that take boolean constants instead of boolean meta-function conditions as template parameters.)

    boost::contract::call_if<``[^['boolean-meta-function-1]]``>(
        ``[^['then-nullary-functor-1]]``
    ).else_if<``[^['boolean-meta-function-2]]``>( // Optional.
        ``[^['then-nullary-functor-2]]``
    )
    ``[^['...]]`` // Else-if can be repeated zero or more times.
    .else_( // Optional for functors returning `void`.
        ``[^['else-nullary-functor]]``
    )

Therefore, the above `push_back` example calls (via `bind`) the functor `std::equal_to<T>()(boost::cref(back()), boost::cref(value))` that checks the postcondition `back() == value` requiring `T`'s equality operator `==`, but only when the `boost::has_equal<T>` meta-function evaluates to `true` at compile-time.
Otherwise, the lambda function `[] { return true; }` is used to trivially evaluate the postcondition assertion to be `true` when `T` does not have an equality operator `==`.

[heading Old Value Requirements]

TODO

[heading Static-If (C++14)]

[funcref boost::contract::call_if] is a general-purpose facility and it can be used together with C++14 generic lambdas to implement statements similar to `static if` (at least at function scope, see also [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3613.pdf N3613]).
For example, consider the following implementation of `std::advance` that uses `static if`-like statements implemented via [funcref boost::contract::call_if] (see also [@../../example/features/static_if_cxx14.cpp =static_if_cxx14.cpp=]):

[import ../example/features/static_if_cxx14.cpp]
[static_if_cxx14]

This implementation is much more concise, easy to read and maintain than the usual implementation of `std::advance` that uses tag dispatching.
[footnote
`boost::hana::if_` can also be used to emulate function scope `static if` with C++14 generic lambdas.
]

[endsect]

[section Access]

As we have seen, this library requires programmers to augment their classes declaring special members that are internally used to implement contracts:

* The `invariant` and `static_invariant` member functions (used by this library to check class invariants).
* The `base_types` member type (used by this library to implement subcontracting).
* The `override_`[^['function-name]] member type (used by this library to implement subcontracting for overriding functions).

Normally, some of these members must be public in order to be accessible by this library.
However, in some cases programmers might need to exactly control the public members of their classes in order to prevent users from incorrectly accessing encapsulated members (this might be especially true in large projects).

`override_`[^['function-name]] never needs to be `public` and programmers can always declare it using [macroref BOOST_CONTRACT_OVERRIDE] in a `private` (or `protected`) section of the class.
[footnote
*Rationale.*
The internals of the `override_...` type generated by [macroref BOOST_CONTRACT_OVERRIDE] use names reserved by this library to users are not able to actually use such a type even when it is defined as a `public` member.
In theory, using C++14 generic lambdas, the [macroref BOOST_CONTRACT_OVERRIDE] macro could be re-implemented in a way so it can be expanded at function scoped (instead of class scoped).
]
`invariant`, `static_invariant`, and `base_types` normally need to be `public`, but programmers can declare them in a `private` (or `protected`) section of the class as long as they also declare the [classref boost::contract::access] class as `friend`.
For example (see also [@../../example/features/access.cpp =access.cpp=]):

[import ../example/features/access.cpp]
[access]

This technique is not used in most examples of this documentation only for brevity, but programmers are encouraged to use it in real code.

See also __Base_Types__, __Class_Invariant__, and __Overloads_and_Named_Override__ to declare these members with different names (e.g., when they clash with other names in the user-defined class).

[endsect]

[section Separate Body Implementation]

Contracts are part of the program specification and not of its implementation (see also __Specification_and_Implementation__).
However, this library uses function definitions to program the contracts so contract code will normally appear together with the function implementation code.
Contract code programmed with this library must always appear at the very top of the function definition so programmers will easily be able to distinguish it from the rest of function implementation in any case (so it is not a real problem in practise).

In some cases, it might be desirable to completely separate the contract code from the code that implements the function body implementation code.
For example, this could be necessary for software that ships only header files and pre-compiled source code to its users (notably, that cannot be done for template code in C++).
If the contracts are programmed in the function definitions that are pre-compiled with the source code, users will not be able to inspect the contract code to understand semantics and usage of the functions (again, this might not be a real problem in practice for example if contract code is already being extracted from the source code and presented as part of the documentation of the shipped software).

In such cases, the function implementation can be programmed in an extra /body function/ (e.g., named `..._body`) that is defined in the source code.
The original function definition remains in the header file instead, it programs the contract and simply calls the extra body function.
At the cost of programmers writing an extra function declaration for the body function, this technique allows to keep the contract code in header files while separating the body implementation code to source files (with the limitation that constructor member initialization lists must still be programmed in the header files because that is where the originally constructors are actually defined).

For example, the following header file only contains function declarations and contract code (see also [@../../example/features/separate_body.hpp =separate_body.hpp=]):

[import ../example/features/separate_body.hpp]
[separate_body_hpp]

Instead, the code implementing the function bodies is programmed in a separate source file (see also [@../../example/features/separate_body.cpp =separate_body.cpp=]):

[import ../example/features/separate_body.cpp]
[separate_body_cpp]

The same technique can be used for free, private, and protected functions.

[endsect]

[section Throw on Failure]

If a condition checked using [macroref BOOST_CONTRACT_ASSERT] is `false` or if code specified in preconditions, postconditions, and class invariants throws an exception, this library calls the /contract failure handler/ functions [funcref boost::contract::precondition_failure], [funcref boost::contract::postcondition_failure], [funcref boost::contract::entry_invariant_failure], or [funcref boost::contract::exit_invariant_failure] respectively (in fact, [macroref BOOST_CONTRACT_ASSERT] simply expands to code that throws a [classref boost::contract::assertion_failure] exception, see also __No_Macros__).

By default, the contract failure handler functions print a message to the standard error `std::cerr` and then terminate the program calling `std::terminate`.
[footnote
*Rationale.*
In general, when a contract fails the only safe thing to do is to terminate the program execution (because the contract failure indicates a bug in the program, and in general the program is in a state for which no operation can be successfully performed, so the program should be stopped).
Therefore, this library terminates the program by default.
However, for specific applications, programmers could implement some fail-safe mechanism for which some mission-critical operation can always be performed upon handling failures so this library allows programmers to override the default contract failure handlers to fully customize how to handle contract failures.
]
However, programmers can override the default contract failure handlers to perform any custom action on contract failure using [funcref boost::contract::set_precondition_failure], [funcref boost::contract::set_postcondition_failure], [funcref boost::contract::set_entry_invariant_failure], [funcref boost::contract::set_exit_invariant_failure], [funcref boost::contract::set_invariant_failure] (to set both entry and exit invariant failure handlers at once for convenience), or [funcref boost::contract::set_failure] (to set all failure handlers at once for convenience).
For example (see also [@../../example/features/throw_on_failure.cpp =throw_on_failure.cpp=]):

[import ../example/features/throw_on_failure.cpp]
[throw_on_failure_handler]

Note that in order to comply with C++ and STL exception safety rules, destructors should never throw.
This library passes a [classref boost::contract::from] parameter to the contract failure handler functions that indicates if the contract failure occurred in a destructor, constructor, or function call.
This way programmers can ensure to never throw from a destructor call (in the example above, contract failures from destructors are simply ignored even if that is probably never a safe thing to do in real code).
[footnote
It is the responsibility of the programmers to decide how to handle contract failures from destructors when they reprogram the contract failure handlers to throw exceptions instead of terminating the program (given that C++ and STL exception safety rules requires destructors to never throw).
This is not a simple dilemma and it might be one more reason to terminate the program instead of throwing exceptions when contract assertions fail (as this library does by default).
]

The contract assertions can be programmed to throw [classref boost::contract::assertion_failure] using [macroref BOOST_CONTRACT_ASSERT] (see also __No_Macros__) or to throw any other exception using code similar to:

    if(``[^['error-condition]]``) throw ``[^['exception-object]]``;

For example (see also [@../../example/features/throw_on_failure.cpp =throw_on_failure.cpp=]):

[throw_on_failure_cstring]

[endsect]

[section Disable Contract Checking]

Checking contracts adds run-time overhead and can slow down program execution (see also __Benefits_and_Costs__).
Therefore, programmers can define the following macros (`-D` option in Clang and GCC, `/D` option in MSVC, etc.) to instruct this library to not check specific set of contracts at run-time: [macroref BOOST_CONTRACT_NO_PRECONDITIONS] (do not check preconditions), [macroref BOOST_CONTRACT_NO_POSTCONDITIONS] (do not check postconditions), [macroref BOOST_CONTRACT_NO_ENTRY_INVARIANTS] (do not check invariants at call entry), [macroref BOOST_CONTRACT_NO_EXIT_INVARIANTS] (do not check invariants at call exit), and [macroref BOOST_CONTRACT_NO_INVARIANTS] (do not check invariants at both call entry and exit).
By default, none of these macros are defined so this library checks all contracts.

For example, programmers could decide to check all contracts during early development builds, but later check only preconditions and maybe entry invariants for release builds by defining [macroref BOOST_CONTRACT_NO_POSTCONDITIONS] and [macroref BOOST_CONTRACT_NO_EXIT_INVARIANTS].

[heading Disable Contract Compilation]

Library macros can also be used to disable compile-time overhead introduced by contracts but at the cost of manually programming `#ifdef` statements around contract code.
The authors of this library do not recommend to use this practice unless strictly necessary because it makes the contract code more verbose, less readable, and in most applications the compile-time overhead of contracts should not represent an issue (it should be sufficient to disable contract checking at run-time as indicated before).

In any case, the following example illustrates how to completely disable contract code compilation for non-member functions (see also [@../../example/features/ifdef.cpp =ifdef.cpp=]):

[import ../example/features/ifdef.cpp]
[ifdef_function]

The same is done to disable contract code complication for private and protected functions.
For constructors, destructors, and public functions instead (see also [@../../example/features/ifdef.cpp =ifdef.cpp=]):

[ifdef_class]

As shown by the examples above:

* The [macroref BOOST_CONTRACT_NO_PRECONDITIONS] macro is defined by programmers and it can be used in `#ifdef` statements to disable compilation of preconditions, including constructor preconditions ([classref boost::contract::constructor_precondition]).
* The [macroref BOOST_CONTRACT_NO_POSTCONDITIONS] macro is defined by programmers and it can be used in `#ifdef` statements to disable compilation of postconditions, old value declarations, and old value assignments at body (`.old(...)`).
* The [macroref BOOST_CONTRACT_NO_INVARIANTS] macro is defined by programmers (or it will be automatically defined by this library if both [macroref BOOST_CONTRACT_NO_ENTRY_INVARIANTS] and [macroref BOOST_CONTRACT_NO_EXIT_INVARIANTS] are defined) and it can be used in `#ifdef` statements to disable compilation of class invariants (including static and volatile class invariants).
Also the [macroref BOOST_CONTRACT_NO_ENTRY_INVARIANTS] and [macroref BOOST_CONTRACT_NO_EXIT_INVARIANTS] macros are defined by programmers (or they will be both automatically defined by this library if [macroref BOOST_CONTRACT_NO_INVARIANTS] is defined) but these macros are not directly used to disable contract code compilation (only contract code run-time checking).
* The [macroref BOOST_CONTRACT_NO_CONSTRUCTORS] macro is automatically defined by this library (a compile-time error will be reported if programmes try to manually define this macro) and it can be used in `#ifdef` statements to disable compilation of constructor contract guards.
* The [macroref BOOST_CONTRACT_NO_DESTRUCTORS] macro is automatically defined by this library (a compile-time error will be reported if programmers try to manually define this macro) and it can be used in `#ifdef` statements to disable compilation of destructor contract guards.
* The [macroref BOOST_CONTRACT_NO_PUBLIC_FUNCTIONS] macro is automatically defined by this library (a compile-time error will be reported if programmers try to manually define this macro) and it can be used in `#ifdef` statements to disable compilation of public member function contract guards, base type `typedef`, extra [classref boost::contract::virtual_] function parameters, and [macroref BOOST_CONTRACT_OVERRIDE] declarations.
* The [macroref BOOST_CONTRACT_NO_FUNCTIONS] macro is automatically defined by this library (a compile-time error will be reported if programmers try to manually define this macro) and it can be used in `#ifdef` statements to disable compilation of contract guards for non-member functions as well as private and protected functions.
* The [macroref BOOST_CONTRACT_NO_ALL] macro is automatically defined by this library (a compile-time error will be reported if programmers try to manually define this macro) and it can be used in `#ifdef` statements to disable [classref boost::contract::access] friendship declarations and also inclusions of [headerref contract.hpp] (some of the other macros listed here can be used to selectively disable inclusion of =boost/contract/*.hpp= headers when they are used instead of [headerref contract.hpp].)

[endsect]

[section No Macros (No C++11)]

[import ../example/features/no_macros.cpp]

This section illustrates how to write contracts without using this library macros and programming the related code manually instead (a part from [macroref BOOST_CONTRACT_OVERRIDE] and [macroref BOOST_CONTRACT_NAMED_OVERRIDE] that cannot be programmed manually).

Some of this library macros are variadic macros, others are not (see below).
Variadic macros were officially added to the language since C++11.
However, C++ compilers have been supporting variadic macros as an extension for a long time, plus essentially all compilers that support C++11 lambda functions also support C++11 variadic macros (and this library might rarely be used without the convenience of C++11 lambda functions, see also __No_Lambda_Functions__).
Therefore this section can be considered more of a curiosity than anything else because programmers should seldom need to use this library without its macros.

[heading Overrides (Not Variadic)]

As shown in __Overriding_Public_Functions__ and __Overloads_and_Named_Overrides__, this library provides the [macroref BOOST_CONTRACT_OVERRIDE] and [macroref BOOST_CONTRACT_NAMED_OVERRIDE] macros to program overriding public functions.
These macros cannot be programmed manually, but these are not variadic macros and programmers should never need not to use them.
[footnote
*Rationale.*
These macros expand SFINAE-based introspection templates that cannot be reasonably programmed by users (that remains the case even if C++14 generic lambdas were to be used here).
]

[heading Assertions (Not Variadic)]

As shown in __Preconditions__, __Postconditions__, __Class_Invariants__, etc. this library provides the [macroref BOOST_CONTRACT_ASSERT] macro to assert contract conditions.
This is not a variadic macro and programmers should be able to use it on all C++ compilers.
However, this macro:

    BOOST_CONTRACT_ASSERT(``[^['boolean-condition]]``)

Simply expands to code equivalent to the following:

    if(!``[^['boolean-condition]]``) {
        throw boost::contract::assertion_failure(__FILE__, __LINE__,
                BOOST_PP_STRINGIZE(``[^['boolean-condition]]``));
    }

That is because this library considers any exception thrown from within preconditions, postconditions, and class invariants as a contract failure and reports it calling the related contract failure handler ([funcref boost::contract::precondition_failed], [funcref boost::contract::postcondition_failed], [funcref boost::contract::entry_invariant_failed] or [funcref boost::contract::exit_invariant_failed]).
In fact, if there is a need for it, programmers can always program contract assertions that throw user-defined exceptions without using [macroref BOOST_CONTRACT_ASSERT] (see also __Throw_on_Failure__):

    if(!``[^['boolean-condition]]``) throw ``[^['user-defined-exception]]``(...);

[heading Base Types (Variadic)]

As shown in __Base_Types__, this library provides the [macroref BOOST_CONTRACT_BASE_TYPES] variadic macro to declare a `base_types` member type that lists the public bases of a derived class.
Programmers can also declare `base_types` without using [macroref BOOST_CONTRACT_BASE_TYPES] at the cost of writing a bit more code manually (see also [@../../example/features/no_macros.cpp =no_macros.cpp=]):

[no_base_types_macro]

The `base_types` member type must be a `boost::mpl::vector` listing /only/ `public` base classes (because only public bases subcontract, see also __Function_Calls__).
[footnote
*Rationale.*
`boost::mpl::vector` is used because this library is design to work with other Boost libraries.
]
If the [macroref BOOST_CONTRACT_BASE_TYPES] macro is not used, it is the responsibility of the programmers to maintain the correct list of bases in the `boost::mpl::vector` each time the derived class inheritance list changes (this might complicate maintenance).
In general, it is recommended to use the [macroref BOOST_CONTRACT_BASE_TYPES] macro if possible.

[heading Old Values (Variadic)]

As shown in __Old_Values__ and __Virtual_Public_Functions__, this library provides the [macroref BOOST_CONTRACT_OLDOF] variadic macro to initialize old values.
Programmers can also initialize old values without using [macroref BOOST_CONTRACT_OLDOF] at the cost of writing a bit more code manually (see also [@../../example/features/no_macros.cpp =no_macros.cpp=]):

[no_oldof_macro]

C++ ternary operator `... ? ... : ...` must be used here to avoid evaluating and copying the old value expression (`size()` in this example) when old values are not being copied (because postcondition checking is disabled, within overridden virtual function calls for subcontracting, etc.).
[classref boost::contract::old]`()` creates an empty old value (that introduces no copy).
[funcref boost::contract::copy_old]`()` returns `true` if and only if old values are being copied.
When used in public virtual functions, programmers must pass the extra [classref boost::contract::virtual_]`* v` argument to [funcref boost::contract::copy_old]`(v)`, for example (see also [@../../example/features/no_macros.cpp =no_macros.cpp=]):

[no_virtual_oldof_macro]

In general, it is recommended to use the [macroref BOOST_CONTRACT_OLDOF] macro if possible.

[endsect]

[section No Lambda Functions (No C++11)]

This section illustrates how to use this library without C++11 lambda functions.
This presets some advantages:

* It allows to use this library on compilers that do not support C++11 lambda functions (essentially C++03 compilers can be used, see __No_Macros__ to also avoid using variadic macros).
* Functors can be programmed to fully enforce constant-correctness and other contract requirements at compile-time (see also __Constant_Correctness__).
[footnote
If C++ supported to capture lambda function variables by constant references `[const&] () { ... }` that could be used to program contract functors using lambda functions that also enforce __Constant_Correctness__ at compile-time (not that value captures cannot be used to program postconditions, plus it introduces an extra copy that might not always be possible or desirable).
]
* Contracts are automatically separated from function body implementations (see also __Specification_and_Implementation__ and __Separate_Body_Implementation__).

However, not using C++11 lambda functions comes to the significant cost of having to manually write a great deal of extra code to program the contract functors (therefore, the authors think this library is most useful when C++11 lambda functions can be used).

For example (see also [@../../example/features/no_lambdas.hpp =no_lambdas.hpp=] and [@../../example/features/no_lambdas.cpp =no_lambdas.cpp=]):

[import ../example/features/no_lambdas.hpp]
[no_lambdas_hpp]

[import ../example/features/no_lambdas.cpp]
[no_lambdas_cpp]

If programmers also want to fully enforce all contract programming constant-correctness requirements at compile-time, they should follow these rules when programming the contract functions (see also __Constant_Correctness__):

* In general, precondition and postcondition functions (e.g., named `..._precondition` and `..._postcondition`) should take their arguments by `const&` and they should be either `static` or `const` member functions.
However, postconditions can (but do not have to) take old value arguments by value (because these are pointers to `const` objects already).
* In general, old value functions (e.g., named `..._old`) should take their arguments by `const&` a part from old value pointers that should be taken by `&` (so only old value pointers can be modified), and they should be either `static` or `const` member functions.
* Constructor precondition and old value functions should be `static` (because constructor preconditions and old-values cannot access the object `this`, see also __Constructor_Calls__).
* Destructor postcondition functions should be `static` (because destructor postconditions cannot access the object `this`, see also __Destructor_Calls__).

Note that the extra contract functions also allowed to program only the contract code in the header file (see also __Specification_and_Implementation__).
All function body implementation code was instead programmed in the source file (including the constructor member initialization list, that could not be done with the technique illustrated by __Separate_Body_Implementation__).
[footnote
In this example, `bind` was used to generate nullary functors from the contract functions.
As always with `bind`, `cref` and `ref` must be used to bind arguments by `const&` and `&` respectively, plus it might be necessary to explicitly `static_cast` the function pointer passed to `bind` in case the bound function name is overloaded.
]

Finally, note that the extra contract functions can always be declared `private` if programmers need to exactly control the public members of the class (this was not done in this example only for brevity, see also __Access__).

[endsect]

[endsect]

