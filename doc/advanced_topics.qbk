
[section Advanced Topics]

This section illustrates more advanced uses of this library.

[section Old Values at Body]

In the examples seen so far old value variables of type [classref boost::contract::old_ptr] are initialized to a copy of the expression passed to [macroref BOOST_CONTRACT_OLDOF] at the point of their declaration.
This correctly is before the function body is executed but also before the contract is executed, therefore even before class invariants at function entry and preconditions are checked.

This is convenient and might be sufficient in most cases.
However, in general old values should be copied before executing the function body but after checking entry class invariants and preconditions (see __Assertions__).
There can be cases in which the expression passed to [macroref BOOST_CONTRACT_OLDOF] should be evaluated only if the assertions in class invariants and preconditions are checked to be true.

This library allows to construct [classref boost::contract::old_ptr] variables using their default constructor (equivalent to a null pointer) and then assign them later to a copy of the expression passed to [macroref BOOST_CONTRACT_OLDOF] in a functor with no parameter [^['h]]`()` passed to `.old(`[^['h]]`)`.
The nullary functor [^['h]]`()` is called by this library before the function body is executed but only after class invariants and preconditions are checked:

    boost::contract::old_ptr<...> old_``[^['name]]``;                 // Use default constructor.
    boost::contract::guard c = boost::contract::function()  // Same for all other contracts.
        ...
        .old([&] {                                          // Capture by reference...
            old_``[^['name]]`` = BOOST_CONTRACT_OLDOF(``[^['expression]]``);    // ...but modify only old values.
        })
        .postcondition([&] {
            BOOST_CONTRACT_ASSERT(*old_``[^['name]]`` ...);
            ...
        })
    ;

For example, the following old value expression `s[index]` passed to [macroref BOOST_CONTRACT_OLDOF] is valid only after the precondition has checked that `index` is within range `index < s.size()`.
Therefore, `old_y` is first declared using its default constructor (i.e., initialized to a null pointer) and later assigned to a copy of `s[index]` in `.old(...)` after the precondition has checked that `index` is in range (see also [@../../example/features/old.cpp =old.cpp=]):

[import ../example/features/old.cpp]
[old]

The functor passed to `.old(...)` should capture all variables it needs to evaluate and copy old value expressions.
In general, these variables should be captured by reference and not by value (because old values need to copy values the variables will have just before executing the function body, and not the value these variables had when the functor passed to `.old(...)` was first declared).
In any case, this functor should modify only old values and not the value of other captured variables (see also __Constant_Correctness__).

[endsect]

[section Optional Return Value]

It is possible to use `boost::optional` to handle the return value when programmers cannot construct the result variable at its point of declaration before the contract (e.g., because an appropriate constructor for the return type is not available at that point, or just because it would be too expensive to execute an extra initialization of the result value at run-time).
[footnote
*Rationale.*
`boost::optional` was used instead of `std::optional` because this library is designed to work well with Boost and because `std::optional` is not part of the C++ standard yet.
]
For example (see also [@../../example/features/optional_result.cpp =optional_result.cpp=]):

[import ../example/features/optional_result.cpp]
[optional_result]

In this example the return type `surface` does not have a default constructor that can be used to initialize `result` when it is first declared.
The `surface` non-default constructor should not be used to initialize `result` by passing it `edge * edge` and `edge * 4` because such operations are logically the responsibility of the function body (in fact, it makes logical sense to do such multiplications only after `edge` has been checked to be positive by the preconditions).
Therefore, instead of initializing `result` with some arbitrary `area` and `perimeter` values (e.g., `0` and `0`, or `-1` and `-1`), `boost::optional` is used in this example to not initialize `result` with a return value when it is first declared before the contract.
`result` is initialized later in the function body when the function is about to return and directly using the correct return value `result = surface(edge * edge, edge * 4)`.

When this technique is used, programmers have to make sure that each return statement in the function is of the form:
    
    boost::optional<...> result;
    ...
    return *(result = ...);

This also ensures that `result` is always set to the return value before the postconditions are checked.
Therefore, programmers can always dereference `result` in postconditions to access the return value (using `operator*` and `operator->` as usual with `boost::optional`, and without having to explicitly check if `result` is an empty `boost::optional` object).

[heading Virtual and Overriding Public Functions]

Similarly, `boost::optional` can be used for return values of virtual and overriding public functions.
As usual with non-void virtual and overriding public functions the return value `result` must be passed as a parameter to [funcref boost::contract::public_function] right after `v` (see also __Virtual_Public_Functions__).
This this case the functor passed to `.postcondition(...)` takes a parameter of type `boost::optional<`[^['result-type]]` const&> const&` (see __Pure_Virtual_Public_Functions__ for an example):
    
    boost::optional<``[^['return-type]]``> result;
    ...
    boost::contract::guard c = boost::contract::public_function(v, result, ...)
        ...
        .postcondition([&] (boost::optional<``[^['return-type]]`` const&> const& result) {
            ...
        }
    ;
    ...
    return *(result = ...);

The inner `const&` in the postcondition functor parameter type `boost::optional<... const&>` is mandatory (the outer `const&` in the postcondition functor parameter type `boost::optional<... const&> const&` is not).
[footnote
*Rationale.*
This library requires the postcondition functor parameter to be of type `boost::optional<... const&>` so the return value does not have to be copied (because of `&`) while postconditions are still prevented from changing it (because of `const`, see also __Constant_Correctness__).
Note that the library cannot require the actual functor parameter `result` to be `const&` instead (because programmers can always program the functor without specifying the `const&` outside the `boost::optional<... const&>` type).
]

[endsect]

[section Pure Virtual Public Functions]

In C++, pure virtual functions are allowed to have a /default implementation/ as long as such implementation is programmed out-of-line so defined outside the class declaring the pure virtual function as `virtual ... = 0;`.
Contracts for pure virtual public functions are programmed using the [funcref boost::contract::public_function] function like for (non-pure) virtual public functions, so all consideration made in __Virtual_Public_Functions__ apply.
However, in this case contracts are always programmed out-of-line, in the default implementation of the pure virtual function.

For example, note how the following `shape::get_surface` default implementation (which is used to program the pure virtual function contract) must be defined out-of-line and therefore outside the `shape` class declaration (see also [@../../example/features/pure_virtual_public.cpp =pure_virtual_public.cpp=]):

[import ../example/features/pure_virtual_public.cpp]
[pure_virtual_public]

This library will never actually execute the pure virtual function body while it is calling the pure virtual function default implementation to check its contract for subcontracting.
Therefore, programmers can safely `assert(false)` at the beginning of the body if they intend for that body to never be executed (or they can program a working body in case they need to use C++ pure virtual function default implementation outside of what strictly required by this library).

Note that because of subcontracting, preconditions of derived class functions are checked in __OR__ with preconditions of base class functions (see __Public_Function_Overrides__).
If base class member functions specify no precondition then preconditions specified by overriding functions in derived classes will have no effect (because when checked in __OR__ with the base class function that has no precondition they will always pass).
This correctly reflects the fact that the base class member function can be called in any context (because it has no precondition) and so must all its overriding function in derived classes in order for the derived class to act like the base class in virtue of inheritance.
However, it is sometimes acceptable for a base class to declare a pure virtual function with a precondition `BOOST_CONTRACT_ASSERT(false)` indicating that the pure virtual function must be redefined by derived classes (as always with pure virtual functions) and also that derived classes will be responsible to specify preconditions (this technique makes sense only for preconditions of pure virtual functions otherwise it will prevent a concrete base function from being ever called successfully).
For example (see also [@../../example/features/named_override.cpp =named_override.cpp=]):

[import ../example/features/named_override.cpp]
[named_override_pure_virtual_assert_false]

As already discussed in __Private_and_Protected_Functions__, private and protected member functions do not check class invariants and do not subcontract (not even when they are virtual or pure virtual).
Therefore, no contract is ever programmed for a private or protected pure virtual function (because that contract would never be checked during subcontracting anyway).

[endsect]

[section Overloaded Functions]

As seen in __Public_Function_Overrides__, [funcref boost::contract::public_function] takes a pointer to the enclosing function as a parameter when used in overriding public functions.
When an overriding public function is overloaded, the function pointer cannot be automatically deduced by the compiler so programmers have to use `static_cast` to resolve ambiguities (as usual with pointers to overloaded functions in C++).
[footnote
*Rationale.*
In oder to avoid copies, this library takes all contracted function arguments and the return value as references when passed to [funcref boost::contract::public_function] for overriding public functions.
Therefore, the library cannot differentiate the actual argument and return types of the contracted functions when they are passed by reference and when they are not.
As a result, the library cannot automatically reconstruct the contracted function pointer type which must be instead deduced from the function pointer explicitly passed by programmers to [funcref boost::contract::public_function] (in turn this requires using `static_cast` to resolve ambiguities as usual in C++ when obtaining the pointer of overloaded functions).
]
For example, note how `static_cast` is used in the following calls to [funcref boost::contract::public_function] (see also [@../../example/features/overload.cpp =overload.cpp=]):

[import ../example/features/overload.cpp]
[overload]

Overloaded functions have the same function name so the same [^override_['function-name]] type can be used as template parameter of [funcref boost::contract::public_function].
Therefore, [macroref BOOST_CONTRACT_OVERRIDE] only needs to be invoked once for any given function name even when the function name is overloaded (as shown in the example above).

[endsect]

[section Named Overrides]

The function name passed to [macroref BOOST_CONTRACT_OVERRIDE] should never start with an underscore to avoid generating names containing double underscores `override__...` that are reserved by the C++ standard.
There is a separate macro [macroref BOOST_CONTRACT_NAMED_OVERRIDE] that can be used to explicitly specify the name of the type that will be passed to [funcref boost::contract::public_function] as a template argument:
[footnote
*Rationale.*
A different macro [macroref BOOST_CONTRACT_NAMED_OVERRIDE] is used instead of overloading [macroref BOOST_CONTRACT_OVERRIDE] using variadic macros because the override macros cannot be programmed manually by the users so making them variadic would prevent the use of this library on compilers that do not support variadic macros (see also __No_Macros__).
]

    BOOST_CONTRACT_OVERRIDE(``[^['function-name]]``)                  // Generate `override_...`.
    BOOST_CONTRACT_NAMED_OVERRIDE(``[^['type-name]]``, ``[^['function-name]]``) // Generate `type-name`.

For example, the following overriding member function is named `_1` so `BOOST_CONTRACT_OVERRIDE(_1)` would generate a type named `override__1` (which is reserved in C++ because it contains double underscores `__`), `BOOST_CONTRACT_NAMED_OVERRIDE(override1, _1)` is used to name the type `override1` instead (see also [@../../example/features/named_override.cpp =named_override.cpp=]):

[named_override]

The [macroref BOOST_CONTRACT_NAMED_OVERRIDE] macro can be used for function names that start with an underscore `_...`, when the name `override_`[^['function-name]] generated by [macroref BOOST_CONTRACT_OVERRIDE] would clash with other names in the user code, to generate names in CamelCase or any other style, in any other case when programmers need or want to generate names different than `override_...`.

[endsect]

[section Move Operations]

As with all public operations of a class, also move operations should maintain class invariants (see also __Stroustrup13__, p. 520).
Specifically, C++ requires the following:

* The moved-from object can be copy assigned.
* The moved-from object can be move assigned.
* The moved-from object can be destroyed.
[footnote
If not anything else, this requires that class invariants are maintained by move operations because the destructor of the moved-from object requires that class invariants are true at its entry (as always with destructors, see also __Destructor_Calls__).
]

Thus both the move constructor and the move assignment operator need to maintain the class invariants of the moved-from object and their contracts can be programmed using [funcref boost::contract::constructor] and [funcref boost::contract::public_function] as always for constructors and public member functions, for example (see also [@../../example/features/move.cpp =move.cpp=]):

[import ../example/features/move.cpp]
[move]

This example requires that it is possible to call the public member function `move()` on the moved-from object.
This allows to make explicit the precondition that except for destructor, copy and move assignments all other public member functions cannot be called on a moved-from object.
This assumption is usually implicit in C++ (i.e., documented by the standard but not checked by the language at run-time).
If it is is not possible (e.g., due to some optimized implementation of the move operations) to have such a public `move()` member function, the private `moved_` member (or similar) can be used to program class invariants and preconditions (and that will just relay on the usual implicit C++ assumption on moved-from object because users will not be able to fully check preconditions and class invariants before calling functions of a moved-from object).

[endsect]

[section Unions]

In C++, a `union` cannot have virtual member functions, bases classes, and cannot be used as a base class thus subcontracting ([classref boost::contract::virtual_], [macroref BOOST_CONTRACT_OVERRIDE], etc.) do not apply to unions.
Also a `union` cannot inherit from [classref boost::contract::constructor_precondition] (because it cannot have base classes) so such a class is used to declare a local object that checks constructor preconditions (see `pre` in the example below).
A part from that, this library is used as usual to program contracts for unions, for example (see also [@../../example/features/union.cpp =union.cpp=]):

[import ../example/features/union.cpp]
[union]

[endsect]

[section Volatile Class Invariants]

This library allows to specify a different set of class invariants to be checked for public volatile member functions.
These /volatile class invariants/ are programmed in a public member function `const volatile` qualified and named `invariant` (see [macroref BOOST_CONTRACT_INVARIANT] to name the invariant function differently from `invariant` and __Access__ to not have to declare it public).

In general, `const volatile` qualified invariants work the same as `const` qualified invariant (see __Class_Invariants__) with the only difference that `volatile` and `const volatile` member functions check `const volatile` invariants while mutable (i.e., neither `const` nor `volatile` qualified) and `const` member functions check `const` invariants.
A given class can specify both `const volatile` and `const` qualified invariant member functions:
[footnote
*Rationale.*
Constructors and destructors check `const volatile` and `const` invariants in that order because the qualifier that limits the calls the least is checked first (note that a `const volatile` calls can be made on any object while `const` calls cannot be made on `volatile` non-`const` objects, in that sense the `const volatile` qualifier limits calls on an object less than `const` alone does).
This is consistent with `static` class invariants that are checked even before `const volatile` invariants (the `static` classifier limits calls even less than `const volatile` in the sense that an object is not even needed to make static calls).
While there is a more important reason to check `static` invariants before all other invariants (see __Contract_Programming_Overview__), the above is the only reason why this library checks `const volatile` invariants before `const` invariants for constructors and destructors.
]

* Constructors check both `const volatile` and `const` qualified invariants in that order (at exit if no exception is thrown).
* Destructors check both `const volatile` and `const` qualified invariants (at entry).
* Both mutable and `const` public member functions check `const` qualified invariants (at entry and at exit if no exception is thrown).
* Both `volatile` and `const volatile` public member functions check `const volatile` qualified invariants (at entry and at exit if no exception is thrown).

This ensures that volatile class invariants are correctly checked (see also __Constructor_Calls__, __Destructor_Calls__, and __Public_Function_Calls__).
For example (see also [@../../example/features/volatile.cpp =volatile.cpp=]):

[import ../example/features/volatile.cpp]
[volatile]

While this library does not automatically check `const volatile` invariants for non-volatile functions, programmers can explicitly call the `const volatile` invariant function from the `const` invariant function if that makes sense for the contracts being specified (that way all public member functions `volatile` and not will check `const volatile` invariants):
[footnote
*Rationale.*
Note that while all public member functions can be made to check `const volatile` invariants, it is never possible to make volatile public member functions check `const` non-volatile invariants.
That is because both `const` and `volatile` can always be added but never stripped in C++ (a part from forcefully via `const_cast`) but `const` is always automatically added by this library in order to enforce contract constant-correctness (see __Constant_Correctness__).
That said, it would be incorrect for this library to also automatically add `volatile` and require all functions to check `const volatile` (not just `const`) invariants because only `volatile` members can be accessed from `const volatile` invariants so there could be many `const` (but not `const volatile`) members that are accessible from `const` invariants but not from `const volatile` invariants.
To avoid this confusion, this library has chosen to draw a clear dichotomy between `const` and `const volatile` invariants so that only volatile members check `const volatile` invariants and only non-volatile members check `const` (but not `const volatile`) invariants.
This is simple and should serve most cases.
If programmers need non-volatile members to check `const volatile` invariants, they can explicitly do so by calling the `const volatile` invariant function from the `const` invariant function as shown in this documentation.
]

    class ``[^['class-type]]`` {
    public:
        void invariant() const {
            ``[^['class-type]]`` const volatile& cv = *this;
            cv.invariant(); // Call `void invariant() const volatile` below.
            ...
        }

        void invariant() const volatile {
            ...
        }

        ...
    };

As usual, static class invariants can also be specified (see __Static_Class_Invariants__) and private and protected member functions do not check any invariant (see __Private_and_Protected_Functions__).

[endsect]

[section Old Value Requirements]

Old values require copying the expression passed to [macroref BOOST_CONTRACT_OLDOF] so the type of that expression must be copy constructible.
More precisely, dereferencing an old value pointer of type [classref boost::contract::old_ptr]`<T>` requires `boost::is_copy_constructible<T>::value` to be `true` (otherwise this library will generate a compile-time error).

* In some cases it might be acceptable, or even desirable, to cause a compile-time error when a program uses old value types that are not copy constructible (because it is not possible to fully check the correctness of the program as stated by the contract assertions that use these old values).
In these cases, programmers can declare old values using [classref boost::contract::old_ptr] as seen so far (or equivalently using C++11 `auto` declarations `auto ... = BOOST_CONTRACT_OLDOF(...)`).
[footnote
*Rationale*.
When C++11 `auto` declarations are used, this library defaults the type of [macroref BOOST_CONTRACT_OLDOF] to [classref boost::contract::old_ptr] because it generates a compile-time error for non-copyable types so it is in general more conservative than [classref boost::contract::noncopyable_old_ptr].
]
* However, in other cases it might be desirable to simply not check assertions that use some old values when the related old value types are not copy constructible.
Programmers can do this by using [classref boost::contract::noncopyable_old_ptr] instead of [classref boost::contract::old_ptr] to program these old values (and by checking if the old value pointer is not null before dereferencing it in postconditions).

For example, consider the following `accumulate` function template that could in general be instantiated for types `T` that are not copy constructible (i.e., `boost::is_copy_constructible<T>::value` is `false`):

[import ../example/features/noncopyable_old.cpp]
[noncopyable_old]

The old value pointer `old_total` is programmed using [classref boost::contract::noncopyable_old_ptr] so if `T` is not copy constructible then `total` will simply not be copied and `old_total` will be left as a null pointer (in these cases `old_total` must be checked to be not null `if(old_total) ...` before it can be dereferenced in the postconditions).
If the above example used [classref boost::contract::old_ptr] instead then the library would have generated a compile-time error if `accumulate` is instantiated for types `T` that are not copy constructible (but only if `old_total` is actually dereferenced in the contract assertions somewhere `*old_total ...`).

Note that the `noncopyable_...` prefix of the name [classref boost::contract::noncopyable_old_ptr]`<T>` refers to the pointed type `T` that may or not be copy constructible without causing a compile-time error in this case (the old value pointer itself is always copyable, or at least copy assignable).

[heading No C++11]

In general, the `boost::is_copy_constructible` type trait requires C++11 for full support.
On non-C++11 compilers, it is possible to inherit the old value type from `boost::noncopyable`, or use `BOOST_MOVABLE_BUT_NOT_COPYABLE`, or explicitly specialize the `boost::is_copy_constructible` template (see [@http://www.boost.org/doc/libs/release/libs/type_traits/doc/html/boost_typetraits/reference/is_copy_constructible.html boost::is_copy_constrictible] for more information):

    #include <boost/type_traits/is_copy_constructible.hpp>

    namespace boost {
        template<>
        struct is_copy_constructible<``[^['old-value-type]]``> : false_type {};
    }

[endsect]

[section Assertion Requirements (Static-If)]

In general, assertions can introduce a new set of requirements on the types used by the program.
Some of these type requirements might be necessary only to check the assertions and they would not be required by the program otherwise.

* In some cases it might be acceptable, or even desirable, to cause a compile-time error when a program uses types that do not provide all the operations needed to check contract assertions (because it is not possible to fully check the correctness of the program as stated by the contracts).
In these cases, programmers can specify contract assertions as we have seen so far, compilation will fail if user types do not provide all operations necessary to check the contracts.
* However, in other cases it might be desirable that adding contracts to a program does not alter its type requirements and that assertions are simply not checked when user types do not provide all the operations necessary to check them.
Programmers can do this by using [funcref boost::contract::check_if] (and [funcref boost::contract::check_if_c]) within the contract assertions.

For example, let's consider the following `vector<T>` class template.
This class template does not usually require that `T` has an equality operator `==` (it only requires `T` to be copy constructible, see `std::vector` documentation).
However, the contracts of the `vector<T>::push_back(value)` member function include a postcondition `back() == value` which introduces the new requirement that `T` must also have an equality operator `==`.
Programmers can specify this postcondition as usual `BOOST_CONTRACT_ASSERT(back() == value)` an let the program fail to compile when users instantiate this template with a type `T` that does not provide an equality operator `==`.
Otherwise, programmers can specify this postcondition using [funcref boost::contract::check_if] to check the assertion only for types `T` that have an equality operator `==` and trivially check `true` otherwise, for example (see also [@../../example/features/check_if.cpp =check_if.cpp=]):

[import ../example/features/check_if.cpp]
[check_if]

The [funcref boost::contract::check_if] function template is a special case of the more general facility [funcref boost::contract::call_if]:
Specifically, `boost::contract::check_if<`[^['condition]]`>(`[^['check]]`)` is equivalent to:

    boost::contract::call_if<``[^['condition]]``>(
        ``[^['check]]``
    ).else_(
        [] { return true; }
    )

Where [^['condition]] is a nullary boolean meta-function and [^['check]] is a nullary boolean functor.
If [^['condition]]`::value` is statically evaluated to be `true` at compile-time then [^['check]]`()` is called at run-time and its boolean result is returned by the enclosing `call_if`.
Otherwise, if [^['condition]]`::value` is statically evaluated to be `false` at compile-time then `[] { return true; }()` is called at run-time and `true` is trivially returned by the enclosing `call_if`.
Note that [^['check]] must be a functor template (and not just a functor) so its code that contains the assertion operations with the extra type requirements (e.g., the operator `==`) will not be instantiated and compiled for specific types unless the compiler determines it will be actually called at run-time (C++14 generic lambdas and functor templates like `std::equal_to` can be used to program [^['check]], but C++11 lambdas cannot).
    
More in general, [funcref boost::contract::call_if] accepts a number of optional else-if and one optional else statement:

    boost::contract::call_if<``[^['condition1]]``>(
        ``[^['then1]]``
    ).template else_if<``[^['condition2]]``>(       // Optional.
        ``[^['then2]]``
    )
    ...                                   // Optionally, other `else_if`.
    .else_(                               // Optional for `void` functors, otherwise required.
        ``[^['else]]``
    )

Where [^['condition1]], [^['condition2]], ... are nullary boolean meta-functions and [^['then1]], [^['then2]], ..., [^['else]] are nullary functors.
The return types of the functor calls [^['then1]]`()`, [^['then2]]`()`, ..., [^['esle]]`()` must either all be the same (possibly all `void`) or be of types implicitly convertible into one another.
At run-time [funcref boost::contract::call_if] will call the functor [^['then1]]`()`, or [^['then2]]`()`, ..., or [^['else]]`()` depending on which meta-function [^['condition1]]`::value`, [^['condition2]]`::value`, ... is evaluated to be `true` or `false` at compile-time, at it will return the value returned by the functor being called 
If [^['then1]], [^['then2]], ..., [^['else]] are nullary functor templates (not just nullary functors) then their code will only be compiled if the compiler determines they need to be actually called at run-time (so only if the related [^['condition1]]`::value`, [^['condition2]]`::value`, ... are evaluated to be `true` or `false` at compile-time).
All the `esle_if<...>(...)` statements are optional, the `else_(...)` statement is optional if the functor calls return `void` but it is required otherwise.

In general, [funcref boost::contract::call_if] can be used to program contract assertions that compile and check different functor templates depending on related conditions being evaluated to be `true` at compile-time (but in most cases [funcref boost::contract::check_if] should be sufficient, simpler and less verbose to use).

The [funcref boost::contract::check_if_c], [funcref boost::contract::call_if_c], and `.else_if_c` function templates work similarly to their counterparts without the `..._c` postfix above, but they take their condition template parameters as static boolean values instead of nullary boolean meta-functions.

[heading Static-If (C++14)]

The [funcref boost::contract::call_if] function template is a general facility and its use is not limited to programming contracts.
In fact, [funcref boost::contract::call_if] can be used together with C++14 generic lambdas to program statements similar to the `static if` proposal (at least at function scope, see also [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3613.pdf N3613]).
For example, consider the following implementation of `std::advance` that uses `static if`-like statements programmed via [funcref boost::contract::call_if] (see also [@../../test/call_if/advance_cxx14.cpp =advance_cxx14.cpp=]):

[import ../test/call_if/advance_cxx14.cpp]
[advance_cxx14]

This implementation is much more concise, easy to read and maintain than the usual implementation of `std::advance` that uses tag dispatching.
[footnote
`boost::hana::if_` can also be used to emulate function scope `static if` with C++14 generic lambdas.
]

[endsect]

[section Access]

As seen so far, programmers are required to decorate their classes declaring extra members that are internally used by this library to check contracts:

* The `invariant` and `static_invariant` member functions (used to check class invariants, see also __Class_Invariants__).
* The `base_types` member type declared via [macroref BOOST_CONTRACT_BASE_TYPES] (used to implement subcontracting, see also __Public_Function_Overrides__).
* The `override_...` member types declared via [macroref BOOST_CONTRACT_OVERRIDE], [macroref BOOST_CONTRACT_NAMED_OVERRIDE], and [macroref BOOST_CONTRACT_OVERRIDES] (used to implement subcontracting for overriding functions, see also __Public_Function_Overrides__).
[footnote
*Rationale.*
The internals of the `override_...` type generated by [macroref BOOST_CONTRACT_OVERRIDE] use names reserved by this library to users should not actually use such a type even when it is defined `public`.
(On a related note, in theory using C++14 generic lambdas, the [macroref BOOST_CONTRACT_OVERRIDE] macro could be re-implemented in a way so it can be expanded at function scoped, instead of class scoped.)
]

In general, these members must be declared `public` in the user class in order for this library to access them.
[footnote
There is some variability among compiler implementations:
the `base_types` member type needs to be declared `public` on all MSVC, GCC, ang CLang;
the `invariant` and `static_invariant` member functions need to be declared `public` on MSVC, but not on GCC and CLang;
the `override_...` member types do not have to be declared `public` on any compiler.
In any case, declaring the [classref boost::contract::access] class `friend` allows to always declare all these extra members `private` on all compilers.
]
However, programmers might need to more precisely control the public members of their classes to prevent incorrect access of encapsulated members.
All these members can be declared `private` as long as the [classref boost::contract::access] class is declared as `friend`, for example (see also [@../../example/features/access.cpp =access.cpp=]):

[import ../example/features/access.cpp]
[access]

This technique is not used in most examples of this documentation only for brevity, but programmers are encouraged to use it in real code.

[endsect]

[section Separate Body Implementation]

Contracts are part of the program specification and not of its implementation (see also __Specification_and_Implementation__).
However, this library uses function definitions to program the contracts so contract code appears together with the function implementation code.
This is not ideal, but contract code programmed with this library must always appear at the very top of the function definition so programmers will easily be able to distinguish it from the rest of function implementation code (so this might not be real problem in practise).

In some cases, it might be desirable to completely separate the contract code (function specification) from the function body code (function implementation).
For example, this could be necessary for software that ships only header files and pre-compiled source code to its users (notably, that cannot be done for template code in C++).
If the contracts are programmed in the function definitions that are pre-compiled with the source code, users will not be able to inspect the contract code to understand semantics and usage of the functions (again, this might not be a real problem in practice for example if contract code is already somehow extracted from the source code and presented as part of the documentation of the shipped software).

In such cases, the function implementation can be programmed in an extra /body function/ (e.g., named `..._body`) that is defined in the source code.
The original function definition remains in the header files instead, it programs the contract and simply calls the extra body function.
At the cost of programmers writing an extra function declaration for the body function, this technique allows to keep the contract code in header files while separating the body implementation code to source files (with the limitation that constructor member initialization lists must still be programmed in the header files because that is where the constructors are actually defined).

For example, the following header file only contains function declarations and contract code (function specifications) and constructor member initializations (see also [@../../example/features/separate_body.hpp =separate_body.hpp=]):

[import ../example/features/separate_body.hpp]
[separate_body_hpp]

Instead, the function bodies (function implementations) is programmed in a separate source file (see also [@../../example/features/separate_body.cpp =separate_body.cpp=]):

[import ../example/features/separate_body.cpp]
[separate_body_cpp]

The same technique can be used for non-member, private, and protected functions.

[endsect]

[section Throw on Failure]

If a condition checked using [macroref BOOST_CONTRACT_ASSERT] is `false` or if code specified in preconditions, postconditions, and class invariants throws an exception, this library calls the /contract failure handler/ functions [funcref boost::contract::precondition_failure], [funcref boost::contract::postcondition_failure], [funcref boost::contract::entry_invariant_failure], or [funcref boost::contract::exit_invariant_failure] respectively (in fact, [macroref BOOST_CONTRACT_ASSERT] simply expands to code that throws a [classref boost::contract::assertion_failure] exception, see also __No_Macros__).

By default, the contract failure handler functions print a message to the standard error `std::cerr` and then terminate the program calling `std::terminate`.
[footnote
*Rationale.*
In general, when a contract fails the only safe thing to do is to terminate the program execution (because the contract failure indicates a bug in the program, and in general the program is in a state for which no operation can be successfully performed, so the program should be stopped).
Therefore, this library terminates the program by default.
However, for specific applications, programmers could implement some fail-safe mechanism for which some mission-critical operation can always be performed upon handling failures so this library allows programmers to override the default contract failure handlers to fully customize how to handle contract failures.
]
However, programmers can override the default contract failure handlers to perform any custom action on contract failure using [funcref boost::contract::set_precondition_failure], [funcref boost::contract::set_postcondition_failure], [funcref boost::contract::set_entry_invariant_failure], [funcref boost::contract::set_exit_invariant_failure], [funcref boost::contract::set_invariant_failure] (to set both entry and exit invariant failure handlers at once for convenience), or [funcref boost::contract::set_failure] (to set all failure handlers at once for convenience).
For example (see also [@../../example/features/throw_on_failure.cpp =throw_on_failure.cpp=]):

[import ../example/features/throw_on_failure.cpp]
[throw_on_failure_handler]

Note that in order to comply with C++ and STL exception safety rules, destructors should never throw.
This library passes a [classref boost::contract::from] parameter to the contract failure handler functions that indicates if the contract failure occurred in a destructor, constructor, or function call.
This way programmers can ensure to never throw from a destructor call (in the example above, contract failures from destructors are simply ignored even if that is probably never a safe thing to do in real code).
[footnote
It is the responsibility of the programmers to decide how to handle contract failures from destructors when they reprogram the contract failure handlers to throw exceptions instead of terminating the program (given that C++ and STL exception safety rules requires destructors to never throw).
This is not a simple dilemma and it might be one more reason to terminate the program instead of throwing exceptions when contract assertions fail (as this library does by default).
]

The contract assertions can be programmed to throw [classref boost::contract::assertion_failure] using [macroref BOOST_CONTRACT_ASSERT] (see also __No_Macros__) or to throw any other exception using code similar to:

    if(``[^['error-condition]]``) throw ``[^['exception-object]]``;

For example (see also [@../../example/features/throw_on_failure.cpp =throw_on_failure.cpp=]):

[throw_on_failure_cstring]

[endsect]

[section Disable Contract Checking]

Checking contracts adds run-time overhead and can slow down program execution (see also __Benefits_and_Costs__).
Therefore, programmers can define the following macros (`-D` option in Clang and GCC, `/D` option in MSVC, etc.) to instruct this library to not check specific set of contracts at run-time: [macroref BOOST_CONTRACT_NO_PRECONDITIONS] (do not check preconditions), [macroref BOOST_CONTRACT_NO_POSTCONDITIONS] (do not check postconditions), [macroref BOOST_CONTRACT_NO_ENTRY_INVARIANTS] (do not check invariants at call entry), [macroref BOOST_CONTRACT_NO_EXIT_INVARIANTS] (do not check invariants at call exit), and [macroref BOOST_CONTRACT_NO_INVARIANTS] (do not check invariants at both call entry and exit).
By default, none of these macros are defined so this library checks all contracts.

For example, programmers could decide to check all contracts during early development builds, but later check only preconditions and maybe entry invariants for release builds by defining [macroref BOOST_CONTRACT_NO_POSTCONDITIONS] and [macroref BOOST_CONTRACT_NO_EXIT_INVARIANTS].

[endsect]

[section Disable Contract Compilation]

This library provides macros that can be used to disable compile-time overhead introduced by contracts but at the cost of manually programming `#ifdef` statements around contract code.
The authors of this library do not recommend to use this practice unless strictly necessary because it makes the contract code more verbose, less readable, and in most applications the compile-time overhead of contracts should not represent an issue (it should be sufficient to disable contract checking at run-time as indicated before).

In any case, the following example illustrates how to completely disable contract code compilation for non-member functions (see also [@../../example/features/ifdef.cpp =ifdef.cpp=]):

[import ../example/features/ifdef.cpp]
[ifdef_function]

The same is done to disable contract code complication for private and protected functions.
For constructors, destructors, and public functions instead (see also [@../../example/features/ifdef.cpp =ifdef.cpp=]):

[ifdef_class]

As shown by the examples above:

* The [macroref BOOST_CONTRACT_NO_PRECONDITIONS] macro is defined by programmers and it can be used in `#ifdef` statements to disable compilation of preconditions, including constructor preconditions ([classref boost::contract::constructor_precondition]).
* The [macroref BOOST_CONTRACT_NO_POSTCONDITIONS] macro is defined by programmers and it can be used in `#ifdef` statements to disable compilation of postconditions, old value declarations, and old value assignments at body (`.old(...)`).
* The [macroref BOOST_CONTRACT_NO_INVARIANTS] macro is defined by programmers (or it will be automatically defined by this library if both [macroref BOOST_CONTRACT_NO_ENTRY_INVARIANTS] and [macroref BOOST_CONTRACT_NO_EXIT_INVARIANTS] are defined) and it can be used in `#ifdef` statements to disable compilation of class invariants (including static and volatile class invariants).
Also the [macroref BOOST_CONTRACT_NO_ENTRY_INVARIANTS] and [macroref BOOST_CONTRACT_NO_EXIT_INVARIANTS] macros are defined by programmers (or they will be both automatically defined by this library if [macroref BOOST_CONTRACT_NO_INVARIANTS] is defined) but these macros are not directly used to disable contract code compilation (only contract code run-time checking).
* The [macroref BOOST_CONTRACT_NO_CONSTRUCTORS] macro is automatically defined by this library (a compile-time error will be reported if programmes try to manually define this macro) and it can be used in `#ifdef` statements to disable compilation of constructor contract guards.
* The [macroref BOOST_CONTRACT_NO_DESTRUCTORS] macro is automatically defined by this library (a compile-time error will be reported if programmers try to manually define this macro) and it can be used in `#ifdef` statements to disable compilation of destructor contract guards.
* The [macroref BOOST_CONTRACT_NO_PUBLIC_FUNCTIONS] macro is automatically defined by this library (a compile-time error will be reported if programmers try to manually define this macro) and it can be used in `#ifdef` statements to disable compilation of public member function contract guards, base type `typedef`, extra [classref boost::contract::virtual_] function parameters, and [macroref BOOST_CONTRACT_OVERRIDE] declarations.
* The [macroref BOOST_CONTRACT_NO_FUNCTIONS] macro is automatically defined by this library (a compile-time error will be reported if programmers try to manually define this macro) and it can be used in `#ifdef` statements to disable compilation of contract guards for non-member functions as well as private and protected functions.
* The [macroref BOOST_CONTRACT_NO_ALL] macro is automatically defined by this library (a compile-time error will be reported if programmers try to manually define this macro) and it can be used in `#ifdef` statements to disable [classref boost::contract::access] friendship declarations and also inclusions of [headerref contract.hpp] (some of the other macros listed here can be used to selectively disable inclusion of =boost/contract/*.hpp= headers when they are used instead of [headerref contract.hpp].)

[endsect]

[section No Macros (No C++11)]

It is possible to specify contracts without using this library macros and programming the related code manually instead (a part from [macroref BOOST_CONTRACT_OVERRIDE], [macroref BOOST_CONTRACT_OVERRIDES], and [macroref BOOST_CONTRACT_NAMED_OVERRIDE] that cannot be programmed manually).

Some of this library macros are variadic macros, others are not (see below).
Variadic macros were officially added to the language since C++11 but most compilers have been supporting variadic macros as an extension for a long time, plus essentially all compilers that support C++11 lambda functions also support C++11 variadic macros (and this library might rarely be used without the convenience of C++11 lambda functions, see also __No_Lambda_Functions__).
Therefore, the following can be considered mainly a curiosity because programmers should seldom need to use this library without using its macros.

[heading Overrides]

As shown in __Public_Function_Overrides__ and __Named_Overrides__, this library provides the [macroref BOOST_CONTRACT_OVERRIDE] and [macroref BOOST_CONTRACT_NAMED_OVERRIDE] macros to program contracts for overriding public functions.
These macros cannot be programmed manually but they are not variadic macros so programmers should be able to use them on all C++ compilers.
[footnote
*Rationale.*
These macros expand SFINAE-based introspection templates that cannot be reasonably programmed by users (that remains the case even if C++14 generic lambdas were to be used here).
]
The [macroref BOOST_CONTRACT_OVERRIDES] macro is a variadic macro instead but programmes can manually repeat the non-variadic macro [macroref BOOST_CONTRACT_OVERRIDE] for each overriding public function name on compilers that do not support variadic macros.

[heading Assertions (Not Variadic)]

As shown in __Preconditions__, __Postconditions__, __Class_Invariants__, etc. this library provides the [macroref BOOST_CONTRACT_ASSERT] macro to assert contract conditions.
This is not a variadic macro and programmers should be able to use it on all C++ compilers.
However, the macro invocation `BOOST_CONTRACT_ASSERT(`[^['condition]]`)` simply expands to code equivalent to the following:

    if(!``[^['condition]]``) {
        throw boost::contract::assertion_failure(__FILE__, __LINE__,
                BOOST_PP_STRINGIZE(``[^['condition]]``));
    }

That is because this library considers any exception thrown from within preconditions, postconditions, and class invariants as a contract failure and reports it calling the related contract failure handler ([funcref boost::contract::precondition_failure], etc., see also __Throw_on_Failure__).
In fact, if there is a need for it, programmers can always program contract assertions that throw an exception as follow (see [@../../example/features/throw_on_failure.cpp =throw_on_failure.cpp=] for an example):

    if(!``[^['condition]]``) throw ``[^['exception-type]]``(...);

However, using [macroref BOOST_CONTRACT_ASSERT] always allows this library to show detailed information about the assertion code, its file and line number, etc.

[heading Base Types (Variadic)]

As shown in __Base_Classes__, this library provides the [macroref BOOST_CONTRACT_BASE_TYPES] variadic macro to declare the `base_types` member type that lists all public bases of a derived class.
Programmers can also declare `base_types` without using [macroref BOOST_CONTRACT_BASE_TYPES] at the cost of writing a bit more code manually, for example (see also [@../../example/features/base_types_no_macros.cpp =base_types_no_macros.cpp=]):

[import ../example/features/base_types_no_macros.cpp]
[base_types_no_macros]

The `base_types` member type must be a `boost::mpl::vector` and it must list /only/ `public` base classes (because only public bases subcontract, see also __Function_Calls__).
If the [macroref BOOST_CONTRACT_BASE_TYPES] macro is not used, it is the responsibility of the programmers to maintain the correct list of bases in the `boost::mpl::vector` each time the derived class inheritance list changes (this might complicate maintenance).
In general, it is recommended to use the [macroref BOOST_CONTRACT_BASE_TYPES] macro if possible.

[heading Old Values (Variadic)]

As shown in __Old_Values__, this library provides the [macroref BOOST_CONTRACT_OLDOF] variadic macro to assign old value copies.
Programmers can also assign old values without using [macroref BOOST_CONTRACT_OLDOF] at the cost of writing a bit more code manually, for example (see also [@../../example/features/old_no_macros.cpp =old_no_macros.cpp=]):

[import ../example/features/old_no_macros.cpp]
[old_no_macros]

The ternary operator `boost::contract::copy_old(v) ? size() : boost::contract::null_old()` must be used here to avoid evaluating and copying the old value expression `size()` when [funcref boost::contract::copy_old] returns `false` because old values are not being copied (postcondition checking is disable at run-time, an overridden virtual function call is not checking postconditions yet, etc.).
The enclosing [funcref boost::contract::make_old] copies the old value expression and creates an old value pointer, while [funcref boost::contract::null_old] indicates when a null old value pointer should be created.

The [funcref boost::contract::make_old] and [funcref boost::contract::copy_old] functions are used exactly as above but without the extra `v` parameter when they are called from within non-virtual functions (see also __Public_Function_Overrides__).
The old value pointer returned by [funcref boost::contract::make_old] can be assigned to either [classref boost::contract::old_ptr] or [classref boost::contract::noncoyable_old_ptr] (see also __Old_Value_Requirements__).

In general, it is recommended to use the [macroref BOOST_CONTRACT_OLDOF] macro if possible.

[endsect]

[section No Lambda Functions (No C++11)]

This section shows how to use this library without C++11 lambda functions.
This has some advantages:

* It allows to use this library on compilers that do not support C++11 lambda functions (essentially most C++03 compilers can be used, see __No_Macros__ to also avoid using variadic macros).
* Contract functions (see the `..._precondition`, `..._old`, and `..._postcondition` functions in the example below) can be programmed to fully enforce constant-correctness and other contract requirements at compile-time (see also __Constant_Correctness__).
[footnote
If C++ allowed lambda functions to capture variables by constant reference (e.g., `[const&] (...) { ... }` or `[const& `[^['variable-name]]`] (...) { ... }`) also lambdas could be used to program contract functors that fully enforce __Constant_Correctness__ at compile-time.
Note that C++11 lambda allows to capture variables by value (`[=] (...) { ... }` and `[`[^['variable-name]]`] (...) { ... }`), these value captures are `const` (unless the lambda is explicitly declared `mutable`) but they are not suitable to program postconditions using this library (see __Postconditions__), plus they introduce an extra copy that might be too expensive in general.
]
* Contracts are separated from function body implementations (see also __Specification_and_Implementation__ and __Separate_Body_Implementation__).

However, not using C++11 lambda functions comes to the significant cost of having to manually write a great deal of extra code to program the contract functions, for example (see also [@../../example/features/no_lambdas.hpp =no_lambdas.hpp=] and [@../../example/features/no_lambdas.cpp =no_lambdas.cpp=]):

[import ../example/features/no_lambdas.hpp]
[no_lambdas_hpp]

[import ../example/features/no_lambdas.cpp]
[no_lambdas_cpp]

If programmers also want to fully enforce all contract programming constant-correctness requirements at compile-time, they should follow these rules when programming the contract functions (see also __Constant_Correctness__):

* Precondition functions (i.e., the `..._precondition` functions in the example above) can take their arguments either by `const` value or by `const&`, and they should be either `static` or `const` member functions.
* Postcondition functions (i.e., the `..._postcondition` functions in the example above) should take their arguments by `const&`, and they should be either `static` or `const` member functions.
* Old value functions (i.e., the `..._old` functions in the example above) should take their arguments by `const&` a part from old value pointers that should be taken by `&` (so only old value pointers can be modified), and they should be either `static` or `const` member functions.
* Constructor precondition and old value functions should be `static` (because constructor preconditions and old values cannot access the object `this`, see also __Constructor_Calls__).
* Destructor postcondition functions should be `static` (because destructor postconditions cannot access the object `this`, see also __Destructor_Calls__).

Note that the extra contract functions also allow to program only the contract code in the header file (see also __Specification_and_Implementation__).
All function body implementation code was instead programmed in the source file (including the constructor member initialization list, that could not be done with the technique shown in __Separate_Body_Implementation__).
[footnote
In this example, `bind` was used to generate nullary functors from the contract functions.
As always with `bind`, `cref` and `ref` must be used to bind arguments by `const&` and `&` respectively, plus it might be necessary to explicitly `static_cast` the function pointer passed to `bind` in case the bound function name is overloaded.
]
Also note that the contract functions can always be declared `private` if programmers need to exactly control the public members of the class (this was not done in this example only for brevity, see also __Access__).

Alternatively, on compilers that do not support C++11 lambda functions but that support type-of (either native as an extension or via emulation, these should be most recent C++03 compilers), [@http://www.boost.org/doc/libs/release/libs/local_function/doc/html/index.html Boost.LocalFunction] can be used to program the contract functions, for example (see also [@../../example/features/no_lambdas_local_func.cpp =no_lambda_local_func.cpp=]):

[import ../example/features/no_lambdas_local_func.cpp]
[no_lambdas_local_func]

This code is somewhat less verbose than the previous example (about 30% less lines of code) but the contract code is hard to ready.

Other libraries could also be used to program the contract functions without C++11 lambda functions (Boost.Lambda, Boost.Fusion, etc.) but like the techniques shown above, they will all result in contract code more verbose, or harder to read and maintain than the contract code programmed using C++11 lambda functions.
Therefore, authors think this library is most useful when used together with C++11 lambda functions.

[endsect]

[endsect]

