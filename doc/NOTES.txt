
/** @note boost::mpl::is_copyable<> could not be used to replace
dbc::copyable<> because Boost's is_copyable<> only works for built-in types.
For user defined types, Boost's is_copyable always returns false unless special
compiler support is provided (and GCC does not provide support for this,
probably only VC++ supports this at the moment...). */

/** @note Inheriting from a dbc::object<> base class allows to provide
assertion checking state, mutex, etc. However, the invariant cannot be made
pure virtual function of dbc::object<> otherwise the invariant call will always
be ambiguis when subcontracting -- I did try this!
Note, since dbc::object<> is a template, they are all different from eavery
class type so the inheritance tree is modified by no common anchestor is
intorduced and dbc::object<> should be private base anyway -- so this 
modification of inheritance tree is OK as is does not change public APIs.
However, contract cannot access class-type directly from dbc::object because
in order to call dbc::object<C>::class_type, the contract will still need to
specify C -- so class-type must still be specified for each contract mem fun. */

/** @note Wanted to provide def constr for all contract class fun, fun::mem, etc
so they are easier to use. In particular if a mem var of a contract class type
is declared, C++ will init automatically using it's default constr. This feature
is currently not used in the library (as contracts are init manually in the
fun declaration that then call operator()) but it might turn out to be handy in
future. */

/** @note If only DBC_CHECK_INVARIANT and DBC_CHECK_REQUIRE are #define, DbC++
can be used to impl invariant checking framework similar to the only proposed
in Str97 (see example/CPP_Prog_Lang/String). In Str97, precondition checking is
not directly discussed (it is actually discouraged in a later section) but
String::operator[] has a check on the range of its index argument that is very
naturally handled with a precondition -- so DbC++ example have implemented that
index range check as a precondition. */

/** @note declaring require(), ensure(), and dbc_invariant_() pure virtual 
forces the user to define them correctly at compile time. Having them with
params allow user to only use correct param (no old or result in require())
and to name args as original function args. */

/** @note Chosen abbreviation "mem" for member and "fun" for function to follow
C++ STL conventions of std::mem_fun. Chosen "constr" and "destr"
abbreviations trying to follow similar abbreviation philosofy of STL. */

/** @note DBC_CONFIG_ macros follow name convention and semantics of 
BOOST_PP_CONFIG_ macros. */

/** @note Contracts are functor as they provide call operator() that checks
contract and inokes body (this seemed a natural choise since this is indeed
the function call). */

/** @note DBC_CONFIG_ENABLE_XYZ_ASSERTIONS do not remove assertions from obj
code. They only run on/off run-time checking of relative assertions (but the
assertions are always compiled). Use DBC_CHECK_XYZ to remove pre/post/inv
assertions (at this regardless of if they throw/exit/terminate) from obj
code. */

/** @note DBC_NO and DBC_ALL override #definitions of single DBC_CEHCKING (if
any). */

/** @note DbC++ also impl a simple version of Eiffel loop invariant checking
(see example/OO_SW_Contruction/Gcd). This hasn't been tested much... */

/** @note Different stylistic naming convetions have been used: C/C++ STL for
DBC library and test, Str97 for Str97 examples, Java-like CaMeL for DBC books
examples. This was to see how DBC will look when in code with different
styles (common C++ situation). */

/** @note DBC_CONFIG_MAX_ARGC is set to 5 by default. It can be increased 
(probably up to BOOST_PP_MAX_MAG around 255) but it will significantly increase
compilation time. Use only a reasonable number based on the number of fun args
you have (for which you need a contract). */

/** @note See examples: Stack4 for general good DBC and library usage; NameList
for inheritance; Observer for more complex inheritance and library usage (where
some classes have contracts and others don't -- but I prefer to have contracts
for all classes and all of their mem-fun/constr/destr). */

/** @note If when subcontracting DBC_BASE is omitted then base contract is
ignored. This might be inline with C++ "freedom" given to the programmer, but
in general you must NOT do that... as you will be braking your parent's contract
by not inheriting it. */

/** @note Do not enter arg default value in contract (only arg-type and 
arg-name). */

/** @note require/ensure declared pure virtual (instead of {}) so compiler error
if you miss type them (e.g., incorrect const or post<> for one of the args).
This requires a bit more work from the programmer even for contracts with no
pre/post conditions but allow to catch errors in the contract at
compile-time. */

/** @note In quite a few places in the impl (macro, fun, etc) we need to
add and them remove copyable etc because if types do not have excaly the same
signature the compiler will not match them to be the same for templates (as for
templates compiler need to wait and eval the type expression lazily...). */

/** @note Argument types are indexed from 0 to n-1 like in Boost.FunctionType
they are returned as Boost.MPL sequence that goes from 0 to n-1. Using symbols
indexed from 1 to n (A1...An, arg1_type...argn_type, etc) would have increased
(but not much) preprocessing time because Boost.Preprocessor enum and 
repetition go from 0 to n-1 by default. */

/** @note Destructor do not subcontract (i.e., their contract do not accept
DBC_BASE() and fun<>::destr<> does not accept base contract type B param). This
is beacuse C++ will automatically invoke base class destructors (with its
contract that cheks inv if base class destructor has a contract). See the 
Courier example: When DifferentCourier is destroied, the base class Courier
destructor is automatically invoked. */

