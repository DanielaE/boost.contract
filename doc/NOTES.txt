
/** @note Constructor/destructor must not de able to declare self copyable.
For destructor there's no postcondition so it makes no sense to have a self.old
as it will not be used anywhere. For constructor, there was no object before
body execution so self.old is not defined and postconditions should not use it
(also this will lead to potential infinite recursion in case a copy contructor
declares self copyable as the execution of the copy contructor contract will
recursively call the copy contructor to handle old). These conditions are
statically asserted by both the macro and code APIs so you will get
DBC_ERROR_... compile errors in case you attempt to specify self copyable in
constructors or desturctors. */

/** @note Note that abstract types (a class with one or more pure virtual mem
fun) cannot be copied so you will get a compiler error if you use DBC_COPYABLE()
on an abstract type (an error like ".../post.hpp:... error: cannot allocate an 
object of abstract type ‘...’"). */

/** @note If destructor invariant check fails, no exceptions is thrown but
broken_destructor_invariant() is called instead (this is to comply with STL
requirement for destructors not to throw). User can redefine
broken_destructor_invriant() beheviour (similarly to std::terminate()), by
default this function will terminate (if user is allowing for terminating
assertions), or exit (if the user is allowing for exiting assertions), or 
simply log a message. In any case the destructor body will not be executed if
the invariant is broken. This is in accordance with [C++ Std].
Furthermore, if destructor is called as a result of an unchatched excetion
handling stack unwinding, then broken_destructor_invariant() is not called
and simply a message is log if the invarint is brken. This is necessary because
if an operation throws an invariant_violation and the user attempt to handle
that, but in a block outside the local scope of the object, the object
destructor will be called with invariant_violation still unchaought but in this
case of course the destrcutor invariat will be broken and a call to
broken_destructor_invariant() will terminate (or exit, or log) preventing the
user from handling the exception. In this case the only thing to do is not to
execute the destructor body (as the invariant if broken and the destructor code
cannot be executed safely) but not to call broken_destructor_invairnt() so the
user can handle the invariant_violation exception. If instead the destructor
body can be executed even if the invarint is broken, then the destructor shall
not be provided with a contract. This complication in case of destructor call
for stack unwinding due to an assertion violation of the same object was not
discussed in [C++ Std] (and destructors are not addressed by Eiffel at all as
Eiffel does not have destructors). (See test/Constructor/throwing... tests.)
The library complies w/ STL exception safety policies (see [Str97, Appendix E])
as destructors don't throw (broken_destrcutor_invariant() is called instead),
if constrcutor throws (pre/post/inv violation) no destructor/operation is
called, if operation throws (pre/post/inv violation) no destructor is called
unless its invariant hold. */

/** @note Using init() is not in violation with avoiding two-stage construction
as suggested in [Str97, Appendx E] as long as init() is private and called only
by constructors within the object (and not other mem fun). */

/** @note Even when using the code API, the macro DBC_CONTRACT() should be used
to name the contract member class. Using this macro allows for proper
subcontracting when using the macro API as the macro API internally use this
macro to refer to the contract name. E.g., if a contract is defined using the
code API and then subcontracted using the macro API, it will not be possible to
subcontract with the macro API unless the code API used DBC_CONTRACT() to name
then contract class (see the deep_subcontracting test). */

/** @note There was not really a Boost.MPL type I could esily use in place of
dbc::none_ (the boost::none type or boost::mpl::none<S, F> metafunction are
more complex than needed, but Boost.MPL "tiny" example introduces a tag type
used precisesly as dbc::none_). */

/** @note If your compiler supports ignoring specific warning, you can ignore
the multiple friend inclusion warnings generated by the library macro APIs.
These warnings are generated as the macro APIs need to make some library class
friends of the supplier class and if the same class is made friend friend by
a macro in multiple places (e.g., a DBC_MEM_FUN() uses for 2 different
contracts within the same class) you will get the warning.
In g++ you could use the "#pragma GCC diagnostic ignored" but unfortunately
the "multiple friend declaration" warning is not (yet) supported to be ignored.
For example:
    // File: main.cpp 
    #pragma GCC diagnostic ignored "-Wparentheses"
    int main() {
        int x = 0;
        if (x = 0) { return 1; } // Would normally generate a warning.
        return 0;
    };
    $ g++ -Wall -Werror main.cpp
This compiles without any warning and/or error as the warning normally generated
by the assgnment in the if condition is now disabled by the #pragma.
If your compiler does not support disabling this warning (as it is for g++ at
the moment) you could write scripts to parse the compiler output, skip warning
matching the warming message for multiple friends, but erroring on any other
warning message... */

/** @note Making fun::mem and post friends of self is necessary for
subcontracting. For example, if subcontracting from private base class (see
the Counter example). However, these friends declarations causes anoying
compiler warnings as the same class if fun::mem and/or post is declared friend
by the code generated by the macro multiple times... */

/** @note DBC++ allows preconditions to access private and protected mem var 
and fun of self (while Eiffel generates a compiler error). Preconditions should
only assert based on public attributes and operations of self otherwise the
user cannot fully verify preconditions are satisfied before callling the
operation (that is why Eiffel generate a complier error). However, C++ is
generally a more permissive language it might be more within C++ philosophy to
leave this up to the programmer and simply discourage writing contracts that
access private or protected members for self. This is done by making the 
contract class a friend class of self (this is required by the current revision
of the C++ standard, it will probably not be required by later standard
revisions, and it is already no longer checked by some compilers -- 
see http://blog.csdn.net/visame/archive/2008/09/06/2889834.aspx).
Leveraging current C++ standard "member classes have no special access to
members of their enclosing class", it would be possible to prevent preconditions
from accessing private and protected members by declaring friend only the
contract's ensure() and the invariant (that will then access to all members),
while not declaring friend contract's require() will allow preconditions to only
access public members of self. However, this standard clause is obsolete, it
will likely change in future revisions fo the C++ standard, and compilers (later
g++ versions included) have already started to allow member classes to have full
access of their ensclosing class. */

/** @note Self is not available in constructor preconditions because
technically there's no object before exec of constrcutor body (and for example
inv was not verified yet so using self of an obj on which inv is not checked
could lead to strange errors and contract violation). Therefore, constrcutor 
preconditions cannot call mem functions  (using self.some_function()) or access
mem variable (again, this is good as object not fully contrcuted and its inv
verified until AFTER contracutor/init body execution). Is this what Eiffel does
also? Does DBC for C++ Std reccomandation say athing about this restrinction?
Note that I had to add extra code for prevent access to self from
dbc::fun::contr so this restriction could easily be removed but I think it
makes sense have it in place... */

/** @note In contract (require(), ensure(), and DBC_INVARIANT()) object self and
all arguments are passed as constant reference so it is NOT possible to change
them (that is even if args and/or self can be changed by the body of the func,
they are const for the contract check operations). */

/** @note boost::mpl::is_copyable<> could not be used to replace
dbc::copyable<> because Boost's is_copyable<> only works for built-in types.
For user defined types, Boost's is_copyable always returns false unless special
compiler support is provided (and GCC does not provide support for this,
probably only VC++ supports this at the moment...). */

/** @note Inheriting from a dbc::object<> base class allows to provide
assertion checking state, mutex, etc. However, the invariant cannot be made
pure virtual function of dbc::object<> otherwise the invariant call will always
be ambiguis when subcontracting -- I did try this!
Note, since dbc::object<> is a template, they are all different from eavery
class type so the inheritance tree is modified by no common anchestor is
intorduced and dbc::object<> should be private base anyway -- so this 
modification of inheritance tree is OK as is does not change public APIs.
However, contract cannot access class-type directly from dbc::object because
in order to call dbc::object<C>::class_type, the contract will still need to
specify C -- so class-type must still be specified for each contract mem fun. */

/** @note Wanted to provide def constr for all contract class fun, fun::mem, etc
so they are easier to use. In particular if a mem var of a contract class type
is declared, C++ will init automatically using it's default constr. This feature
is currently not used in the library (as contracts are init manually in the
fun declaration that then call operator()) but it might turn out to be handy in
future. */

/** @note If only DBC_CHECK_INVARIANT and DBC_CHECK_REQUIRE are #define, DbC++
can be used to impl invariant checking framework similar to the only proposed
in Str97 (see example/CPP_Prog_Lang/String). In Str97, precondition checking is
not directly discussed (it is actually discouraged in a later section) but
String::operator[] has a check on the range of its index argument that is very
naturally handled with a precondition -- so DbC++ example have implemented that
index range check as a precondition. */

/** @note declaring require(), ensure(), and dbc_invariant_() pure virtual 
forces the user to define them correctly at compile time. Having them with
params allow user to only use correct param (no old or result in require())
and to name args as original function args. */

/** @note Chosen abbreviation "mem" for member and "fun" for function to follow
C++ STL conventions of std::mem_fun. Chosen "constr" and "destr"
abbreviations trying to follow similar abbreviation philosofy of STL. */

/** @note DBC_CONFIG_ macros follow name convention and semantics of 
BOOST_PP_CONFIG_ macros. */

/** @note Contracts are functor as they provide call operator() that checks
contract and inokes body (this seemed a natural choise since this is indeed
the function call). */

/** @note DBC_CONFIG_ENABLE_XYZ_ASSERTIONS do not remove assertions from obj
code. They only run on/off run-time checking of relative assertions (but the
assertions are always compiled). Use DBC_CHECK_XYZ to remove pre/post/inv
assertions (at this regardless of if they throw/exit/terminate) from obj
code. */

/** @note DBC_NO and DBC_ALL override #definitions of single DBC_CEHCKING (if
any). */

/** @note DbC++ also impl a simple version of Eiffel loop invariant checking
(see example/OO_SW_Contruction/Gcd). This hasn't been tested much... */

/** @note Different stylistic naming convetions have been used: C/C++ STL for
DBC library and test, Str97 for Str97 examples, Java-like CaMeL for DBC books
examples. This was to see how DBC will look when in code with different
styles (common C++ situation). */

/** @note DBC_CONFIG_MAX_ARGC is set to 5 by default. It can be increased 
(probably up to BOOST_PP_MAX_MAG around 255) but it will significantly increase
compilation time. Use only a reasonable number based on the number of fun args
you have (for which you need a contract). */

/** @note See examples: Stack4 for general good DBC and library usage; NameList
for inheritance; Observer for more complex inheritance and library usage (where
some classes have contracts and others don't -- but I prefer to have contracts
for all classes and all of their mem-fun/constr/destr). */

/** @note If when subcontracting DBC_BASE is omitted then base contract is
ignored. This might be inline with C++ "freedom" given to the programmer, but
in general you must NOT do that... as you will be braking your parent's contract
by not inheriting it. */

/** @note Do not enter arg default value in contract (only arg-type and 
arg-name). */

/** @note require/ensure declared pure virtual (instead of {}) so compiler error
if you miss type them (e.g., incorrect const or post<> for one of the args).
This requires a bit more work from the programmer even for contracts with no
pre/post conditions but allow to catch errors in the contract at
compile-time. */

/** @note In quite a few places in the impl (macro, fun, etc) we need to
add and them remove copyable etc because if types do not have excaly the same
signature the compiler will not match them to be the same for templates (as for
templates compiler need to wait and eval the type expression lazily...). */

/** @note Argument types are indexed from 0 to n-1 like in Boost.FunctionType
they are returned as Boost.MPL sequence that goes from 0 to n-1. Using symbols
indexed from 1 to n (A1...An, arg1_type...argn_type, etc) would have increased
(but not much) preprocessing time because Boost.Preprocessor enum and 
repetition go from 0 to n-1 by default. */

/** @note Destructor do not subcontract (i.e., their contract do not accept
DBC_BASE() and fun<>::destr<> does not accept base contract type B param). This
is beacuse C++ will automatically invoke base class destructors (with its
contract that cheks inv if base class destructor has a contract). See the 
Courier example: When DifferentCourier is destroied, the base class Courier
destructor is automatically invoked. */

