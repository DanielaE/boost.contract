
[section TODO]

This section lists open items under consideration for future development of this library.
It is mainly intended as a memorandum for the library authors.

[section Improve contract macros `sequence` error detection and reporting]

The current implementation for syntax error detection and reporting for the `sequence` parameter of the contract macros should be improved.

For example, if I forget the sequence element for the result type `(result-type)`, the preprocessor gives a ton of errors most of which are about Boost.Preprocessor internal macros and make no sense to the user.
While using the C++ preprocessor imposes some fundamental limitations on the amount of syntax checking I can implement for the `sequence` macro parameter, I should be able to improve the current library implementation.

[endsect]
[section Can block invariants and loop variants be made constant-correct?]

Currently block invariants and loop variants are /not/ constant-correct.
Class invariants, preconditions, and postconditions instead are constant-correct so to ensure that the state of the system is not changed while checking the contract.

Can block invariants and loop variants be made constant-correct also?

This seems difficult because C++ does not allow to specify "constant-block":

    { // Some existing block.
        const { // A constant block -- BUT NOT SUPPORTED!!
            // Assert here block invariants and loop variants ensuring
            // const correctness.
            ...
        }
        ...
    }

Therefore, the code asserting block invariants and loop variants has the same constant constraints (possibly none!) on object, function arguments, result, etc as the enclosing code block...
Is there a way around this?
If not, shall I still provide block invariants and loop variants (documenting this limitation) or not?

[endsect]
[section Improve compile-time performances]

The library significantly increases compile-time (and compiler memory usage) when compiling the code with contracts turned on, compared with compilation with contracts off.
Investigate what is stressing compiler performances and see if the library implementation can be optimized to improve compile-time performances.

The baseline should be compilation with all contracts turned off.
There might be different reasons for the increased compilation-time/memory:

# Contract assertions are programmed in header files so they are recompiled for each translation unit.
I can test the effect of this by disabling pre/postcondition compilation (so the library contract templates will still be compiled by the user contracts will compile much less code in the header files because there will be no pre/postcondition).
# The preprocessing time needed for the contract macros expansion and to parse the `sequence` macro parameter.
I can check this by stopping compilation after preprocessing (`-E` compiler option) and measure how long preprocessing takes compared with compilation.
# The library uses quite a bit of template metaprogramming (metafunctions, etc).
See how the compile-time effects of template metaprogramming were analyzed for the Boost.MSM library and performance a similar analysis for this library.
Also study carefully the chapter on compile-time performances of the Boost.MPL book.
# The library is intentionally making all the contract classes always templates (using the artificial `ZERO` template argument so the library can internally use `template/typename` keywords regardless of the template context).
What is the compile-time effect of these extra contract template classes compared with the effect if they have not been made templates using `ZERO`?
`ZERO` can be removed and contract classes (for non-template functions) can be made non-template but this comes at the cost of having the user specify `(template)` instead of `(class)` for template classes (this complicates the `sequence` syntax) -- so the `ZERO` workaround should be removed only if there is evidence that it will help compile-time.
# More?

Ultimately, this analysis should be added to the documentation.

[endsect]
[section Analyze run-time performances]

Provide some data to show run-time performances of contract checking -- the baseline should be run-time performance with all contracts turned off.

The library current implementation should be optimized to minimize run-time overhead of contract checking.
Preliminary data shows that the library run-time performance impact (execution time, CPU usage, and memory usage) is acceptable.
However, data should be systematically collected and analyzed to verify this (and then added to the documentation).

[endsect]
[section Support concurrency]

Understand what needs to be done to support concurrency.

__Meyer1997__ discusses issues associated with Contract Programming and concurrency when, for example, a precondition is first checked true but then the sate of the object is changed asynchronously after the precondition check and before body execution so at the time the body executes the checked precondition is no longer true.
Eiffel addresses this issue using the SCOOP concurrency model and implementing waiting contract conditions.

In general, it seems inappropriate for this library to force /one/ concurrency model for Contract Programming in C++ (SCOOP, or any other).
Synchronization, including the one of contracts, might be best left up to programmers as usual in C++.
However, currently it is not possible to lock a mutex at function entry and release it at function exit when using the contract macros.
This is because programmers can only program the body so they can lock at body scope but not at the scope of the contracted function.

More in general, the library could provide a mechanism to:

# Acquire resources (including a locks) at function entry.
# Check invariants/preconditions, execute body, check invariants/postconditions via calling contract's `call()`.
# Release the acquired resources at function exit.

For example:

    void f(void)
    CONTRACT_FUNCTION( (void) (f)( (void) )
    ``*(scoped)*`` ( // In general, no `{` parenthesis here.
        boost::recursive_mutex::scoped_lock lock(mutex);
        ... // Eventually more here.
    )
    (precondition) ({
        ...
    })
    (postcondition) ({
        ...
    })
    (body) ({
        ...
    }) )
    
    // If contracts compilation on, expands to something like this:
    void f(void)
    {
        boost::recursive_mutex::scoped_lock lock(mutex); // Scoped resources.
        contract_f_().call(); // Contract call.
    } // Releases scoped resources via their destructors.
    ...

    // If contracts compilation off, expands to something like this:
    void f(void)
    {
        boost::recursive_mutex::scoped_lock lock(mutex); // Scoped resources.
        ... // Body code
    } // Releases scoped resources via their destructors.
    ...

Note:

* Even when contract compilation is turned off, the scoped code should be part of the contract macro expansion together with the body code block.
* In general, the scoped code is /not/ a code block `{ ... }` (otherwise the acquired resources will be released at scope exit of the code block before calling `call()`) but multiple instructions can still be specified.
* Should this scoped code be enforced constant-correct?
Maybe not, it should be contract-correct only if the contracted function is a `const` member (same as for the body)... but think more about this.

In addition:

# The library uses a global variable to "globally disable assertion checking within assertion checking".
This boolean variable should be synchronized by the library in a concurrent context.
However, this will require a global lock...
Can I implement "global disabling of assertion checking within assertion checking" without a global state?
# The library uses the object member variable `contract_state_` to disable assertions within nested function calls for a given object.
This boolean member variable should be synchronized by the library in a concurrent context.
This synchronization is between object member functions, it is not global, so it might be OK...
# If implemented, both global and object synchronizations should be enabled only if a macro symbol `CONTRACT_THREADING` is #defined (#undef by default).
# Can I allow the user to configure how to synchronize global/object state?
For example, I could use a configuration macro that by default uses `boost::recursive_mutex::lock()` but it can be #redefined by the user...

Most of these are open issues that need to be analysed in greater detail.

[endsect]
[section Can constructor member initialization list limitation be removed?]

Can the contract macros overcome the constructor member initialization list limitation when separating constructor definition from declaration?
See current workaround for this as documented in `CONTRACT_CONSTRUCTOR_BODY()`.

However, this would have to work for all combinations of the followings

# With and without contracts.
# Definition together and separated from declaration.
# With and without member initialization list.

[endsect]
[section Should preconditions be checked before constructor member initialization list?]

The library checks constructor preconditions after executing the member initialization list: {Default AND Pre}Body{Post AND Inv} (Default is the member initialization list).

This is essentially what Eiffel does but constructors (and member initialization lists) are different in C++ than Eiffel.
Is this what C++ should do or {Pre AND Default} is a better approach for C++?
Why does Eiffel do {Default AND Pre}?
Does any of the Contract Programming proposals for C++ mention this issue explicitly?
Implementing {Pre AND Default} for this library might present similar challenges to separating constructor definition when member initialization list is specified (so it might not be possible given the lack of delegating constructors in C++...).

If {Pre AND Default} is a better approach, {Default AND Pre} should be documented as a library limitation.
If {Default and Pre} is a better approach, I should document why.

[endsect]
[section Can syntax of contract macros be unified with other Boost libraries?]

Look if the contract macro `sequence` syntax can be unified with the one of other Boost libraries.

Specifically, is this possible with respect to Boost.ConceptCheck and how concept checking interacts with this Contract Programming library?
Same questions respect to Boost.Parameter.
Any other Boost library I should study with respect to this issue?

[endsect]
[section  Consider allowing optional contract checking based on assertion importance and/or class name]

Let's assume I have a template library that is well tested so I want to disable postcondition checking for it.
However, this is a template library so it cannot be precompiled separately with postconditions off.
I must compile it together with the rest of the code.
Therefore, if the rest of the code needs to check postconditions, I must check postconditions for the well tested template library as well...
The extra contract checking for the template library introduces both compile-time and run-time overhead.

* I could address this if the library allowed to disable contract checking (at least at run-time) based on class and function name.

Moreover, there might be contract conditions which are very inefficient to test so I might want to turn off checking /only/ for the inefficient conditions.
With respect to this issue, __Mitchell2002__ recommends to only program preconditions in Eiffel that can be checked efficiently (as preconditions are usually left also in production code) and leave inefficient preconditions documented as code comments.

* I could address this by disabling contract checking (at least at run-time) based on some assertion /importance ordering/ (assertion importance ordering was removed from __Crowl2006__ but is was present in [Crowl2005]).

[endsect]
[section Consider adding contracts to all STL classes and functions in `contract::std::`]

All `std::` classes and functions could be wrapped by classes and functions in a namespace `contract::std::` declaring contracts for all the STL classes and functions.
The `contract::std::` namespace should have the /exact/ same structure as `std::` (so it is easy to use for C++ programmers familiar with STL).

For example a `contract::std::vector` class can wrap `std::vector` providing the exact same API but adding contracts to it (similar to the STL Vector __Example__ but int the `contract::std::` namespace).

* The contracts could assert all the STL standard guarantees.
* Postcondition and invariant checking might not add much value given that STL implementations are usually well tested, documented, and work well.
* Precondition checking might instead be valuable as they will check that the STL is not misused by the callers.

[endsect]





[/ *** PRIVATE TODOs *** ]

[/ !!! FOR MY RECORD ONLY -- LEAVE THESE COMMENTED OUT !!!

[section Rename SourceForge to contractpp]

Rename SourceForge project and SVN repository from 'dbcpp' to 'contractpp' (for Contract++).

[endsect]
[section Destructor should use `CHECK_INVARIANT` instead of CHECK_ANY]

Destructor optional compilation should just use CHECK_INVARIANT and not CHECK_ANY because there is no need to add destructor contract overhead when only pre/post are checked if no inv is checked.

Similarly, for non-member function only CHECK_PRE and CHECK_POST should be checked because they have no inv so there is no reason to add contract overhead when only inv is checked.

(Note that is NOT the case for static-members which have pre and post bust also inv (static inv) so they must use CHECK_INV, CHECK_PRE, and CHECK_POST as usual.)

[endsect]
[section Document MSVC error "warning ... not enough actual parameters for macro BOOST_PP_SEQ']

Document MSVC error "warning ... not enough actual parameters for macro 'BOOST_PP_SEQ...'" repeated many, many times when using "(f)( )" instead of "(f)( (void) )" to specify empty argument list.

[endsect]
[section Shall I try to compile on MSVC with /Wall??]

This gives a LOT of warning also in Boost...
For g++, it compiles with no warnings but the "already friend" one.

[endsect]
[section Can I remove limitation that BODY() must be used when calling overridden function]

If an overriding function does not use BODY() to invoke the overridden function, contracts go into infinite recursion.
Document this limitation (as a warning).

It is not possible to work around this limitation.
Using object state the library could detect infinite recursion between overriding and overridden function (I prototyped something like this but I am not even sure if this is 100% possible).
However, to break the recursion the base contract will have to call the base body function via static binding (otherwise using dynamic binding, default C++ behaviour for the call, the overriding function will be called causing the recursion).
The contract itself cannot perform the static binding call (e.g., using static_cast<> to the object) because the object state is changed only if pointers/references to the objects are used to call the body, but if pointers/objects are used then C++ uses dynamic binding for the call.
So the contract function could call a special method of the contracted class which performs the static binding call `contract_static_binding_body_...`.
The issue is that such a static binding call will raise a compiler error if the body function is pure virtual.
The library does not know directly when a function is pure virtual or not so the library will have to define `contract_static_binding_body_...` also for pure virtual functions and in this case the static binding call `B::f()` will raise a compile time error.
*** BUT, could I use templates so the contract_static_biding_body_ is templated and it is not compiled unless called? This way I only get the error if the use calls attempts the static binding for pure virtual?? ***

    struct base {
        virtual void call() {
            std::cout << "base call\n";
            // body(); // This causes infinite recursion as it calls deriv::body() via dynamic binding.
            static_binding_body();
        }
        void static_binding_body() {
            std::cout << "base static binding body\n";
            b::body(); // Compiler error for pure virtual body()...
        }
        virtual void body() = 0;
    //    {
    //        std::cout << "base body\n";
    //    }
    };

    struct deriv: base {
        virtual void call() {
            std::cout << "deriv call\n";
            body();
        }
        virtual void body() {
            std::cout << "deri body\n";
            base::call(); // Causes infinite recursion...
            // base::body(); // This is fine instead.
        }
    };
    
    Infinite recursion: deriv::base --> deriv::body --> base::call() --> deriv::body() causing infinite recursion because base::body() is NOT called...

So, at the moment, I did not see a way around this.
Programmers will have to pay attention and use BODY() for static binding call of the base class.

[endsect]
[section Email all referenced authors after 1st solid release]

After the 1st solid release of Contract++, email all cited authors (Crowl, Ottosen, Meyer, Mitchell, Abrahams, etc) to ask for feedback on the library.

[endsect]

]

[endsect]

