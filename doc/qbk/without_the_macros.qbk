
[section Without the Macros]

This section explains how to program contracts without using the library macros.
This is useful to better understand how the library actually implements Contract Programming and to occasionally implement workarounds for compiler standard compliance issues.
However:

[important *Recommended to Use Contract Macros*

In general, it is recommended to write contracts using the library macros because they save programmers from writing a significant amount of setup code.]

All the macros described in the __Tutorial__ section expand to code equivalent to the one explained in this section (with the exception of block invariants and loop variants which are not covered here).
See also the __Reference__ section for more details.

[section An Example (Without the Macros)]

The following example shows how to write a contract for the vector `push_back()` function without using the contract macros:

    #include "pushable.hpp" // Base class for subcontracting.
    #include <contract.hpp> // This library.
    #include <vector> // STL vector.

    template<typename T>
    class myvector: public pushable<T> {

    #if defined CONTRACT_CHECK_CLASS_INVARIANT ||   /* Support for       */ \
            defined CONTRACT_CHECK_PRECONDITION ||  /* optional contract */ \
            defined CONTRACT_CHECK_POSTCONDITION    /* compilation.      */
        // Augmented state.
        friend class contract::state;
        mutable contract::state contract_state_;
    #endif // contracts

    #if defined CONTRACT_CHECK_CLASS_INVARIANT
        // Static class invariants
        static void contract_static_invariant_(void) {
            // Assert nothing in this case.
        }
        // Class invariants.
        void contract_invariant_(void) const {
            if (!((size() == 0) == empty()))
                throw contract::failure(__FILE__, __LINE__);
            // More invariants here...
        }
    #endif // invariants

    public:
        void push_back(const T& element)
    #if defined CONTRACT_CHECK_CLASS_INVARIANT || \
            defined CONTRACT_CHECK_PRECONDITION || \
            defined CONTRACT_CHECK_POSTCONDITION
        // Contracted function.
        { contract_push_back_element_<0>().call(this , element); }
    private: // Private so not to alter user call public API.
    #if defined CONTRACT_CHECK_PRECONDITION
        void contract_precondition_push_back_element_(const T& element) const {
            if (!(size() < max_size())) 
                throw contract::failure(__FILE__, __LINE__);
            // More preconditions here...
        }
    #endif // preconditions
    #if defined CONTRACT_CHECK_POSTCONDITION
        void contract_postcondition_push_back_element_(
                const myvector* old_this, // Old value for object.
                const T& element, contract::noold // No old for `element` argument.
                ) const {
            if (!(size() == (old_this->size() + 1)))
                throw contract::failure(__FILE__, __LINE__);
            // More postconditions here...
        }
    #endif // postconditions
    protected: // Must be protected (not private) to allow subcontracting.
        void contract_body_push_back_(const T& element)
    #endif // contracts
        // Original function definition (the body).
        { vector_.push_back(element); } 
    #if defined CONTRACT_CHECK_CLASS_INVARIANT || \
            defined CONTRACT_CHECK_PRECONDITION || \
            defined CONTRACT_CHECK_POSTCONDITION
        // Contract class.
        template<int ZERO>
        struct contract_push_back_element_: contract::nonstatic_member_function<
                // Function type for contracted function.
                // Copyable class type for old object value in postconditions.
                // For constant members use `myvector const` instead of `myvector`.
                void (contract::copyable<myvector>*, const T&),
                // Base contract class for subcontracting.
                typename pushable<T>::template contract_push_back_element_<0>
                > {
            // Constructor specifies body, preconditions, and postconditions.
            contract_push_back_element_(): contract::static_member_function<
                    void (contract::copyable<myvector>*, const T&),
                    typename pushable<T>::template contract_push_back_element_<0>
                    >(    &myvector::contract_body_push_back_
    #if defined CONTRACT_CHECK_PRECONDITION
                        , &myvector::contract_precondition_push_back_element_
    #endif // preconditions
    #if defined CONTRACT_CHECK_POSTCONDITION
                        , &myvector::contract_postcondition_push_back_element_
    #endif // postconditions
                    ) {} 
        };
    public: // Restore original access level.
    #endif // contracts

        ... // Rest of the class.

    private:        
        std::vector<T> vector_;
    };

Let's take a close look at this code.

[endsect]
[section Optional Contract Compilation]

First of all, note that when programmers completely disable contract compilation by not #defining any of the `__CONTRACT_CHECK_CLASS_INVARIANT__`, `__CONTRACT_CHECK_PRECONDITION__`, and `__CONTRACT_CHECK_POSTCONDITION__`  macro symbols, the code above reduces to just the function declaration and its definition without *any* contract code overhead:

    template<typename T>
    class myvector {

        ``*// Augmented state and class invariants disappear!*``
    
    public:
        void push_back(const T& value)
        ``*// Preconditions, postconditions, and body functions disappear!*``
        {
            vector_.push_back(value); // Original function implementation.
        }
        ``*// Contract class disappears!*``
    public:

        ...
    private:
        std::vector<T> vector_;
    };

Note how the `__CONTRACT_CHECK_CLASS_INVARIANT__`, `__CONTRACT_CHECK_PRECONDITION__`, and `__CONTRACT_CHECK_POSTCONDITION__`  macros can be #defined independently to selectively turn on or off the compilation of class invariants only, preconditions only, postconditions only, or any combination of the above.

The rest of this section illustrates what happens when contract compilation is turned on.
Therefore, from here on, we will assume that `__CONTRACT_CHECK_CLASS_INVARIANT__` , `__CONTRACT_CHECK_PRECONDITION__`, and `__CONTRACT_CHECK_POSTCONDITION__` are all #defined.

[endsect]
[section Assertions]

Note how class invariants, preconditions, and postconditions are asserted using an `if`-statement that throws a `contract::__failure__` exception in case the checked boolean condition is false (note the leading `"!"` within the `if`-condition):

    // Code from the non-static class invariants (but similar for
    // static class invariants, preconditions, and postconditions).
    if (``*!*``((size() == 0) == empty()))
        throw contract::failure(__FILE__, __LINE__);
        
When an exception (/any/ exception) is thrown from within class invariants, preconditions, or postconditions code blocks, the library will handle the exception invoking the relative `contract::__class_invariant_failed__()`, `contract::__precondition_failed__()`, or `contract::__postcondition_failed__()` function (but only if that is necessary according to subcontracting rules, see below).
Therefore, the fact that the contract condition check throws `contract::__failure__` does /not/ necessarily imply that the program itself will throw but only that the correct contract failure handler function will be invoked by the library.
All contract failure handler functions terminate by default but they can be customized (see __Throw_on_Failure__ for an example).

It is not possible to directly call `contract::__class_invariant_failed__()`, `contract::__precondition_failed__()`, or `contract::__postcondition_failed__()` instead of throwing the exception because of subcontracting.
For example, if a precondition of a derived contract fails but the preconditions of an overridden contract hold true then the library will /not/ call `contract::__precondition_failed__()` even if the derived contract throws an exception (as specified by subcontracting requirements in __Member_Function_Call_Semantics__).

The first two arguments of the `contract::__failure__` constructor are mandatory and they specify file name and line number of the assertion (used the C++ macros `__FILE__` and `__LINE__`).
The third argument of the constructor is an optional human readable description of the asserted condition.
For example:

    // More verbose error message with .
    if (!((size() == 0) == empty()))
        throw contract::failure(__FILE__, __LINE__, "size zero iff empty");

All this information is simply used to provide the user with a descriptive error message in case of a contract failure, for example:

[pre
class invariant: terminate called after throwing an instance of 'contract::failure'
  what():  contract "size zero iff empty" failed at myvector_nomacros.cpp:37
Aborted
]

[endsect]
[section Augmented State]

This library needs to declare an additional member variable for the class. 
This member variable is mainly used by the library to keep track of when contracts are being checked so to disable assertion checking in nested member function calls that could otherwise result in infinite recursion (this a common requirement in Contract Programming).

    template<typename T>
    class myvector: public pushable<T> {

        // Augmented state.
        friend class contract::state;
        mutable contract::state contract_state_;

        ...
    };

The state member variable must be declared of `mutable` type `contract::__state__` (so the library can modify it while still ensuring constant-correctness for the contracts), it should be in a private section of the class (so not to alter the class public API), and it must have the predefined name `__contract_state___` (so the library knows how to access it).
Furthermore, the `contract::__state__` class type must be declared a friend so the library can internally access the entire user class including its private and protected members.

The details of the `contract::__state__` type are library implementation specific.
The state variable name begins with the `contract` prefix and ends with an underscore "`_`" so programmers should never directly use it in user code (see __Getting_Started__).

[endsect]
[section Class Invariants]

This library checks static and non-static class invariants invoking a static and a constant member function with the predefined names `__contract_static_invariant___` and `__contract_invariant__` respectively:

    template<typename T>
    class myvector: public pushable<T> {
        ...
        
        // Static class invariants
        static void contract_static_invariant_(void) {
            // Assert nothing in this case.
        }
        // Class invariants.
        void contract_invariant_(void) const {
            if (!((size() == 0) == empty()))
                throw contract::failure(__FILE__, __LINE__);
            // More invariants here...
        }
        
        ...
    };

The non-static class invariant function must a constant member so to enforce contract checking constant-correctness.
The static class invariants function is static so it cannot change the object state because it cannot access the object (static member functions cannot be constant).

The class invariant function names begin with the `contract` prefix and end with an underscore "`_`" so programmers should never directly use it in user code (see __Getting_Started__).

[endsect]
[section Contracted Function]

The `push_back()` function is programmed to construct the `contract` object and to invoke its `__call__()` member function:

    template<typename T>
    class myvector: public pushable<T> {
        ...

    public:
        void push_back(const T& element)
        // Contracted function.
        {
            contract_push_back_element_<0>().call(this , element);
        }

        ...
    };

The `__call__()` function takes in input a pointer to the object (`this`) and the function arguments (just `element` in this example) in the order they appear in the function declaration.

The `__call__()` function is the one implementing the correct Contract Programming call semantics (see __Member_Function_Call_Semantics__).
In this case, `__call__()` checks class invariants and preconditions (calling `__contract_static_invariant___()`, `__contract_invariant___()`, and the __precondition__ function, see below), then it executes the body, and lastly it checks class invariants and postconditions (calling `__contract_static_invariant___()`, `__contract_invariant___()`, and the __postcondition__ function, see below).

[endsect]
[section Preconditions]

A member function is defined to check the preconditions:

    template<typename T>
    class myvector: public pushable<T> {
        ...

    private:
        void contract_precondition_push_back_element_(const T& element) const {
            if (!(size() < max_size())) 
                throw contract::failure(__FILE__, __LINE__);
            // More preconditions here...
        }
        
        ...
    };

Note the followings:

* The precondition function is private so not to alter the user class public API.
* In order to support contracts for overloaded functions, the precondition function name must contain the contracted function name, the name of all arguments, and the trailing cv-qualifier if the contracted function is cv-qualified (similarly to the contract class name, see below).
* The precondition function must be a constant member plus all its arguments must be constant so to enforce contract constant-correctness.
* The precondition function must be `volatile` if the contracted function is `volatile`.
* The precondition function arguments are constant references to the contracted function arguments.

The precondition function name begins with the `contract` prefix and ends with an underscore "`_`" so programmers should never directly use it in user code (see __Getting_Started__).

[endsect]
[section Postconditions]

A member function is defined to check the postconditions:

    template<typename T>
    class myvector: public pushable<T> {
    
    private:
        ... // Preconditions.
        void contract_postcondition_push_back_element_(
                const myvector* old_this, // Old value for object.
                const T& element, contract::noold // No old for `element` argument.
                ) const {
            if (!(size() == (old_this->size() + 1)))
                throw contract::failure(__FILE__, __LINE__);
            // More postconditions here...
        }

        ...
    };

Note the followings:

* The postcondition function is private so not to alter the user class public API.
* In order to support contracts for overloaded functions, the postcondition function name must contain the contracted function name, the name of all arguments, and the trailing cv-qualifier if the contracted function is cv-qualified (similarly to the contract class name, see below).
* The postcondition function must be a constant member plus all its arguments must be constant so to enforce contract constant-correctness.
* The precondition function must be `volatile` if the contracted function is `volatile`.
* The first postcondition function argument is a constant pointer to the object old value when the class type is tagged `contract::__copyable__` within the contract class (see below), otherwise it is of type `contract::noold`.
* The remaining postcondition function arguments are constant references to the contracted function argument current and old values.
A function argument old value is different from `contract::nold` only if the argument type is tagged `contract::__copyable__` within the contract class (see below).
* Finally, for non-void contracted functions, there is an extra argument at the very end of the postcondition function argument list which is a constant reference to the function result value being returned.

The `contract::noold` type is used as a "placeholder" for an argument when its old value is /not/ provided in the postconditions.
An `contract::noold` argument cannot be mistakenly accessed or manipulated by programmers because `contract::noold` is an empty class with no member at all.
Furthermore, copying `contract::noold` performs no operation so `contract::noold` arguments can be passed to the postcondition function by value but without adding any run-time overhead.
This ensures that programmers can only access old values in postconditions for types that are tagged `contract::__copyable__`.

This is an example where the old value is provided for both the object and one of the function arguments:

    template<typename T>
    class myvector: public pushable<T> {
        ...
    
    public:
        iterator insert(iterator where, const T& element)
        ...
        void contract_postcondition_insert_insert_where_element_(
                const myvector* old_this, // Old value for object.
                const iterator& where, const iterator& old_where, // Old value for `where`.
                
                const T& element, contract::noold, // No old for `element` argument.
                const iterator& result // Result value.
                ) const {
            ... // Assert postconditions using `old_this` and `old_where`.
        }
        ... // Both class type and `where` type are tagged `contract::copyable`.
            // in the contract class (see below).
        
        ...
    };

The postcondition function name begins with the `contract` prefix and ends with an underscore "`_`" so programmers should never directly use it in user code (see __Getting_Started__).

[endsect]
[section Body]

A member function is declared as the body function and it is defined to be the original function implementation as specified by the user:

    template<typename T>
    class myvector: public pushable<T> {
        ...

    protected:
        void contract_body_push_back_(const T& element)
        // Original function definition (the body).
        {
            vector_.push_back(element);
        } 
        
        ...
    };

Note the followings:

* The body function is protected to avoid changing the user's class public API but it cannot be private to allow for subcontracting of pure virtual functions.
* The body function declaration and definition must be /exactly/ the ones specified by the user for the original `push_back()` function (only the function name is different).
For example, if the original function is declared `virtual`, the body function should be declared `virtual` as well.
Also the body function signature (return type, argument type, argument names, eventual cv-qualifier, etc) must match exactly the signature of the original `push_back()` function.

The body function name begins with the `contract` prefix and ends with an underscore "`_`" so programmers should never directly use it in user code (see __Getting_Started__).

[h5 Separating the Definition]

In this example, the body function definition `{ vector_.push_back(element); }` is specified together with the body function declaration.
However, following C++ usual syntax, programmers can define the body function to be "`;`" in order to separate the function definition from its declaration:

    // Declarations (usually in header files).

    template<typename T>
    class myvector: public pushable<T> {
        ...

    protected:
        void contract_body_push_back_(const T& element)
        ``*;*`` // Separating body definition using `;`.
        
        ...
    };
    
    // Separated definitions (eventually in a different file).

    template<typename T>
    void myvector<T>::
    #if defined CONTRACT_CHECK_CLASS_INVARIANT || \
            defined CONTRACT_CHECK_PRECONDITION || \
            defined CONTRACT_CHECK_POSTCONDITION
        ``*contract_body_push_back_*`` // Body function name.
    #else
        ``*push_back*`` // Actual function name if contract compilation is off.
    #endif
            (const T& element) {
        vector_.push_back(element); // Original function definition.
    }

In this case, it is recommended to used the `__CONTRACT_BODY__()` macro instead of the hard to read `#if` around the function name.
If contract compilation is on, `__CONTRACT_BODY__(push_back)` expands to `contract_body_push_back_`, otherwise it expands to `push_back` (see __Reference__ and __Tutorial__ sections).
Using this macro, the above function definition is equivalently written as:

    // Separated definitions (eventually in a different file).

    template<typename T>
    void myvector<T>::``*CONTRACT_FUNCTION_BODY(push_back)*``(const T& element) {
        vector_.push_back(element); // Original function definition.
    }

[h5 Pure Virtual Functions]

Programmers can also define the body function to be pure virtual so to defer its definition to derived classes.
In this case the usual C++ syntax "` = 0;`" is used:

    template<typename T>
    class pushable {
        ...

    protected:
        void contract_body_push_back_(const T& element)
        ``*= 0;*`` // Contract for pure virtual functions.
        
        ...
    };

[endsect]
[section Contract Class]

A member class is defined as the contract class:

    template<typename T>
    class myvector: public pushable<T> {
        ...
        
    protected:
        ...
        // Contract class.
        template<int ZERO>
        struct contract_push_back_element_: contract::nonstatic_member_function<
                // Function type for contracted function.
                // Copyable class type for old object value in postconditions.
                // For const members, use `myvector const` instead of `myvector`.
                void (contract::copyable<myvector>*, const T&),
                // Base contract class for subcontracting.
                typename pushable<T>::template contract_push_back_element_<0>
                > {
            // Constructor specifies body, preconditions, and postconditions.
            contract_push_back_element_(): contract::nonstatic_member_function<
                    void (contract::copyable<myvector>*, const T&),
                    typename pushable<T>::template contract_push_back_element_<0>
                    >(    &myvector::contract_body_push_back_
                        , &myvector::contract_precondition_push_back_element_
                        , &myvector::contract_postcondition_push_back_element_
                    ) {} 
        };
    public: // Restore original access level.
    
        ...
    };

Note the followings:

* The contract class is protected to avoid changing the user's class public API but it cannot be private because derived classes might need to access it for subcontracting.
* The contract class publicly inherits (it is a `struct`) from `contract::__nonstatic_member_function__`. 
The `__call__()` function, which implements the contract call semantics, is inherited from this base class.
* The `contract::__nonstatic_member_function__` template takes as first parameter the a function type matching the signature of the contracted `push_back()` function.
    * For member functions (including static members, constructors, and destructors, see `contract::__static_member_function__`, `contract::__constructor__`, and `contract::__destructor__` respectively), the first argument of the function type if a pointer to the class type, followed by the contracted function argument types.
Instead, for non-member functions (see `contract::__nonmember_function__`), there is no class pointer type and the first argument of the function type matches the first argument type of the contract function.
(This is the same syntax used by __Boost_Function__
[footnote A more natural syntax would have been to use C++ function pointer types because they already provide a syntax for non-member functions /result-type/` (*)(`/argument-type1/`, ...)` and a different syntax for member function /result-type/` (`/class-type/`::*)(`/argument-type1/,` ...)`.
However, the use of function pointer types to resolve partial template specializations (as needed by this library) it not fully supported by all compilers (notably MVSC 8.0 has issues in resolving template specializations between void constant and non-void constant member functions using function pointer types).
Therefore, the __Boost_Function__ preferred syntax was adopted for this library (also this harmonizes this library more with the __Boost__ libraries).
The __Boost_Function__ portable syntax was not used because it is maintained by __Boost_Function__ for backward compatibility only and it is not recommended (even if that would have been the most portable syntax across the different compilers, see __Boost_Function__ for more information).
].)
    * For cv-qualified member functions, the first argument is specified as a cv-qualified pointer to the class type.
For example, if the function in this example were to be a `const` member function `void push_back(...) const` then the function type would have been `void (contract::__copyable__<myvector const>*, const T&)`.
Note that when both `const` and `contract::__copyable__` are used, `const` must be used within `contract::__copyable__`
[footnote However, if the member function is constant it cannot modify the object so there is in principle no need to copy the object value before body execution because the body cannot modify the object in the first place].
Similarly, for `volatile` and `const volatile`.
    * In the function type, the class type (which is specified only for member functions) and the argument types can be tagged `contract::__copyable__` if the relative old values are needed in postconditions.
Any type tagged `contract::__copyable__` (`myvector` in this example) must have an accessible constant-correct copy constructor otherwise the library will generate a compile-time error (see `contract::__copy__`).
Note that the object `contract::__copyable__` only wraps the class type and not the pointer (i.e., `contract::__copyable__<myvector*>` is invalid) but for all the contracted function argument types `contract::__copyable__` wraps the entire type including eventual pointers -- this is because for member functions, the first argument of the function type must always be a pointer to the class type (even when the class type is tagged `contract::__copyable__` and/or it is qualified `const`).
* When subcontracting, the base contract classes are specified as the optional template parameters following the function type for `contract::__nonstatic_member_function__` (one base contract is specified in this case `pushable<T>::contract_push_back_element<0>`).
All these template parameters are optional and multiple base contract classes can be specified to support subcontracting for multiple inheritance.
* The contract class must define a public default constructor (i.e., with no arguments) which constructs the base class `contract::__nonstatic_member_function__` passing function pointers to the body, precondition, and postcondition (so the contract knows which function to invoke to execute the body, check preconditions, and check postconditions).

[note
The contract class is declared as a template using the /artificial/ template parameter `int ZERO` to support an internal library workaround.
This allows the library to internally use the `typename` and `template` keywords freely to explicitly characterize types even without knowing if the contracted class is a template or not.
The artificial template parameter `int ZERO` is not needed if the contracted function is already a template (in which case `int ZERO` is replaced by the actual function template parameters).

The value of artificial template parameter `int ZERO` is not used so any value can be specified. However, it is recommended to always specify the value `0` for consistency (this is practice followed by this documentation).
]

[h5 Contract Class Name]

Note how, similarly to the precondition and postcondition function names, the contract class name repeats the function name and the argument names.
Furthermore, for cv-qualified member functions, the contract class name should end with the cv-qualifier.
This is necessary to support contracts for overloaded functions (with the limitation that overloaded functions, with the same number of arguments and same constant qualifier, must have different argument names and not just different argument types otherwise contract names will clash).
In summary, the contract class name should be as follow:

    contract_``/function-name/``_``/argument-name1/``_``/argument-name2/``_``/...argument-nameN/``_``/[/``const_``/]/````/[/``volatile_``/]/``

In order to allow the contract macros to subcontract from hand-written contracts, you must follow the above convention in naming the contract class at all times (because this is the convention that the contract macros assume).

The contract class name begins with the `contract` prefix and ends with an underscore "`_`" thus programmers should never directly use this class in user code (see __Getting_Started__).

[endsect]
[section Static Member Functions]

Contracts can also be programmed for static member functions (see the example at the end of this section).
However, compared with non-static member function contracts the following differences apply:

* The `contract::__static_member_function__` class template is used instead of `contract::__nonstatic_member_function__`.
* The class type cannot be tagged `contract::__copyable__` or qualified `const` (because there is no object to copy or to not modify).
* The precondition, postcondition, and body functions must be `static` members (and therefore they cannot be `const`).
* No base contract class can be specified because `static` members cannot be `virtual` so they cannot subcontract.

All these constraints are enforced by the library at compile-time.

[endsect]
[section Constructors]

Contracts can also be programmed for constructors (see the example at the end of this section).
However, compared with non-static member function contracts the following differences apply:

* The `contract::__constructor__` class template is used instead of `contract::__nonstatic_member_function__`.
* The class type cannot be tagged `contract::__copyable__` or qualified `const` (because there is no object before body execution to copy and the object is always modified by the body as it is constructed).
* The `contract::__constructor__` function type template parameter must always specify a `void` return type (because constructors return no value).
* The precondition function must be `static` because constructor preconditions cannot access the object (as there is no object before constructor body execution).
* The postcondition function always specifies `contract::__noold__` for the object old value because constructor postconditions can never access the object old value (as there was no object before constructor body execution).
Furthermore, the function type passed to `contract::__constructor__` cannot tag the class type `contract::__copyable__`.
* No base contract class can be specified because constructors do not directly  subcontract (the C++ object construction mechanism will automatically invoke the base class constructor contracts if present).

All these constraints are enforced by the library at compile-time.

[endsect]
[section Destructors]

Contracts can also be programmed for destructors (see the example at the end of this section).
However, compared with non-static member function contracts the following differences apply:

* The `contract::__destructor__` class template is used instead of `contract::__nonstatic_member_function__`.
* The class type cannot be tagged `contract::__copyable__` or qualified `const` (because there are no postconditions to accessed to copied object and the object is always modified by the body as it is destructed).
* The `contract::__destructor__` function type template parameter must always specify a `void` return type and have no argument (because destructors return no value and have no argument).
Furthermore, the function pointer cannot tag the class type `contract::__copyable__`.
* The `contract::__destructor__` constructor only takes the body function pointer and it does not take the precondition and postcondition function pointers (because destructors have no preconditions and no postconditions as they have no arguments and there is no object after destructor body execution).
* No base contract class can be specified because destructors do not directly  subcontract (the C++ object destruction mechanism will automatically invoke the base class destructor contracts if present).

All these constraints are enforced by the library at compile-time.

[endsect]
[section Non-Member Functions]

Contracts can also be programmed for non-member functions (see the example at the end of this section).
However, compared with non-static member function contracts the following differences apply:

* The `contract::__nonmember_function__` class template is used instead of `contract::__nonstatic_member_function__`.
* The function type passed as the first template parameter to `contract::__nonmember_function__` does /not/ specify the class type (i.e., /result-type/` (`/argument-type1/`, ...)` is used instead of /result-type/` (`/class-type/`*,` /argument-type1/`, ...)`).
* The precondition, postcondition, body functions, and the contract class are not members.
* The contracted function definition must be `inline` and it must appear at the very end of the contract after the precondition, postcondition, body functions, and the contract class (to avoid duplicate definitions and missing definitions compile-time errors).

All these constraints are enforced by the library at compile-time.

[endsect]
[section A Fully Working Example (Without the Macros)]

We conclude this section with a fully working example that can be compiled.
This example illustrates how to use the library to program contracts without the macros.

For simplicity, this example only exposes a limited subset of the `std::vector` operations and it only programs simple contracts for them (see the STL Vector __Example__ for `std::vector` complete contracts).
Furthermore, the somewhat artificial base classes have been deliberately introduced to illustrate subcontracting and they will probably not be part of real code.

Comparing this example with the one presented in the __Tutorial__ section, it is easy to note how much more setup code around the contract assertions is required when the contract macros are not used.
Therefore, the use of the contract macros is always recommended.

[myvector_nomacros_cpp]

[endsect]
[endsect]

