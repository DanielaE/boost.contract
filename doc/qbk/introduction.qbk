
[/ Copyright (C) 2008-2012 Lorenzo Caminiti ]
[/ Distributed under the Boost Software License, Version 1.0 ]
[/ (see accompanying file LICENSE_1_0.txt or a copy at ]
[/ http://www.boost.org/LICENSE_1_0.txt) ]
[/ Home at http://sourceforge.net/projects/contractpp ]

[section Introduction]

Contract Programming allows to specify preconditions, postconditions, and class invariants that are automatically checked when functions are executed at run-time.
These conditions assert program specifications within the source code itself allowing to find bugs more quickly during testing, making the code self-documenting, and increasing overall software quality.

The following example shows how to use this library to program contracts for the [@http://www.sgi.com/tech/stl/BackInsertionSequence.html `std::vector::push_back`] member function (for simplicity, the full contracts are not programmed here, see the __Examples__ section for a fully contracted version of `std::vector`).
In order to illustrate subcontracting, this `vector` class inherits from the (somewhat arbitrary) `pushable` base class (see also [@../../example/features/push_back.cpp =push_back.cpp=]):

[import ../example/features/push_back.cpp]
[push_back]

This library executes the following steps when the `vector::push_back` function above is called at run-time (see also the __Contract_Programming_Overview__ section):

* First, the class invariants and the function preconditions are checked.
* Then, the function body following the contract declaration is executed.
* Last, the class invariants and the function postconditions are checked.
* When subcontracting (like in the example above), this library will automatically check derived and base preconditions in __OR__, derived and base postconditions in __AND__, derived and base class invariants in __AND__.

For example, if there is a bug in the function caller for which `push_back` is called when `size` is equal to `max_size` then the execution of the program will terminate with an error message similar to the following, thus it will be evident the bug is in the caller:

[pre
    precondition assertion "size() < max_size()" failed: file "push_back.cpp", line 33
]

Instead, if there is a bug in the `push_back` implementation for which `size` is not increased by `1` after `value` is added to `vector` by the function body then the execution will terminate with an error message similar to the following, thus it will be evident the bug is in the `push_back` body:

[pre
    postcondition assertion "size() == *old_size + 1" failed: file "push_back.cpp", line 36
]

By default, when an assertion fails this library prints an error message the standard error `std::cerr` and then it terminates the program calling `std::terminate` (but this behaviour can be customized to any user-defined action including throwing an exception, see the __Contract_Failure_Handlers__ section).
Note that the error message printed by this library contains information to easily and uniquely identify the assertion that failed.
[footnote
*Rationale.*
The assertion failure message generated by this library follows a format similar to the message printed by __Clang__ when the C-style `assert` macro fails.
]

[note
C++11 lambda functions are required to use this library without having to write a significant amount of boiler-plate code (but see also __No_Lambda_Functions).
Other C++11 features (like auto declarations) are not really necessary even if they are sometime used in this documentation for convenience.
]

[endsect]

