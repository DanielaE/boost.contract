// Copyright (C) 2009-2010 Lorenzo Caminiti.
// Use, modification, and distribution is subject to the
// Contract++ Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt.)

/** @file
Contract macros.

These macros are the primary tools to write contracts.

@See See the Tutorial section for examples.
*/










/** 
Macro used to write (static and non) class invariants.

This macro should be used in a private section in the class declaration.
There is no need for a trailing <c>";"</c> after the macro closing parenthesis <c>")"</c>.

For example (see the Tutorial section for more information):
@code
    template<typename T>
    class myvector {

        CONTRACT_INVARIANT( (static) ({
            ... // Assert static class invariants.
        }) ({
            ... // Assert non-static class invariants.
        }) ) // No need for ";" after macro closing parenthesis ")".
        
        ... // Rest of the class.
    };
@endcode

@Params
@Param{sequence,
    A Boost.Preprocesor sequence of tokens <c>(<em>1st-token</em>)(<em>2nd-token</em>)<em>...</em>(<em>last-token</em>)</c> that specifies static and non-static class invariants.
    - At least one of the class invariants must be specified (i.e.\, you can  specify only non-static class invariants\, only static class invariants\, or both static and non-static class invariants).
    - The code block <c>({ ... })</c> following <c>(static)</c> should assert static class invariants. The other code block should assert non-static class invariants.
    - The class invariant @c sequence syntax is as follows (<em>[]</em> for optional tokens):

<c>
<em>[</em>(static)({ ... })<em>]
</em>({ ... })
</c>
}
@EndParams

@Returns
See the Without the Macro section for examples of the code generated by this macro expansion.
@li If contract compilation is turned on, this macro expands to the augmented state member variable named @c contract_state_.
@li Furthermore, if invariants compilation is specifically turned on, this macro expands to the static member function @c contract_static_invariant_ and the non-static member function @c contract_invariant_ defined respectively using the two code blocks from <c>(static)({ ... })</c> and <c>({ ... })</c>.
@li Otherwise, if contract compilation is turned off, this macro expands to nothing (and no contract overhead is added).

@Note Even if a class has no invariants, you must still use this macro (with an empty code block) otherwise the library will generate a compile-time error saying that it cannot find the invariant check function for your class (see the Tutorial section for more information):
@code
    class myclass {

        // Assert no invariant (mandatory).
        CONTRACT_INVARIANT( ({}) )
        
        ... // Rest of the class.
    };
@endcode
In this case, <c>CONTRACT_INVARIANT()</c> cannot be used instead of <c>CONTRACT_INVARIANT( ({}) )</c>.
This is because ISO standard C++ does not allow for empty macro parameters (this library also supports @c CONTRACT_INVARIANT() but this will only compile on C99 so its use is not recommended -- see the Tutorial section for more information).

@See @c CONTRACT_ASSERT(), @c CONTRACT_CONSTRUCTOR(), @c CONTRACT_DESTRUCTOR(), @c CONTRACT_FUNCTION()
*/
#define CONTRACT_INVARIANT(sequence)










/**
Macro used to write contracts for constructors.

This macro must be used right after the constructor declaration -- and after the member initialization list if such a list is specified.
There is no need for a trailing <c>";"</c> after the macro closing parenthesis <c>")"</c>.

For example (see the Tutorial section for more information):
@code
    template<typename T>
    class myvector {
        ... // Invariants.

    public:
        explicit myvector(size_type count) // Constructor declaration.
                : vector_(count) // Member initialization list.
        CONTRACT_COSTRUCTOR( (class) (myvector)
                (public) (myvector)( (size_type)(count) )
        (precondition) ({
            ... // Assert constructor preconditions.
        })
        (postcondition) ({
            ... // Assert constructor postconditions.
        }) 
        (body) ({
            ... // Actual constructor implementation.
        }) ) // No need for ";" after macro closing parenthesis ")".
    
        ... // Rest of the class.
    };
@endcode

@Params
@Param{sequence,
    A Boost.Preprocessor sequence of tokens <c>(<em>1st-token</em>)(<em>2nd-token</em>)<em>...</em>(<em>last-token</em>)</c> that repeats the constructor signature syntactic elements and specifies the contract.
    - The signature tokens are needed by the library to generate the contract code with the function name\, the argument types and names\, etc as discussed in the Without the Macros section (e.g.\, the argument names are needed to actually name the precondition and postcondition function arguments).
    - The extra parenthesis <c>()</c> around the tokens are mandatory (they are the ones making the preprocessor sequence).
    - It is recommended to use @c CONTRACT_ASSERT() to assert preconditions and postconditions within the relative code blocks.
    - Within the postcondition code block\, <c>CONTRACT_OLDOF(</c><em>argument-name</em><c>)</c> is a constant reference to the related old argument value (as the value was before body execution) but only if the <em>argument-type</em> was tagged <c>(copyable)</c> in @c sequence.
    - For the body block\, <c>";"</c> can be used to separate the constructor definition from its declaration (see @c CONTRACT_CONSTRUCTOR_BODY()).
    - As explained in the Tutorial section\, the tokens in @c sequence appear in the exact same order as they appear in the constructor declaration followed by the optional preconditions\, optional postconditions\, and mandatory body.
    - The constructor @c sequence syntax is as follows (<em>[]</em> for optional tokens\, <em>{}</em> tokens resulting from parenthesis contents evaluation\, <em>||</em> one token or the other\, <em>+</em> tokens repeated 1 or more times):

<c>
<em>[</em>(class)<em>]</em> (<em>class-type</em>)
<em>{</em>(public) <em>||</em> (protected) <em>||</em> (private)<em>}</em>
<em>[</em>(template)( <em>{</em>(<em>function-template-parameter-type</em>)(<em>function-template-parameter-name</em>)<em>}+</em> )<em>]</em>
(<em>class-name</em>)( <em>{</em>(void) <em>||</em> <em>{[</em>(copyable)<em>]</em>(<em>argument-type</em>)(<em>argument-name</em>)<em>}+}</em> )
<em>[</em>(precondition) ({ ... })<em>]</em>
<em>[</em>(postcondition) ({ ... })<em>]</em>
(body) ({ ... })
</c>
}
@EndParams

@Returns
See the Without the Macro section for examples of the code generated by this macro expansion.
@li If contract compilation is turned on, this macro expands to the constructor contract.
@li Otherwise, if contract compilation is turned off, this macro expands to just the constructor function body using the given body code block (and no contract overhead is added).

@Note For functions with no argument <c>(<em>class-name</em>)( (void) )</c>, and not just <c>(<em>class-name</em>)( )</c>, must be used to specify the empty argument list within @c sequence.
This is because ISO standard C++ does not allow for empty macro parameters (this library also supports <c>(<em>class-name</em>)( )</c> but this will only compile on C99 so its use is not recommended -- see the Tutorial section for more information).

@Note In comparing the @c sequence syntax of constructors with the one of member functions from @c CONTRACT_FUNCTION(), note the following differences (see also the Constructor Call Semantics in the Tutorial section):
There is no <c>(copyable)</c> before <em>class-type</em> because there is no object before construction body execution;
There is no <c>(inherit)</c> because constructors cannot directly subcontract;
There is no <c>(static)</c> or <c>(virtual)</c> because constructors cannot be static or virtual;
There is no <c>(<em>result-type</em>)</c> because constructors have no return value;
The <em>function-name</em> must be the <em>class-name</em> as always for constructors;
There is no trailing <c>(const)</c> because constructor cannot be constant members.

@See @c CONTRACT_ASSERT(), @c CONTRACT_INVARIANT(), @c CONTRACT_DESTRUCTOR(), @c CONTRACT_FUNCTION()
*/
#define CONTRACT_CONSTRUCTOR(sequence)










/**
Macro used to write contracts for destructors.

This macro must be used right after the destructor declaration.
There is no need for a trailing <c>";"</c> after the macro closing parenthesis <c>")"</c>.

For example (see the Tutorial section for more information):
@code
    template<typename T>
    class myvector {
        ... // Invariants.

    public:
        virtual ~myvector(void) // Destructor declaration.
        BOOST_CONTRACT_DESTRUCTOR( (class) (myvector)
                (public) (virtual) (myvector)( (void) )
        // Never preconditions or postconditions for destructors.
        (body ({
            ... // Actual destructor implementation.
        }) ) // No need for ";" after macro closing parenthesis ")".
        
        ... // Rest of the class.
    };
@endcode

@Params
@Param{signature_sequence,
    A Boost.Preprocessor sequence of tokens <c>(<em>1st-token</em>)(<em>2nd-token</em>)<em>...</em>(<em>last-token</em>)</c> that repeats the destructor signature syntactic elements.
    - The signature tokens are needed by the library to generate the contract code with the function name\, the argument types and names\, etc as discussed in the Without the Macros section.
    - The extra parenthesis <c>()</c> around the tokens are mandatory (they are the ones making the preprocessor sequence).
    - For the body code block\, <c>";"</c> can be specified to separate the destructor definition from its declaration (see @c CONTRACT_DESTRUCTOR_BODY()).
    - As explained in the Tutorial section\, the tokens in @c sequence appear in the exact same order as they appear in the destructor declaration followed by the mandatory body code block.
    - The destructor @c sequence syntax is as follows (<em>[]</em> for optional tokens\, <em>{}</em> tokens resulting from parenthesis contents evaluation\, <em>||</em> one token or the other):

<c>
<em>[</em>(template)<em>]</em> (<em>class-type</em>)
<em>{</em>(public) <em>||</em> (protected) <em>||</em> (private)<em>}</em> [(virtual)]
(<em>class-name</em>)( (void) )
(body) ({ ... })
</c>
}
@EndParams

@Returns
See the Without the Macro section for examples of the code generated by this macro expansion.
@li If contract compilation is turned on, this macro expands to the destructor contract.
@li Otherwise, if contract compilation is turned off, this macro expands to just the destructor function body using body code block (and no contract overhead is added).

@Note Destructor have no argument so <c>(void)</c> must always be used  in <c>(<em>class-name</em>)( (void) )</c> to specify the empty argument list within @c sequence.
This is because ISO standard C++ does not allow for empty macro parameters (this library also supports <c>(<em>class-name</em>)( )</c> but this will only compile on C99 so its use is not recommended -- see the Tutorial section for more information).

@Note In comparing the @c sequence syntax of destructors with the one of member functions from @c CONTRACT_FUNCTION(), note the following differences (see also the Destructor Call Semantics in the Tutorial section):
There is no <c>(copyable)</c> before <em>class-type</em> because there are no postconditions;
There is no <c>(inherit)</c> because destructors cannot directly subcontract; 
There is no function template keyword and arguments because destructors cannot be template functions;
There is no <c>(static)</c> because destructors cannot be static;
There is no <c>(<em>result-type</em>)</c> because destructors have no return value; 
The <em>function-name</em> must be the <em>class-name</em> as always for destructors;
The function argument list must be <c>(void)</c> because destructors take no argument;
There is no trailing <c>(const)</c> because constructor cannot be constant members.

@See @c CONTRACT_ASSERT(), @c CONTRACT_INVARIANT(), @c CONTRACT_CONSTRUCTOR(), @c CONTRACT_FUNCTION()
*/
#define CONTRACT_DESTRUCTOR(sequence)










/**
Macro used to write contracts for functions (non-static members, static members, and non-members but not for constructors and destructors).

This macro must be used right after the member function declaration.
There is no need for a trailing <c>";"</c> after the macro closing parenthesis <c>")"</c>.

For example (see the Tutorial section for more information):
@code
    template<typename T>
    class myvector {
        ... // Invariants.
        
    public:
        void push_back(const T& element) // Function declaration.
        CONTRACT_FUNCTION( (class) (copyable)(myvector)
                (public) (void) (push_back)( (const T&)(element) )
        (precondition) ({
            ... // Assert function preconditions.
        })
        (postcondition) ({
            ... // Assert function postconditions.
        })
        (body) ({
            ... // Actual function implementation.
        }) ) // No need for ";" after macro closing parenthesis ")".

        ... // Rest of the class.
    };
@endcode

@Params
@Param{sequence,
    A Boost.Preprocessor sequence of tokens <c>(<em>1st-token</em>)(<em>2nd-token</em>)<em>...</em>(<em>last-token</em>)</c> that repeats the function signature syntactic elements and specifies the contract.
    - The signature tokens are needed by the library to generate the contract code with the function name\, the argument types and names\, etc as explained in the the Without the Macros section (e.g.\, the argument names are needed to actually name the arguments for the precondition and postcondition functions).
    - The extra parenthesis <c>()</c> around the tokens are mandatory (they are the ones making the preprocessor sequence).
    - It is recommended to use @c CONTRACT_ASSERT() to assert preconditions and postconditions within the relative code blocks.
    - Within the postcondition code block\, <c>CONTRACT_OLDOF(this)</c> is a constant pointer to the object old value (as it was before body execution) but only if <em>class-type</em> was tagged <c>(copyable)</c> in @c sequence.
    Similarly\, <c>CONTRACT_OLDOF(</c><em>argument-name</em><c>)</c> is a constant reference to the related old argument value (as is was before body execution) but only if the <em>argument-type</em> was tagged <c>(copyable)</c> in @c sequence.
    - Within the postcondition code block\, <em>result-name</em> (with the actual name specified in @c sequence) is a constant reference to the value being returned but only when <em>result-type</em> is specified different from @c void in @c sequence.
    - For the body block\, <c>";"</c> can be used to separate the constructor definition from its declaration (see @c CONTRACT_CONSTRUCTOR_BODY()). Also\, <c>"= 0;"</c> can be specified when writing contracts for pure virtual member functions.
    - As explained in the Tutorial section\, the tokens in @c sequence appear in the exact same order as they appear in the member function declaration followed by the optional preconditions\, optional postconditions\, and mandatory body.
    - The function @c sequence syntax is as follows (<em>[]</em> for optional tokens\, <em>{}</em> tokens resulting from parenthesis contents evaluation\, <em>||</em> one token or the other\, <em>*</em> tokens repeated 0 or more times\, <em>+</em> tokens repeated 1 or more times\, <em>{}::</em> tokens specified only for member functions\, <em>{}?</em> tokens specified only for non-void functions):

<c>
<em>{[</em>(template)<em>]</em> <em>[</em>(copyable)<em>]</em>(<em>class-type</em>) <em>{</em>(inherit)(<em>base-class-type</em>)<em>}*</em>
<em>{</em>(public) <em>||</em> (protected) <em>||</em> (private)<em>}}::</em>
<em>[</em>(template)( <em>{</em>(<em>function-template-parameter-type</em>)(<em>function-template-parameter-name</em>)<em>}+</em> )<em>]</em>
<em>[{</em>(static) <em>||</em> (virtual)<em>}]</em>
(<em>result-type</em>) (<em>function-name</em>)( <em>{</em>(void) <em>||</em> <em>{[</em>(copyable)<em>]</em>(<em>argument-type</em>)(<em>argument-name</em>)<em>}+}</em> ) <em>[</em>(const)<em>]</em>
<em>[</em>(precondition) ({ ... })<em>]</em>
<em>[</em>(postcondition) {(<em>result-name</em>)}? ({ ... })<em>]</em>
(body) ({ ... })
</c>
}
@EndParams

@Returns
See Without the Macro section for examples of the code generated by this macro expansion.
@li If contract compilation is turned on, this macro expands to the function contract (see the Without the Macros section).
@li Otherwise, if contract compilation is turned off, this macro expands to just the function body using @c body_code_block (and no contract overhead is added).

The usual C++ restrictions on the function signature apply.
For example, static member functions cannot be @c virtual or @c const, plus they cannot subcontract so <c>(inherit)</c> cannot be specified.
The library will generate compile-time errors if @c sequence violates these constraints.

For @b operators, the operator name must also be spelled out in words and passed as <c>(operator(<em>symbol, word</em>))</c> (this is because operator names usually contain symbols, like <c>"[]"</c>, that are not valid preprocessor token so they cannot be used by this library).
The spelled out operator name is arbitrary but it cannot contain operator special symbols (see the Tutorial for more information).
For example, for <c>operator[]</c> the function name passed to @c sequence could be <c>(operator([], at))</c>.

@b Overloaded functions, with same number of arguments and constant qualifier, must have different argument names (and not just different argument types).
This is necessary otherwise this library will not be able to distinguish the contract of the overloaded functions from each other and it will generate a compile-time error.
(C++ uses the argument types and not their names to distinguish overloaded functions from each other but this library cannot use the argument types because, in general, they are not valid preprocessor tokens -- see the Tutorial for more information on this topic.)

@Note For functions with no argument <c>(<em>function-name</em>)( (void) )</c>, and not just <c>(<em>function-name</em>)( )</c>, must be used to specify the empty argument list within @c sequence.
This is because ISO standard C++ does not allow for empty macro parameters (this library also supports <c>(<em>function-name</em>)( )</c> but this will only compile on C99 so its use is not recommended -- see the Tutorial section for more information).

@Warning While there is only a limited amount of compile-time error checking that the library can do on @c sequence, the current library implementation does not uses the best possible error detection and reporting mechanism for missuses of the @c sequence syntax.
In some cases, and depending on the compiler used, an error in programming @c sequence might result in cryptic compiler errors (involving library internal templates and preprocessor macros, Boost.Preprocessor internal macros <c>BOOST_PP_...</c>, and only referring to the contract macro first line number).
The best way to resolve these errors is usually to inspect the @c sequence by eye instead of trying to make sense of the compiler error messages.
Also, try first to compile with contracts turned off so to make sure that the errors are actually in the contract code.
Rarely, it might be useful to look at the code generated by the contract macro expansion after preprocessing using your compiler related options ("-E -P" on GCC, "\EP" on Microsoft Visual C++, etc).

@See @c CONTRACT_ASSERT(), @c CONTRACT_INVARIANT(), @c CONTRACT_CONSTRUCTOR(), @c CONTRACT_DESTRUCTOR()
*/
#define CONTRACT_FUNCTION(sequence)

