
[/ Copyright (C) 2008-2012 Lorenzo Caminiti ]
[/ Distributed under the Boost Software License, Version 1.0 ]
[/ (see accompanying file LICENSE_1_0.txt or a copy at ]
[/ http://www.boost.org/LICENSE_1_0.txt) ]
[/ Home at http://sourceforge.net/projects/contractpp ]

[def __typedef_declaration__ [link typedef_declaration_anchor [^['typedef-declaration]]]]
[def __using_alias__ [link using_alias_anchor [^['using-alias]]]]
[def __using_declaration__ [link using_declaration_anchor [^['using-declaration]]]]
[def __static_select_assertion__ [link static_select_assertion_anchor [^['static-select-assertion]]]]
[def __alias__ [link alias_anchor [^['alias]]]]
[def __auto_type__ [link auto_type [^['auto-type]]]]
[def __assertion__ [link assertion_anchor [^['assertion]]]]
[def __assertion_condition__ [link assertion_condition_anchor [^['assertion-condition]]]]
[def __assertion_expression__ [link assertion_expression_anchor [^['assertion-expression]]]]
[def __assertions__ [link assertions_anchor [^['assertions]]]]
[def __base_classes__ [link base_classes_anchor [^['base-classes]]]]
[def __boolean_condition__ [link boolean_condition_anchor [^['boolean-condition]]]]
[def __class_declaration__ [link class_declaration_anchor [^['class-declaration]]]]
[def __class_invariant__ [link class_invariant_anchor [^['class-invariant]]]]
[def __class_invariants__ [link class_invariants_anchor [^['class-invariants]]]]
[def __concepts__ [link concepts_anchor [^['concepts]]]]
[def __exception_specs__ [link exception_specs_anchor [^['exception-specs]]]]
[def __function_parameter__ [link function_parameter_anchor [^['function-paramter]]]]
[def __classifiers__ [link classifiers_anchor [^['classifiers]]]]
[def __cv_qualifiers__ [link cv_qualifiers_anchor [^['cv-qualifiers]]]]
[def __ref_qualifiers__ [link ref_qualifiers_anchor [^['ref-qualifiers]]]]
[def __virt_specifiers__ [link virt_specifiers_anchor [^['virt-specifiers]]]]
[def __function_declaration__ [link function_declaration_anchor [^['function-declaration]]]]
[def __function_name__ [link function_name_anchor [^['function-name]]]]
[def __function_parameters__ [link function_parameters_anchor [^['function-parameters]]]]
[def __fundamental_type__ [link fundamental_type_anchor [^['fundamental-type]]]]
[def __inscope_variables__ [link inscope_variables_anchor [^['inscope-variables]]]]
[def __loop_variant__ [link loop_variant_anchor [^['loop-variant]]]]
[def __member_initializers__ [link member_initializers_anchor [^['member-initializers]]]]
[def __named_function_parameter__ [link named_function_parameter_anchor [^['named-function-parameter]]]]
[def __named_function_parameters__ [link named_function_parameters_anchor [^['named-function-parameters]]]]
[def __named_parameter_declaration__ [link named_parameter_declaration_anchor [^['named-parameter-declaration]]]]
[def __named_template_parameter__ [link named_template_parameter_anchor [^['named-template-parameter]]]]
[def __named_template_parameters__ [link named_template_parameters_anchor [^['named-template-parameters]]]]
[def __named_template_template_parameter__ [link named_template_template_parameter_anchor [^['named-template-template-parameter]]]]
[def __named_type_template_parameter__ [link named_type_template_parameter_anchor [^['named-type-template-parameter]]]]
[def __named_value_template_parameter__ [link named_value_template_parameter_anchor [^['named-value-template-parameter]]]]
[def __oldof_declaration__ [link oldof_declaration_anchor [^['oldof-declaration]]]]
[def __operator_name__ [link operator_name_anchor [^['operator-name]]]]
[def __positional_function_parameter__ [link positional_function_parameter_anchor [^['positional-function-parameter]]]]
[def __positional_function_parameters__ [link positional_function_parameters_anchor [^['positional-function-parameters]]]]
[def __template_parameter__ [link template_parameter_anchor [^['positional-template-parameter]]]]
[def __type_template_parameter__ [link type_template_parameter_anchor [^['type-template-parameter]]]]
[def __value_template_parameter__ [link value_template_parameter_anchor [^['value-template-parameter]]]]
[def __template_template_parameter__ [link template_template_parameter_anchor [^['template-template-parameter]]]]
[def __oldof_assertions__ [link oldof_assertions_anchor [^['oldof-assertions]]]]
[def __return_type__ [link return_type_anchor [^['return-type]]]]
[def __cv_qualifier__ [link cv_qualifier_anchor [^['cv-qualifier]]]]
[def __select_assertion__ [link select_assertion_anchor [^['select-assertion]]]]
[def __template_parameters__ [link template_parameters_anchor [^['template-parameters]]]]
[def __template_specialization_arguments__ [link template_specialization_arguments_anchor [^['template-specialization-arguments]]]]
[def __type_keyword__ [link type_keyword_anchor [^['type-keyword]]]]
[def __type_qualifier__ [link type_qualifier_anchor [^['type-qualifier]]]]
[def __wrapped_type__ [link wrapped_type_anchor [^['wrapped-type]]]]

[def __capture_boolean_expression__ [link capture_boolean_expression_anchor [^[*capture-boolean-expression]]]]
[def __capture__ [link capture_anchor [^[*capture]]]]
[def __name__ [link name_anchor [^[*name]]]]
[def __new_name__ [link new_name_anchor [^[*new-name]]]]
[def __boolean_expression__ [link boolean_expression_anchor [^[*boolean-expression]]]]
[def __boolean_expression_of_inscope_variables__ [link boolean_expression_of_inscope_variables_anchor [^[*boolean-expression-of-inscope-variables]]]]
[def __boost_concept__ [link boost_concept_anchor [^[*boost-concept]]]]
[def __catch_declaration__ [link catch_declaration_anchor [^[*catch-declaration]]]]
[def __catch_instructions__ [link catch_instructions_anchor [^[*catch-instructions]]]]
[def __class_name__ [link class_name_anchor [^[*class-name]]]]
[def __class_type__ [link class_type_anchor [^[*class-type]]]]
[def __constant_boolean_expression__ [link constant_boolean_expression_anchor [^[*constant-boolean-expression]]]]
[def __constant_string_literal__ [link constant_string_literal_anchor [^[*constant-string-literal]]]]
[def __exception_type__ [link exception_type_anchor [^[*exception-type]]]]
[def __function_identifier__ [link function_identifier_anchor [^[*function-identifier]]]]
[def __inscope_variable__ [link inscope_variable_anchor [^[*inscope-variable]]]]
[def __loop_declaration__ [link loop_declaration_anchor [^[*loop-declaration]]]]
[def __member_initializer__ [link member_initializer_anchor [^[*member-initializer]]]]
[def __named_argument_identifier_name__ [link named_argument_identifier_anchor [^[*named-argument-identifier]]]]
[def __named_parameter_identifier_namespace__ [link named_parameter_identifier_namespace_anchor [^[*named-parameter-identifier-namespace]]]]
[def __namespace_alias__ [link namespace_alias_anchor [^[*namespace-alias]]]]
[def __natural_expression__ [link natural_expression_anchor [^[*natural-expression]]]]
[def __natural_expression_using_inscope_variables__ [link natural_expression_using_inscope_variables_anchor [^[*natural-expression-using-inscope-variables]]]]
[def __new_type_name__ [link new_type_name_anchor [^[*new-type-name]]]]
[def __oldof_expression__ [link oldof_expression_anchor [^[*oldof-expression]]]]
[def __operator_identifier__ [link operator_identifier_anchor [^[*operator-identifier]]]]
[def __operator_symbol__ [link operator_symbol_anchor [^[*operator-symbol]]]]
[def __parameter_name__ [link parameter_name_anchor [^[*parameter-name]]]]
[def __default_argument__ [link default_argument_anchor [^[*default-argument]]]]
[def __cxx_template_parameter__ [link cxx_template_parameter_anchor [^[*c++-template-parameter]]]]
[def __template_specialization_argument__ [link template_specialization_argument_anchor [^[*template-specialization-argument]]]]
[def __type__ [link type_anchor [^[*type]]]]
[def __typedef_type__ [link typedef_type_anchor [^[*typedef-type]]]]
[def __unary_boolean_metafunction__ [link unary_boolean_metafunction_anchor [^[*unary-boolean-metafunction]]]]
[def __using_directive__ [link using_directive_anchor [^[*using-directive]]]]
[def __variable_name__ [link variable_name_anchor [^[*variable-name]]]]
[def __attributes__ [link attributes_anchor [^[*attributes]]]]

[section Grammar]

[:['["Almost every macro demonstrates a flaw in the programming language, in the program, or in the programmer.]]]
[:['-- Bjarne Stroustrup (see __Stroustrup97__ page 160)]]

This library uses macros to overcome a limitation of C++, namely the fact that the core language does not support preconditions, postconditions, class invariants, old values, and subcontracting.
This section lists the complete grammar of the syntax used by this library macros.

[#syntax_error_warning_anchor]
[warning
In general, an error in programming this library syntax will generate cryptic compiler errors (often exposing internal code from this library and from __Boost_Preprocessor__).
[footnote
Usually, the complexity of C++ definitions is greater than the complexity of C++ declaration and the fact that this library macros only affect declarations would help by preserving the usefulness of the compiler error messages for the definition code.
However, this library aims to make declarations more complex by adding program specifications to them (preconditions, postconditions, etc).
Therefore, it can no longer be argued that declarations are significantly simpler than definitions and it would be rather helpful to have sensible compiler error messages at least for the declarations with contracts.
]

There are intrinsic limitations on the amount of error checking that can be implemented by this library because it uses the preprocessor to parse its syntax (e.g., there is no way the preprocessor can gracefully detect and report unbalanced round parenthesis `( ... /* missing closing parenthesis here */` or an invalid concatenation symbol `BOOST_PP_CAT(xyz, ::std::vector)`).
In addition, for a given macro all compiler error messages report the same line number (because macros always expand on a single line) so line numbers are not very useful in identifying syntactic errors.

While the preprocessor imposes limits on the error checking that can be implemented, the current version of this library does not focus on providing the best possible syntax error messages (this will be the focus of future releases, see also [@https://sourceforge.net/apps/trac/contractpp/ticket/44 Ticket 44]).
]

The best way to resolve syntactic errors is for programmers to inspect the code ["by eye] instead of trying to make sense of the compiler errors.
This section is very useful for programmers to make sure that they are using the syntax correctly.

[section Preprocessor DSEL]

The syntax used by this library macros effectively defies a new language within C++.
More precisely, this library macros define a [@http://en.wikipedia.org/wiki/Domain-specific_language Domain-Specific Embedded Language (DSEL)] that replaces the usual C++ syntax for class and function declarations.
This is the ['Language of Contract++] (or ['LC++] for short).

In contrast with other DSEL hosted by C++ which are parsed using template meta-programming (e.g., __Boost_Phoenix__), this library DSEL is parsed ["one meta-programming level higher] using preprocessor meta-programming.
Using both processor meta-programming and template meta-programming allows this library to implement rules like this:

    ``/if a member function is not public then it does not check the class invariants/``

This rule cannot be implemented using only template meta-programming because it is not possible to check if a function is public using template meta-programming introspection techniques.
For example, it is not possible to implement a boolean meta-function like the following:
[footnote
Using __CXX11__, it /might/ be possible to implement the `is_public` template because __SFINAE__ was extended to support access level (but to the authors' knowledge such a meta-function has not been implemented yet so the authors cannot be sure that `is_public` can be properly implemented even using __CXX11__ __SFINAE__).
Even if that were possible in __CXX11__, this library still needs declaration traits other than `public` in oder to properly implement Contract Programming (e.g., if a function is `virtual` or not in order to implement subcontracting, and there are examples like that).
Therefore, the arguments made here for the need to use a preprocessor DSEL in oder to properly implement Contract Programming in C++ hold even if `is_public` could be implemented in __CXX11__.
]

    template< ... >
    struct is_public { ... }; // Unfortunately, this cannot be implemented.

Instead a macro can be programmed to parse the following function declarations and expand to `1` if and only if the function is public:

    #define IS_PUBLIC(function_declaration) ... // This can be implemented.

    IS_PUBLIC( public  void (f) ( int x ) )     // Expand to 1.
    IS_PUBLIC( private void (g) ( int y ) )     // Expand to 0.
    IS_PUBLIC(         void (h) ( int z ) )     // Expand to 0.

There are more examples of class and function declaration traits (`virtual`, etc) that need to be known to correctly implement Contract Programming but that cannot be inspected using template meta-programming.
This library macros can instead parse the specified class and function declarations extracting /any/ declaration trait (if a constructor is `explicit`, if a member function is `virtual`, if a base class is `protected`, if a parameter has a default value, etc).

It should be noted that while the syntax of the DSEL defined by this library macros is rather extensive and complex, macros always define a DSEL that is intrinsically different from the core C++ language.
For example, consider the following function-like macro:

    #define F(x, y) (int(x) - int(y))

    template< typename X, typename Y >
    int f ( X const& x, Y const& y ) { return (int(x) - int(y)); }

    int main ( void )
    {
        std::cout << F( , 2) << std::endl; // OK, no syntax error, it prints `-2`.
        std::cout << f( , 2) << std::endl; // Compiler generates a syntax error.
        return 0;
    }

Note how it is valid to invoke the macro with an empty parameter `F( , 2)` while it is syntactically invalid to invoke a function with an empty parameter `f( , 2)`.
This very simple macro already shows fundamental differences between the syntax of macros and the syntax of the core language.

[endsect]

[section Differences with C++ Syntax]

The following is a summary of all the differences between the syntax of this library macros and the usual C++ class and function declaration syntax.

[table
[ [#] [Syntactic Element] [Syntax Differences] ]
[ [1] [Template Declarations] [
Use round parenthesis `template( `[^['template-parameters]]` )` instead of angular parenthesis `template< `[^['template-parameters]]` >` to declare templates (note that template instantiations are not template declarations and they use angular parenthesis as usual).
] ]
[ [2] [Template Specializations] [
Use round parenthesis [^['template-name]]`( `[^['template-specialization-arguments]]` )` instead of angular parenthesis [^['template-name]]`< `[^['template-specialization-arguements]]` >` after a class template name to specify the arguments of the template specialization.
] ]
[ [3] [Class and Function Names, and Operators] [
Wrap class and function declaration names within round parenthesis `(`[^['class-name]]`)` and `(`[^['function-name]]`)`.
Use `operator(`[^['symbol]]`)(`[^['arbitrary-name]]`)` for operators (allowed but not required for `operator new`, `operator delete`, and implicit type conversion operators for fundamental types with no symbol).
Always use `operator comma` for comma operator.
Memory member operators must always be explicitly declared `static`.
] ]
[ [4] [Base Classes] [
Use `extends( `[^['base-classes]]` )` instead of the column symbol `: `[^['base-classes]] to inherit from base classes.
] ]
[ [5] [Default Arguments] [
Use `default `[^['default-argument]] instead of the assignment symbol `= `[^['default-argument]] to specify default arguments for template and function parameters.
] ]
[ [6] [Result and Parameter Types] [
Wrap function result and parameter types within round parenthesis `(`[^['type]]`)`.
The wrapping parenthesis are allowed but not required for fundamental types containing only alphanumeric tokens (e.g., `(const unsigned int)` and `const unsigned int` are both allowed and equivalent, but only `(int&)` and not `int&` is allowed because of the non-alphanumeric symbol `&`, furthermore only `(mytype)` is allowed because `mytype` is not a fundamental type).
] ]
[ [7] [Member Initializers] [
Use `initialize( `[^['member-initializers]]` )` instead of the column symbol `: `[^['member-initializers]] to specify a constructor's member initializers.
] ]
[ [8] [Commas and Leading Symbols] [
Syntactic elements containing commas and leading non-alphanumeric symbols must be wrapped within extra round parenthesis `(...)` (e.g., `'a'`, `"abc"`, and `1.23` are non-alphanumeric because of `'`, `"`, `.` respectively so they need to be wrapped as `('a')`, `("abc")`, and `(1.23)` if used within this library syntax as default parameters, etc.).
] ]
]

[important
In general, every token which is not a known keyword (e.g., `int` is a known keyword but the function name is not) or that contains a non-alphanumeric symbol (e.g., `int&`) must be wrapped within round parenthesis `(...)` unless it is the very last token of a syntactic element (e.g., the function parameter name).
]

[endsect]

[section Macro Interface]

This library uses the following macros.

    // Class declarations.
    
    ``[macroref BOOST_CONTRACT_CLASS]``(__class_declaration__)
    ``[macroref BOOST_CONTRACT_CLASS_TPL]``(__class_declaration__)
    
    // Class invariants.

    ``[macroref BOOST_CONTRACT_INVARIANT]``(__assertions__)
    ``[macroref BOOST_CONTRACT_INVARIANT_TPL]``(__assertions__)

    ``[macroref BOOST_CONTRACT_STATIC_INVARIANT]``(__assertions__)
    ``[macroref BOOST_CONTRACT_STATIC_INVARIANT_TPL]``(__assertions__)
    
    ``[macroref BOOST_CONTRACT_INVARIANT_VOLATILE]``(__assertions__)
    ``[macroref BOOST_CONTRACT_INVARIANT_VOLATILE_TPL]``(__assertions__)

    // Constructor declarations.

    ``[macroref BOOST_CONTRACT_CONSTRUCTOR]``(__function_declaration__)
    ``[macroref BOOST_CONTRACT_CONSTRUCTOR_TPL]``(__function_declaration__)
    ``[macroref BOOST_CONTRACT_CONSTRUCTOR_BODY]``(__class_type__, __class_name__)
    
    // Destructor declarations.

    ``[macroref BOOST_CONTRACT_DESTRUCTOR]``(__function_declaration__)
    ``[macroref BOOST_CONTRACT_DESTRUCTOR_TPL]``(__function_declaration__)
    ``[macroref BOOST_CONTRACT_DESTRUCTOR_BODY]``(__class_type__, ~__class_name__)
    
    // Member function (and member operator) declarations.

    ``[macroref BOOST_CONTRACT_MEMBER]``(__function_declaration__)
    ``[macroref BOOST_CONTRACT_MEMBER_TPL]``(__function_declaration__)
    ``[macroref BOOST_CONTRACT_MEMBER_BODY]``(__function_name__)
    
    // Free function (and free operator) declarations.

    ``[macroref BOOST_CONTRACT_FUNCTION]``(__function_declaration__)
    ``[macroref BOOST_CONTRACT_FUNCTION_TPL]``(__function_declaration__)
    ``[macroref BOOST_CONTRACT_FUNCTION_BODY]``(__function_name__)

The macros with the trailing `_TPL` must be used when the enclosing scope is type-dependent (e.g., within templates).

[endsect]

[section Lexical Conventions]

The following conventions are used to express this grammar.

[table
[ [Lexical Expression] [Meaning] [Text] ]
[ [[^symbol[':]]] [
The specified symbol is defined by the symbols following the semicolon `:` (symbol definition). ][
Semicolon in italic font.
] ]
[ [[^['[]symbols['\]]]] [
Either `symbols` or nothing (optional symbols). ] [
Angular brackets in italic font.
] ]
[ [[^['{]expression['}]]] [
The result of the enclosed expression `expression` (evaluation order). ] [
Curly brackets in italic font.
] ]
[ [[^symbol1 ['|] symbol2]] [
Either `symbol1` or `symbol2` (["or] operation). ] [
Vertical bar in italic font.
] ]
[ [[^symbol['*]]] [
`symbol` repeated zero or more times (repetition starting from zero). ] [
Asterisk in italic font.
] ]
[ [[^symbol['+]]] [
`symbol` repeated one or more times (repetition starting from one). ] [
Plus in italic front.
] ]
[ [[^symbol[', ...]]] [
A comma separated list of symbols that could also contain a single symbol (e.g., `symbol1` or `symbol1, symbol2` or `symbol1, symbol2, symbol3`). ] [
Comma and three dots in italic font.
] ]
[ [[^[*symbol]]] [
Terminal symbol (defined outside this grammar). ] [
Dash separated words in bold font.
] ]
[ [[^['symbols]]] [
Non-terminal symbol (defined within this grammar). ] [
Dash separated words in italic font.
] ]
]

[endsect]

[section Class Declarations]

    __class_declaration__``/:/ [#class_declaration_anchor]``
            ``/[/````/[/``export``/]/`` template( ``/[/``__template_parameters__``/]/`` )``/]/``
            ``/[/``friend``/]/`` ``/{/``class ``/|/`` struct``/}/`` ``/[/``verbatim(__attributes__)``/]/`` (__class_name__)``/[/``( __template_specialization_arguments__ )``/]/``
            ``/[/``final``/]/`` ``/[/``extends( __base_classes__ )``/]/``

[endsect]

[section Template Parameters]

    __template_parameters__``/:/ [#template_parameters_anchor]``
            __template_parameter__``/, .../``
    
    __template_parameter__``/:/ [#template_parameter_anchor]``
            __type_template_parameter__ ``/|/``
            __value_template_parameter__ ``/|/``
            __template_template_parameter__

    __type_template_parameter__``/:/ [#type_template_parameter_anchor]``
            ``/{/``class ``/|/`` typename``/}/````/[/``...``/]/`` ``/[/``__parameter_name__``/]/``
            ``/[/``, default __default_argument__``/]/``
    
    __value_template_parameter__``/:/ [#value_template_parameter_anchor]``
            __wrapped_type__ ``/[/``__parameter_name__``/]/``
            ``/[/``, default __default_argument__``/]/``
    
    __template_template_parameter__``/:/ [#template_template_parameter_anchor]``
            template( ``/[/``__cxx_template_parameter__``/, .../````/]/`` ) class ``/[/``__parameter_name__``/]/``
            ``/[/``, default __default_argument__``/]/``

Note how this syntax allows to specify __CXX11__ variadic templates as usual using ellipses `...` after `typename` or `class` and before the type template parameter name (e.g., `typename... Args` or `class... Args`).

If present, default parameters must be specified at the end of the parameter list as usual in C++.

Note that if `typename` appears within __wrapped_type__ for a value template parameter then it will be wrapped within parenthesis (e.g., `(typename std::map<int, char>) Map`) so it is syntactically distinguishable from the `typename` leading a type template parameter.

[endsect]

[section Template Specializations]

    __template_specialization_arguments__``: [#template_specialization_arguments_anchor]``
            __template_specialization_argument__``/, .../``

[endsect]

[section Base Classes]

    __base_classes__``/:/ [#base_classes_anchor]``
            ``/[/``public ``/|/`` protected ``/|/`` private``/]/`` ``/[/``virtual``/]/`` __class_type__``/, .../``

Note that when specified, `virtual` must appear after the inheritance access level for a base class (as with usual C++ base class declarations).

[endsect]

[section Types]

    __wrapped_type__``/:/ [#wrapped_type_anchor]``
            (__type__``/[/``...``/]/``) ``/|/`` __fundamental_type__ ``/|/`` decltype(__expression__)

    __fundamental_type__``/:/ [#fundamental_type_anchor]``
            ``/{/``const ``/|/`` volatile ``/|/`` long ``/|/`` short ``/|/`` signed ``/|/`` unsigned ``/|/`` 
            void ``/|/`` bool ``/|/`` char ``/|/`` char16_t ``/|/`` char32_t ``/|/`` double ``/|/`` float ``/|/`` int ``/|/`` wchar_t``/}+/``
            
    __auto_type__``/:/ [#auto_type_anchor]``
            __wrapped_type__ ``/|/`` auto

This is the syntax used to specify types of different entities such as the function return type, the function parameter types, the types of value template parameters, etc.
The usual constraints of C++ for qualified fundamental type apply (it invalid to specify `int int`, `long int long`, `unsigned void`, etc).

As indicated by the syntax above, extra parenthesis around the specified type are always allowed but they are required only for user-defined types `(mytype)` and types containing non-alphanumeric symbols `(int&)`, `(std::size_t)`, `(int&&)`, etc.
However, the parenthesis are optional for fundamental types containing no symbol (e.g., `unsigned long int const` and `(unsigned long int const)` can be equivalently used) and `decltype` (e.g., `decltype(x)` and `(decltype(x))` can be equivalently used).

Note that the type wrapped within parenthesis can contain trailing ellipses in case it is the type specified for a variadic template (e.g., `(Args...)`).

[endsect]

[section Function Declarations]

    __function_declaration__``/:/ [#function_declaration_anchor]``
            ``/[/``verbatim(__attributes__)``/]/``
            ``/[/````/[/``export``/]/`` ``/[/``template( ``/[/``__template_parameters__``/]/`` )``/]/``
            __classifiers__ ``/[/``__return_type__``/]/`` __function_name__ ( __function_parameters__ )
            __cv_qualifiers__ __ref_qualifiers__ __exception_specs__
            ``/[/``return __wrapped_type__``/]/`` __virt_specifiers__
            ``/[/``precondition( __assertions__ )``/]/``
            ``/[/``postcondition( __oldof_assertions__ )``/]/``
            
This is the syntax used to declare all functions: Free functions, member functions, constructors, destructors, and operators.
The usual constraints of C++ function declarations apply (it is not possible to declare a static virtual member function, only constructors can use the class name as the function name, constructors and destructors have no result type, etc).

[endsect]

[section Classifiers (`static`, `virtual`, etc.)]

    __classifiers__``/:/ [#classifiers_anchor]``
            ``/[/``explicit``/]/`` ``/[/``inline``/]/`` ``/[/``extern``/]/`` ``/[/``static``/]/`` ``/[/``virtual``/]/`` ``/[/``friend``/]/``

The `static` specifier can only be used for member functions (because it was deprecated for free functions from C to __CXX03__).

[note
C++ automatically promotes the memory member operators `operator new`, `operator delete`, `operator new[]`, and `operator delete[]` to be static members so the `static` specifier is allowed but optional for declarations of these member operators.
This library cannot automatically perform such a promotion so the `static` specifier is always required by this library for declarations of memory member operators.
]

[endsect]

[section Return Type]

    __return_type__``/:/ [#return_type_anchor]``
            __auto_type__

As always with this syntax's wrapped types, note that fundamental types containing no symbol can be specified without extra parenthesis (`void`, `bool`, `int`, `unsigned long const`, `decltype(...)`, etc.).

__CXX11__ trailing return types can be specified using `auto` for the return type and then using `return __wrapped_type__` after the function parameters (instead of the usual `->` syntax).
Contrary to when `return` is used to specify a return value within a function definition, in this case `return` is followed by a type expression (and not by a value expression) as it is specifying the return type (and not the return value).
On compilers that support __CXX14__ automatic return type deduction, the trailing return type `return __wrapped_type__` is optional when the return type is `auto`. 

[endsect]
            
[section Function and Operator Names]

    __function_name__``/:/ [#function_name_anchor]``
            (__function_identifier__) ``/|/`` (__class_name__) ``/|/`` (~__class_name__) ``/|/`` __operator_name__
    
    __operator_name__``/:/ [#operator_name_anchor]``
            operator(__operator_symbol__)(__operator_identifier__) ``/|/`` operator __fundamental_type__ ``/|/``
            operator new ``/|/`` operator delete

Names for free functions, member functions, constructors, and destructors are specified as usual but wrapped within parenthesis.

Operator names are specified wrapping within parenthesis the usual operator symbol followed by an arbitrary but alphanumeric identifier, for example:

    operator(+)(plus)
    operator("")(literal)

    operator(())(call)
    operator(,)(comma)
    
    operator(new[])(new_array)
    operator(delete[])(delete_array)

Names for implicit type conversion operators use the same syntax, for example:

    operator(int*)(int_ptr)
    operator(mytype const&)(mytype_const_ref)
    operator(std::map<char, int>)(std_map)

However, if the type is a fundamental type containing no symbol, the parenthesis and alphanumeric identifier are optional, for example:

    operator const int              // OK.
    operator(const int)(const_int)  // Also allowed (but less readable).

Similarly, the parenthesis and alphanumeric identifier are optional for the `new` and `delete` operators:

    operator new                    // OK.
    operator(new)(new_ptr)          // Also allowed (but less readable).

    operator delete                 // OK.
    operator(delete)(delete_ptr)    // Also allowed (but less readable).

[endsect]
    
[section Function Parameters]

    __function_parameters__``/:/ [#function_parameters_anchor]``
            ``/[/``__function_parameter__``/, .../````/]/`` ``/[/``...``/]/`` ``/|/`` void
    
    __function_parameter__``/:/ [#function_parameter_anchor]``
            ``/[/``auto ``/|/`` register``/]/`` __wrapped_type__ ``/[/``__parameter_name__``/]/``
            ``/[/``, default __default_argument__``/]/``


This syntax allows to specify variadic functions as usual in C++ using ellipses `...` at the end of the parameter list.

The storage classifier `auto` is supported by this library but it is deprecated in __CXX11__ (so use it with the usual care when writing code portable to __CXX11__).

If present, default parameters must be specified at the end of the parameter list as usual in C++.

[endsect]
    
[section Constant/Volatile Qualifiers]

    __cv_qualifiers__``/:/ [#cv_qualifiers_anchor]``
            ``/[/``const ``/|/`` volatile ``/|/`` const volatile ``/|/`` volatile const``/]/``

[endsect]

[section Reference Qualifiers]

    __ref_qualifiers__``/:/ [#ref_qualifiers_anchor]``
            ``/[/``ref ``/|/ ``refref``/]/``

Member functions are qualified as lvalue references using `ref` (instead of C++11 usual `&`) and as rvalue references using `refref` (instead of C++11 usual `&&`).

[endsect]

[section Exception Specifications]

    __exception_specs__``/:/ [#exception_specs_anchor]``
            ``/[/``noexcept``/[/``(__constant_boolean_expression__)``/]/`` ``/|/`` throw( ``/[/``__exception_type__``/, .../````/]/`` )``/]/``

Exception specifications apply only to exceptions thrown by the function body and not to exceptions thrown by the contracts themselves (if any) and by the contract checking code generated by this library's macros.

[endsect]

[section Virtual Specifiers]

    __virt_specifiers__``/:/ [#virt_specifiers_anchor]``
            ``/[/``final ``/|/`` override ``/|/`` final override ``/|/`` override``/]/``

[endsect]

[section Assertions]

    __assertions__``/:/``
            ``/[/``__assertion__, ... ``/[/``,``/]/````/]/``

Note that an extra trailing comma `,` is always allowed here but never required (similarly to C++ trailing comma that can be used to end an enumeration declaration list).

    __assertion__``/:/``
            __alias__ ``/|/``
            
            __auto_type__ __new_name__ = return ``/|/``
            __auto_type__ __new_name__ = ``[macroref CONTRACT_OLDOF]`` __oldof_expression__ ``/|/``
            
            __boolean_condition__ ``/|/``

            __select_assertion__ ``/|/``
            __static_select_assertion__

Where return and old-of declarations are allowed only within postconditions.

    __boolean_condition__``/:/``
            __boolean_expression__ ``/|/``
            const( ``/[/``__capture__, ...``/]/`` ) __capture_boolean_expression__

Parenthesis around __boolean_expression__ are always allowed here but they are actually required only when __boolean_expression__ starts with a non-alphanumeric symbol (e.g., `(!vector.empty())`) or it contains unwrapped commas `,`.
Parenthesis around __capture_boolean_expression__ are always allowed but they are actually required only when __capture_boolean_expression__ contains unwrapped commas `,`.

    __select_assertion__``/:/``
            if(__boolean_condition__) ( ``/[/``__assertion__, ...``/]/`` )
            ``/[/``else ( ``/[/``__assertion__, ...``/]/`` )
    
    __static_select_assertion__``/:/``
            static if(__constant_boolean_expression__) ( ``/[/``__assertion__, ...``/]/`` )
            ``/[/``else ( ``/[/``__assertion__, ...``/]/`` )

For example, static select assertions can be used in generic programming to selectively check some assertions only when the types involved fulfill all operations required for the assertion checking.

[endsect]

[section Aliases]
    
    __alias__``/:/ [#alias_anchor]``
            __namespace_alias__ ``/|/`` __using_directive__ ``/|/`` __using_declaration__ ``/|/`` __using_alias__ ``/|/`` __typedef_declaration__

    __namespace_alias__``/:/``
            namespace (__new_name__) as __name__

    __using_directive__``/:/``
            using namespace __name__
    
    __using_declaration__``/:/``
            using {``/[/``typename``/]/`` __name__ ``/|/`` (``/[/``typename``/]/`` __name__)}

    __using_alias__``/:/``
            ``/[/``template( ``/[/``__cxx_template_parameter__, ...``/]/`` )``/]/``
            using (__new_name__) as {__type__ | (__type__)}

    __typedef_declaration__``/:/``
            typedef __wrapped_type__ __new_name__

In __using_declaration__, parenthesis around __name__ are always allowed here but they are actually required only when __name__ contains unwrapped commas `,`.
As usual in C++, __name__ can be prefixed by `typename` if that it is needed to resolve dependent names.

In __using_alias__, parenthesis around __type__ are always allowed here but they are actually required only when __type__ contains unwrapped commas `,`.

For example, all the aliases above can be used to simplify and short types and names used to program assertions (aliases do not alter the run-time state of the program so they can be safely used to program assertions).

[endsect]


[section Preconditions]

    __assertions__``/:/ [#assertions_anchor]``
            ``/[/``__aliasing__``/, .../````/]/``
            __assertion__``/, .../``

    __aliasing__``/:/``
            using ``/[/``namespace``/]/`` __used_identifier__ ``/|/``
            namespace __original_namespace__ = __new_namespace__ ``/|/``
            typedef __original_type__ __new_type__ ``/|/``
            template< ``/[/``__cxx_template_parameter__``/, .../````/]/`` > using __template_alias__ = __new_type__

    __assertion__``/:/``
            __boolean_condition__ ``/|/``
            __select_assertion__ ``/|/``
            __static_selection_assertion__

    __boolean_condition__``/:/``
            __boolean_expression__ ``/|/``
            const( __inscope_variable__``/, .../`` ) __boolean_expression_of_inscope_variables__

    __select_assertion__``/:/``
            if(__boolean_condition__) ( __assertion__``/, .../`` )
            ``/[/``else ( __assertion__``/, .../`` )``/]/``

    __static_select_assertion__``/:/``
            static if(__constant_boolean_expression__) ( __assertion__``/, .../`` )
            ``/[/``else ( __assertion__``/, .../`` )``/]/``

Some basic aliases are allowed at the local scope where the assertions are being declared in case they are ever needed to simplify the names used in the assertions.
Specifically, using directives, namespace aliases, typedefs, and template aliases are allowed (these will always affect all assertions within the given preconditions, postconditions, etc so it is recommended to always use these statement at the very beginning before the actual assertion conditions).
Note that these aliases have no effect on the program run-time state and therefore they do not compromise the contract constant-correctness requirement.

As indicated by the grammar above, it is not possible to specify assertion requirements (using `requires`) for the entire select assertion if-then-else expression.
Eventual assertion requirements must be specified for the single assertions within the select assertion if-then-else statement and they will never disable compilation and checking of the select assertion if-condition.
Programmers can use the ternary operator `?:` instead of a select assertion if they need to specify a guarded assertion with a condition that is also disabled by the assertion requirements:

    ``/boolean-guard/`` ? __boolean_expression__ : true, requires __constant_boolean_expression__

Constant expressions `const( ... ) `[^['expression]] can be used to assert conditions and to check the select assertion if-condition so to fully enforce the assertion constant-correctness requirement.
However, function arguments, result value, old-of values, and the object `this` are automatically made constant by this library so constant expressions only need to be used to assert conditions on global variables, static variables, etc.
The type of the in-scope variable __inscope_variable__ is optional and it is automatically deduced using __Boost_Typeof__ when it is not specified.

[endsect]

[section Postconditions] 

If present, result and old value declarations should appear before any assertion because they will always be visible to all assertions, plus these declarations cannot be nested (within select-assertions, etc).

The macro [macroref CONTRACT_OLDOF] allows but does not require parenthesis around the value expression __oldof_expression__, for example the following are both valid:
[footnote
*Rationale*.
This is as specified for the `oldof` operator in __N1962__ and similar to the `sizeof` operator which requires parenthesis when applied to a type expression `sizeof(size_type)` but not when applied to a value expression `sizeof size()`.
]

    auto old_size = CONTRACT_OLDOF size()   // OK.
    auto old_size = CONTRACT_OLDOF(size())  // Also allowed (but less readable).

If the macro [macroref CONTRACT_OLDOF] is applied to the value of a type that is not __ConstantCopyConstructible__, the related old value declaration will not fail but it will produce an old value that will cause a compiler-error as soon as it is used in an assertion (unless the assertion is guarded by a `static if` using the properly specialized [classref contract::has_oldof] trait).

[endsect]

[section Class Invariants]

    __class_invariants__``/:/ [#class_invariants_anchor]``
            ``/[/``__aliasing__``/, .../````/]/``
            __assertion__

Volatile class invariants are assumed to have the same assertions as non-volatile class invariants unless they are explicitly specified.
Static class invariants are assumed to assert nothing unless they are explicitly specified.

[endsect]

[section Terminals]

[table
[
[Terminal]
[Description]
[If terminal contains unwrapped commas or leading symbols]
] [
[__boolean_expression__[#boolean_expression_anchor]]
[A boolean expression: `x == 1`.]
[Wrap value within parenthesis: `(vey_sizeof<Key, T>::value)`.]
] [
[__boolean_expression_of_inscope_variables__[#boolean_expression_of_inscope_variables_anchor]]
[A boolean expression that only uses in-scope variables captured as constants by a constant expression `const( ... ) `[^['expression]].]
[Wrap value within parenthesis: `(key_sizeof<Key, T>::value + x)`.]
] [
[__boost_concept__[#boost_concept_anchor]]
[A concept class defined using __Boost_ConceptCheck__: `boost::CopyConstructible`.]
[Wrap type within parenthesis: `(boost::Convertible<T, int>)`.]
] [
[__catch_declaration__[#catch_declaration_anchor]]
[The declaration of an exception for a `catch` statement: `std::runtime_error& error`.]
[Wrap type using __Boost_Utility_IdentityType__: `BOOST_IDENTITY_TYPE((map<char, int>::exception&)) error`.]
] [
[__catch_instructions__[#catch_instructions_anchor]]
[The instructions of a `catch` statement terminated by semicolons `;`: `std::cout << "error" << std::endl; exit(255);`.]
[Wrap types using __Boost_Utility_IdentityType__ and values within parenthesis: `typedef BOOST_UTILITY_TYPE(std::map<char, int>) mtype; (mtype m, m['a'] = 1);`.]
] [
[__class_name__[#class_name_anchor]]
[The class name: `myclass`. For class templates this must not include the template instantiation parameters: `vector`. (For non-template classes, the class type and name are the same.)]
[Never the case.]
] [
[__class_type__[#class_type_anchor]]
[The class type, for class templates this must include the template instantiation parameters: `vector<T>`.]
[Wrap type within parenthesis: `(map<Key, T>)`.]
] [
[__constant_boolean_expression__[#constant_boolean_expression_anchor]]
[A compile-time constant boolean expression: `sizeof(T) >= sizeof(int)`.]
[Wrap value within parenthesis: `(boost::is_convertible<T, int>::value)`.]
] [
[__constant_string_literal__[#constant_string_literal_anchor]]
[A compile-time constant string literal: `"abc"`.]
[Do nothing: `"abc"`.]
] [
[__exception_type__[#exception_type_anchor]]
[A type: `std::exception`, `int`, `mytype`.]
[Wrap type within parenthesis: `(map<char, int>::exception)`.]
] [
[__function_identifier__[#function_identifier_anchor]]
[A valid function name identifier (C++ requires it to be alphanumeric): `f`, `push_back`, `myfunc`.]
[Never the case.]
] [
[__inscope_variable__[#inscope_variable_anchor]]
[A variable in-scope.]
[Never the case.]
] [
[__loop_declaration__[#loop_declaration_anchor]]
[A loop declaration: `for(int i = 0; i < 10; ++i)`, `while(i < 10)`.]
[Never the case.]
] [
[__member_initializer__[#member_initializer_anchor]]
[A member initialization expression: `vector_(count)`.]
[Wrap object initializations within parenthesis: `(base_map<char, int>())`.]
] [
[__named_argument_identifier_name__[#named_argument_identifier_anchor]]
[The argument name to use at the calling site to pass named and deduced parameter values: `value_arg`, `NumberArg`.]
[Never the case.]
] [
[__named_parameter_identifier_namespace__[#named_parameter_identifier_namespace_anchor]]
[The internal namespace for named and deduced parameter identifiers: `params`.]
[Never the case.]
] [
[__namespace_alias__[#namespace_alias_anchor]]
[The argument to pass to namespace aliasing: `mpl = boost::mpl`.]
[Never the case.]
] [
[__natural_expression__[#natural_expression_anchor]]
[A natural (i.e., non-negative integral) expression: `2 - 1`.]
[Wrap value within parenthesis: `(key_sizeof<Key, T>::value)`.]
] [
[__natural_expression_using_inscope_variables__[#natural_expression_using_inscope_variables_anchor]]
[A natural (i.e., non-negative integral) expression that only uses in-scope variables captured as constant by a constant-expression: `x + 10`.]
[Wrap value within parenthesis: `(key_sizeof<Key, T>::value + x)`.]
] [
[__new_type_name__[#new_type_name_anchor]]
[A new type name for `typedef` statement: `myint`.]
[Never the case.]
] [
[__oldof_expression__[#oldof_expression_anchor]]
[A expression of type __ConstantCopyConstructible__ to pass to the [macroref CONTRACT_OLDOF] macro: `value`, `size()`.]
[Wrap value within parenthesis: `(x, y)`.]
] [
[__operator_identifier__[#operator_identifier_anchor]]
[An arbitrary but alphanumeric identifier: `equal`, `less`, `call`.]
[Never the case.]
] [
[__operator_symbol__[#operator_symbol_anchor]]
[The usual operator symbols: `==`, `<=`, `()`.]
[Do nothing: `std::map<char, int>`.]
] [
[__parameter_default__[#parameter_default_anchor]]
[A function or template parameter default value (either a value, a type, or a template depending on the kind of parameter): `123`.]
[Wrap value within parenthesis: `("abc")`, `('a')`, `(-123)`, `(1.23)`.]
] [
[__parameter_name__[#parameter_name_anchor]]
[A function or template parameter name: `value`, `T`.]
[Never the case.]
] [
[__cxx_template_parameter__[#cxx_template_parameter_anchor]]
[A usual C++ type template parameter, value template parameter, or template template parameter): `typename T`, `class U`, `int Number`, `T Value`, `template< typename X, class Y > class Template`.]
[Do nothing: `std::map<Key, T> Default`, `template< typename X, class Y > class Template`.]
] [
[__template_specialization_argument__[#template_specialization_argument_anchor]]
[A template specialization argument (type, value, etc) that follow the class name in the declaration to specialize a template: `void (int, T)`.]
[Wrap types within parenthesis: `(std::map<char, int>)`.]
] [
[__type__[#type_anchor]]
[A type: `int`, `int const&`, `mytype`.]
[Do nothing: `std::map<char, int>`.]
] [
[__typedef_type__[#typedef_type_anchor]]
[A type: `int`, `mytype`.]
[Wrap type using __Boost_Utility_IdentityType__: `BOOST_IDENTITY_TYPE((std::map<char, int>))`.]
] [
[__unary_boolean_metafunction__[#unary_boolean_metafunction_anchor]]
[A boolean meta-function that takes one parameter: `boost::is_class<boost::mpl::_>`.]
[Do nothing: `boost:is_convertible<boost::mpl::_, int>`.]
] [
[__using_directive__[#using_directive_anchor]]
[The argument to pass to a using directive: `namespace std`, `std::vector`.]
[Never the case.]
] [
[__variable_name__[#variable_name_anchor]]
[A valid name to use to declare a variable: `result`, `old_size`.]
[Never the case.]
] [
[__attributes__[#attributes_anchor]]
[Compiler-specific attributes like MSVC `__declspec(export)` and `__declspec(import)`, or G++ `__attribute__((visibility("default")))`, or C++11 `[[`[^['compiler-attribute]]`]]`.]
[Do nothing.]
]
]

If terminals contain commas not already wrapped by round parenthesis or if they start with a non-alphanumeric symbol (including tokens like `'a'`, `"abc"`, `-123`, and `1.23`),
[footnote
The C++ preprocessor cannot concatenate `1.23` because it contains the `.` symbol (even if that symbol is technically not the leading symbol).
The precise preprocessor requirement is that the concatenated symbol must be a valid macro identifier and concatenating `1.23` with any token will never give a valid macro identifier because of the presence of the dot symbol `.` (e.g., `BOOST_PP_CAT(XYZ, 1.23)` gives `XYZ1.23` which is not a valid macro identifier).
]
they need to be wrapped by extra round parenthesis `(...)` or by the __Boost_Utility_IdentityType__ `BOOST_IDENTITY_TYPE((...))` macro.
Value expressions can always be wrapped within extra around parenthesis in C++.
Type expressions can always be wrapped using __Boost_Utility_IdentityType__ but that will make the syntax less readable (and it prevents C++ from automatically deducing function template parameters) so this syntax allows to wrap type expressions within extra round parenthesis `(...)` for most terminals, including types, as indicated by the table above.

[endsect]

[section Alternative Assertion Syntax (Not Implemented)]

The following alternative syntax could have been implemented to program the contract assertions:

[table
[ [This Library Syntax] [Alternative Syntax (not implemented)] ]
[ [``
CONTRACT_CLASS(
    template( typename T )
    class (vector)
) {
public:
    CONTRACT_MEMBER_TPL(
        (iterator) (erase) ( (iterator) where )
            precondition(
                not empty(),
                where != end()
            )
            postcondition(
                auto result = return,
                auto old_size = CONTRACT_OLDOF size(),
                size() == old_size - 1,
                if(const( this ) this->empty()) (
                    result == end()
                )
            )
    ) ;
    
    ...
};
`` ] [``
CONTRACT_CLASS(
    template( typename T )
    class (vector)
) {
public:
    CONTRACT_MEMBER_TPL(
        (iterator) (erase) ( (iterator) where )
            precondition(
                assert(not empty())
                assert(where != end())
            )
            postcondition(
                const(auto result = return)
                const(auto old_size = CONTRACT_OLDOF size())
                assert(size() == old_size - 1)
                if(const(this, this->empty())) (
                    assert(result == end())
                )
            )
    ) ;

    ...
};
``] ]
]

An advantage of this alternative syntax is that it does not require commas `,` at the end of each assertion (but it still does not allow for semicolon `;` at the end of each assertion as usual C++ statement syntax would require).
However, when compared with this library syntax, the alternative syntax is overall more verbose, it uses more parenthesis, it deviates more from __N1962__ and __Eiffel__ because of its explicit use of `assert(...)` (even if that makes it more similar to __D__'s syntax).
Therefore, the authors opted for implementing the syntax on the left hand side.

[endsect]

[endsect]

