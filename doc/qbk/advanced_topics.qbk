
[section Advanced Topics]

This section explains advanced usages of this library.

[section Optional Return Value]

It is possible to use `boost::optional` to handle the return value when programmers cannot construct the result variable at its point of declaration before the contract (e.g., because an appropriate constructor for the return type is not available at that point, or just because it is too expensive to execute an extra initialization of the result value at run-time).
[footnote
*Rationale.*
`boost::optional` was used instead of `std::optional` because this library is designed to work well with Boost and because `std::optional` is not part of the C++ standard yet.
]
For example (see also [@../../example/features/optional_result.cpp =optional_result.cpp=]):

[import ../../example/features/optional_result.cpp]
[optional_result]

In this example the return type `surface` does not have a default constructor that can be used to initialize `result` when it is first declared.
`surface` non-default constructor cannot be used to initialize `result` by passing it `edge * edge` because such an operation is the responsibility of the body (in fact, it makes logical sense to do such multiplication only after `edge` has been checked to be positive by the preconditions).
Therefore, instead of initializing `result` with some useless `area` value, `boost::optional` was used in this example to not initialize `result` with a return value when it is declared before the contract.
`result` is instead initialized only later in the body when the function body is about to return and directly using the correct return value `surface(edge * edge)`.

When this technique is used, programmers have to make sure that each return statement in the function is of the following form:
    
    boost::optional<...> result;
    ...
    return *(result = ...);

This ensures that `result` is always set to the return value before the postconditions are checked.
Therefore, programmers can always dereference `result` in postconditions to access the return value (using `operator*` and `operator->` as usual with `boost::optional`, and without having to explicitly check if `result` is an empty `boost::optional` object).

Similarly, `boost::optional` can be used for return values passed to virtual and overriding functions (see also __Pure_Virtual_Functions__).

[endsect]

[section Old Values at Body]

TODO

[import ../../example/features/old.cpp]
[old]

[endsect]

[section Pure Virtual Public Functions]

In C++, pure virtual functions are allowed to have a /default implementation/ as long as such implementation is programmed out-of-line and defined outside the class declaring the pure virtual function as `virtual ... = 0;`.
Contracts for pure virtual public functions are programmed using the [funcref boost::contract::public_function] function very much like contracts for virtual public functions, so all consideration made in __Virtual_Public_Functions__ apply.
However, in this case contracts are always programmed out-of-line, in the default implementation of the pure virtual function.

For example, note how the following `shape::area` default implementation (which is used to program the contract) must be defined out-of-line and therefore outside the `shape` class declaration (see also [@../../example/features/pure_virtual.cpp =pure_virtual.cpp=]):

[import ../../example/features/pure_virtual.cpp]
[pure_virtual]

This library will never actually execute the pure virtual function body while it is calling the pure virtual function default implementation to check its contract for subcontracting.
Therefore, programmers can safely `assert(false)` at the beginning of the body if they intend for that body to never be executed (or they can program a working body in case they want to take full advantage of C++ pure virtual function default implementation outside of what strictly needed by this library).
Finally, in this example, the pure virtual function does not have enough information to meaningfully initialize the return value `result` (it is missing the actual shape dimensions like edges, radius, etc.) so `boost::optional` is used to declare the return value (see also __Optional_Return_Value__).

As already discussed in __Private_and_Protected_Functions__, private and protected member functions do not check class invariants and do not subcontract (not even when they are virtual or pure virtual).
Therefore, no contract is ever programmed for a private or protected pure virtual function (because that contract would never be checked during subcontracting anyway).

[endsect]

[section Static Public Functions]

Contracts for static public member functions are programmed using the [funcref boost::contract::public_function] function.
However, in this case [funcref boost::contract::public_function] takes the enclosing class type as an explicit template parameter instead of taking the object `this` as a function parameter (because there is no object `this` in static member functions):

    auto c = boost::contract::public_function<``[^['class-type]]``>()
        ... // Preconditions and postconditions.
    ;

For example (see also [@../../example/features/static.cpp =static.cpp=]):

[import ../../example/features/static.cpp]
[static]

Even if they are not present in this example, it is possible to specify both preconditions and postconditions for static public member functions (see also __Preconditions__ and __Postconditions__).
[funcref boost::contract::public_function] takes the class type as a template parameter because static public member functions check static class invariants (but it does not take the object `this` and obviously static public member functions do not check non-static class invariants, see also __Class_Invariants__).

[funcref boost::contract::public_function] returns an RAII object (that can be assigned to a local variable of explicit type [classref boost::contract::guard] when programmers are not using C++11 auto declarations).
The static public member function body is programmed right after the declaration of this RAII object.
At construction, this RAII object does the following:

# Check static class invariants, by calling [^['class-type]]`::static_invariant()` (but never non-static class invariants).
# Check preconditions, by calling the functor [^['f]]`()` passed to `.precondition(`[^['f]]`)`.

At destruction instead:

# Check static class invariants, by calling [^['class-type]]`::static_invariant()` (even if the function body threw and exception, but never non-static class invariants).
# If the function body did not throw an exception:
    # Check postconditions, by calling the functor [^['g]]`()` passed to `.postcondition(`[^['g]]`)`.

This ensures that static public member function contracts are correctly checked at run-time (note that static public member functions do not subcontract, see also __Public_Function_Calls__).

[note
A static public member function can avoid calling [funcref boost::contract::public_function] for efficiency but only when it has no precondition and no postconditions, and its class has not static invariant (its class can still have non-static invariants or base classes instead).
]

As already discussed in __Private_and_Protected_Functions__, private and protected member functions never check static or non-static class invariants (not even when they are static member functions).
Therefore, [funcref boost::contract::function] is always used for private and protected member functions, also whey they are static member functions.

[heading Static Class Invariants]

As shown by the example above, when static class invariants are specified, the re programmed in a public `static` member function named `static_invariant` taking no argument and returning `void` (this library will generate a compile-time error if the `static` classifier is missing, unless [macroref BOOST_CONTRACT_CONFIG_PERMISSIVE] is set).
Classes that do not static class invariants, simply do not declare a `static_invariant` member function.
[footnote
This library uses template meta-programming (SFINAE-based introspection techniques) to check static invariants only for classes that declare a member function named `static_invariant`.
]

Any code can be programmed in the `static_invariant` function, but it is recommended to keep this code simple using mainly assertions and if-statements (to avoid programming complex static invariants that might be buggy and slow to execute at run-time).
It is also recommended to use the [macroref BOOST_CONTRACT_ASSERT] macro to program the assertions because it enables this library to print very informative error messages when the asserted conditions are evaluated to be false at run-time (this is not a variadic macro, but see also __No_Macros__):
    
    BOOST_CONTRACT_ASSERT(``/boolean-condition/``)
    // Or, if condition has commas `,` not already within parenthesis `(...)`.
    BOOST_CONTRACT_ASSERT((``/boolean-condition/``))

This library will automatically call [funcref boost::contract::entry_invariant_failed] or [funcref boost::contract::exit_invariant_failed] if any of the [macroref BOOST_CONTRACT_ASSERT] macro conditions are `false` and also if the `static_invariant` function throws an exception (by default, this terminates the program calling `std::terminate`, but see __Throw_on_Failure__ to throw exceptions, exit the program with an error code, etc.).

See __Access__ to avoid making `static_invariant` a public member function (e.g., in cases when all public members of a class must be controlled exactly).
Set the [macroref BOOST_CONTRACT_CONFIG_STATIC_INVARIANT] configuration macro to use a name different from `static_invariant` (e.g., because `static_invariant` clashes with other names in the user-defined class).
[footnote
*Rationale.*
It is not possible to overload a member function in C++ based on the `static` classifier.
Therefore, different function names have to be used for member functions checking static and non-static class invariants (e.g., `invariant` and `static_invariant`).
]

Furthermore, see __Class_Invariants__ and __Volatile_Public_Functions__ for programming non-static and volatile class invariants respectively.

[endsect]

[section Volatile Public Functions]

TODO

[endsect]

[section Throw on Failure]

[import ../../example/features/throw_on_failure.cpp]

If a condition checked using [macroref BOOST_CONTRACT_ASSERT] is `false` or if code specified in preconditions, postconditions, and class invariants throw any exception, this library calls the /contract failure handler/ functions [funcref boost::contract::precondition_failed], [funcref boost::contract::postcondition_failed], [funcref boost::contract::entry_invariant_failed], or [funcref boost::contract::exit_invariant_failed] respectively (in fact, [macroref BOOST_CONTRACT_ASSERT] simply expand to code that throw [classref boost::contract::assertion_failure], see also __No_Macros__).

By default, these handler functions print a message to the standard error `std::cerr` and then terminate the program calling `std::terminate()`.
[footnote
*Rationale.*
In general, when a contract fails the only safe thing to do is to terminate the program execution (because the contract failure indicates a bug in the program, and in general the program might be in a state for which no operation can be successfully performed, so the program should be stopped).
Therefore, that is what this library does by default.
However, for a specific application, programmers could implement some fail-safe mechanism for which some mission-critical operations can always be performed upon handling specific failures.
Therefore, this library allows programmers to override the default contract failure handlers to fully customize how to handle contract failures.
]
However, programmers can override the default contract failure handlers to perform any custom action on contract failure using [funcref boost::contract::set_precondition_failed], [funcref boost::contract::set_postcondition_failed], [funcref boost::contract::set_entry_invariant_failed] and [funcref boost::contract::set_exit_exit_invariant_failed] (or just [funcref boost::contract::set_invariant_failed] to set both entry and exit invariant failure handlers at once).
For example (see also [@../../example/features/throw_on_failure.cpp =throw_on_failure.cpp=]):

[throw_on_failure_handler]

Note that in order to comply with C++ and STL exception safety, destructors should never throw.
This library passes a [classref boost::contract::from] parameter to the contract failure handler functions that can be used to identify if the contract failure occurred during a destructor, a constructor, or a function call.
This way programmers can ensure to never throw from a destructor call (in the example above, failures from destructors are simply ignored... in general, this is not a safe thing to do, but how to handle such a case in real code is left up to the specific applications being programmed).

Then the contract assertions can be programmed to throw [classref boost::contract::assertion_failure] using [macroref BOOST_CONTRACT_ASSERT] (see also __No_Macro__), or any other exception using:

    if(``[^['error-condition]]``) throw ...;

For example (see also [@../../example/features/throw_on_failure.cpp =throw_on_failure.cpp=]):

[throw_on_failure_cstring]

[endsect]

[section Separate Body Implementation]

Contracts are part of the program specification and not of its implementation (see also __Specification_and_Implementation__).
However, this library uses function definitions to program the contracts so contract code will normally appear together with the function implementation code.
Contract code programmed with this library must always appear at the very top of the function definition so programmers will easily be able to distinguish it from the rest of function implementation in any case (so it is not a real problem in practise).

In some cases, it might be desirable to completely separate the contract code from the code that implements the function body implementation code.
For example, this could be necessary for software that ships only header files and pre-compiled source code to its users (notably, that cannot be done for template code in C++).
If the contracts are programmed in the function definitions that are pre-compiled with the source code, users will not be able to inspect the contract code to understand semantics and usage of the functions (again, this might not be a real problem in practice for example if contract code is already being extracted from the source code and presented as part of the documentation of the shipped software).

In such cases, the function implementation can be programmed in an extra /body function/ (e.g., named `..._body`) that is defined in the source code.
The original function definition remains in the header file instead, it programs the contract and simply calls the extra body function.
At the cost of programmers writing an extra function declaration for the body function, this technique allows to keep the contract code in header files while separating the body implementation code to source files (with the limitation that constructor member initialization lists must still be programmed in the header files because that is where the originally constructors are actually defined).

For example, the following header file only contains function declarations and contract code (see also [@../../example/features/separate_body.hpp =separate_body.hpp=]):

[import ../../example/features/separate_body.hpp]
[separate_body_hpp]

Instead, the code implementing the function bodies is programmed in a separate source file (see also [@../../example/features/separate_body.cpp =separate_body.cpp=]):

[import ../../example/features/separate_body.cpp]
[separate_body_cpp]

The same technique can be used for free, private, and protected functions.

[endsect]

[section Overloads and Named Overrides]

Calls to [funcref boost::contract::public_function] from different overloaded functions reuse the same `override_`[^['function-name]] template argument.
Therefore, [macroref BOOST_CONTRACT_OVERRIDE][^(['function-name])] is used only once in a given class even when [^['function-name]] is overloaded.
For example (see also [@../../example/features/override_overload.cpp =override_overload.cpp=]):

[import ../../example/features/override_overload.cpp]
[override_overload]

Note that the function name passed to [macroref BOOST_CONTRACT_OVERRIDE] should never start with an underscore to avoid generating names containing double underscores `override__...` that are reserved by the C++ standard.
There is a separate macro [macroref BOOST_CONTRACT_NAMED_OVERRIDE] that can be used to explicitly specify the name of the type that will be passed to [funcref boost::contract::public_function] as a template argument:
[footnote
*Rationale.*
It is best to use a different macro name [macroref BOOST_CONTRACT_NAMED_OVERRIDE] instead of overloading [macroref BOOST_CONTRACT_OVERRIDE] using variadic macros because the override macros cannot be programmed manually by the users so making them variadic macros would prevent using this library on compilers that do not support variadic macros (see also __No_Macros__).
]

    BOOST_CONTRACT_OVERRIDE(``[^['function-name]]``) // Generate `override_...`.
    BOOST_CONTRACT_NAMED_OVERRIDE(``[^['type-name]]``, ``[^['function-name]]``)

This second macro can be used for function names that start with an underscore `_...`, when the name `override_`[^['function-name]] clashes with another name the user class, or in any other case when programmers need to generate a name different than `override_...`.
For example (see also [@../../example/features/named_override.cpp =named_override.cpp=]):

[import ../../example/features/named_override.cpp]
[named_override]

[endsect]

[section Access]

As we have seen, this library requires programmers to augment their classes declaring special members that are internally used to implement contracts:

* The `invariant` and `static_invariant` member functions (used by this library to check class invariants).
* The `base_types` member type (used by this library to implement subcontracting).
* The `override_`[^['function-name]] member type (used by this library to implement subcontracting for overriding functions).

Normally, some of these members must be public in order to be accessible by this library.
However, in some cases programmers might need to exactly control the public members of their classes in order to prevent users from incorrectly accessing encapsulated members (this might be especially true in large projects).

`override_`[^['function-name]] never needs to be `public` and programmers can always declare it using [macroref BOOST_CONTRACT_OVERRIDE] in a `private` (or `protected`) section of the class.
[footnote
*Rationale.*
The internals of the `override_...` type generated by [macroref BOOST_CONTRACT_OVERRIDE] use names reserved by this library to users are not able to actually use such a type even when it is defined as a `public` member.
In theory, using C++14 generic lambdas, the [macroref BOOST_CONTRACT_OVERRIDE] macro could be re-implemented in a way so it can be expanded at function scoped (instead of class scoped).
]
`invariant`, `static_invariant`, and `base_types` normally need to be `public`, but programmers can declare them in a `private` (or `protected`) section of the class as long as they also declare the [classref boost::contract::access] class as `friend`.
For example (see also [@../../example/features/access.cpp =access.cpp=]):

[import ../../example/features/access.cpp]
[access]

This technique is not used in most examples of this documentation only for brevity, but programmers are encouraged to use it in real code.

See also __Base_Types__, __Class_Invariant__, and __Overloads_and_Named_Override__ to declare these members with different names (e.g., when they clash with other names in the user-defined class).

[endsect]

[section Assertion Requirements (Call-If)]

In general, assertions can introduce a new set of requirements on the types used by the program: Some of the type requirements might be necessary only to program the assertions and they would not be required by the program otherwise.

* In some cases it might be acceptable, or even desirable, to cause a compile-time error when a program uses types that do not provide all the operations needed to check contract assertions (because it is not possible to fully check the correctness of the program as stated by the contracts).
In these cases, programmers can specify contract assertions as we have seen so far, and compilation will fail if user types do not provide all operations necessary to check the contracts.
* However, in other cases it might be desirable that adding contracts to a program does not alter its type requirements and that assertions are simply not checked when user types do not provide all the operations necessary to check them.
With this library, this can be done using [funcref boost::contract::call_if] and [funcref boost::contract::call_if_c].

For example, let's consider the STL `vector<T>` class template.
This class template (as specified by the STL without the contracts) does not normally require that `T` has an equality operator `==` (it only requires `T` to be copy constructible).
However, the full contracts of the `vector<T>::push_back(value)` member function include a postcondition `back() == value` which introduces the new requirement that `T` must have an equality operator `==`.
Programmers can specify this postcondition as-is an let the program fail to compile when users instantiate this template with a type `T` that does not provide an equality operator `==`.
Otherwise, programmers can specify this postcondition using [funcref boost::contract::call_if] so to check the assertion only for types `T` that have an equality operator `==`, and trivially check `true` otherwise (see also [@../../example/features/call_if.cpp =call_if.cpp=]):

[import ../../example/features/call_if.cpp]
[call_if]

[funcref boost::contract::call_if] takes a condition template parameter as a boolean meta-function.
It takes a "then" nullary functor `t`, it calls and returns `t()` when the boolean meta-function evaluates to `true` at compile-time (thus `t()` must be valid code only in this case).
It provides an `else_` member to specify an "else" nullary functor `e`, it calls and returns `e()` when the boolean meta-function evaluates to `false` at compile-time (thus `e()` must be valid code only in this case).
It also provides an `else_if` member that can be used (multi times) to specify other boolean meta-function conditions and "then" and "else" nullary functors to be evaluated and valid only when the boolean meta-function is `false` at compile-time.
`else_` and `else_if` are optional if `t()` return value is `void` (otherwise the return types of `t()`, `e()`, and all the other nullary functors passed to `else_if` must all be compatible).
(There are also alternative versions named [funcref boost::contract::call_if_c] and `else_if_c` that take boolean constants instead of boolean meta-function conditions as template parameters.)

    boost::contract::call_if<``[^['boolean-meta-function-1]]``>(
        ``[^['then-nullary-functor-1]]``
    ).else_if<``[^['boolean-meta-function-2]]``>( // Optional.
        ``[^['then-nullary-functor-2]]``
    )
    ``[^['...]]`` // Else-if can be repeated zero or more times.
    .else_( // Optional for functors returning `void`.
        ``[^['else-nullary-functor]]``
    )

Therefore, the above `push_back` example calls (via `bind`) the functor `std::equal_to<T>()(boost::cref(back()), boost::cref(value))` that checks the postcondition `back() == value` requiring `T`'s equality operator `==`, but only when the `boost::has_equal<T>` meta-function evaluates to `true` at compile-time.
Otherwise, the lambda function `[] { return true; }` is used to trivially evaluate the postcondition assertion to be `true` when `T` does not have an equality operator `==`.

[heading Old Value Requirements]

TODO

[heading Static-If (C++14)]

[funcref boost::contract::call_if] is a general-purpose facility and it can be used together with C++14 generic lambdas to implement statements similar to `static if` (at least at function scope, see also [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3613.pdf N3613]).
For example, consider the following implementation of `std::advance` that uses `static if`-like statements implemented via [funcref boost::contract::call_if] (see also [@../../example/features/static_if_cxx14.cpp =static_if_cxx14.cpp=]):

[import ../../example/features/static_if_cxx14.cpp]
[static_if_cxx14]

This implementation is much more concise, easy to read and maintain than the usual implementation of `std::advance` that uses tag dispatching.
[footnote
`boost::hana::if_` can also be used to emulate function scope `static if` with C++14 generic lambdas.
]

[endsect]

[section No Macros (No C++11)]

[import ../../example/features/no_macros.cpp]

This section illustrates how to write contracts without using this library macros and programming the related code manually instead (a part from [macroref BOOST_CONTRACT_OVERRIDE] and [macroref BOOST_CONTRACT_NAMED_OVERRIDE] that cannot be programmed manually).

Some of this library macros are variadic macros, others are not (see below).
Variadic macros were officially added to the language since C++11.
However, C++ compilers have been supporting variadic macros as an extension for a long time, plus essentially all compilers that support C++11 lambda functions also support C++11 variadic macros (and this library might rarely be used without the convenience of C++11 lambda functions, see also __No_Lambda_Functions__).
Therefore this section can be considered more of a curiosity than anything else because programmers should seldom need to use this library without its macros.

[heading Overrides (Not Variadic)]

As shown in __Overriding_Public_Functions__ and __Overloads_and_Named_Overrides__, this library provides the [macroref BOOST_CONTRACT_OVERRIDE] and [macroref BOOST_CONTRACT_NAMED_OVERRIDE] macros to program overriding public functions.
These macros cannot be programmed manually, but these are not variadic macros and programmers should never need not to use them.
[footnote
*Rationale.*
These macros expand SFINAE-based introspection templates that cannot be reasonably programmed by users (that remains the case even if C++14 generic lambdas were to be used here).
]

[heading Assertions (Not Variadic)]

As shown in __Preconditions__, __Postconditions__, __Class_Invariants__, etc. this library provides the [macroref BOOST_CONTRACT_ASSERT] macro to assert contract conditions.
This is not a variadic macro and programmers should be able to use it on all C++ compilers.
However, this macro:

    BOOST_CONTRACT_ASSERT(``[^['boolean-condition]]``)

Simply expands to code equivalent to the following:

    if(!``[^['boolean-condition]]``) {
        throw boost::contract::assertion_failure(__FILE__, __LINE__,
                BOOST_PP_STRINGIZE(``[^['boolean-condition]]``));
    }

That is because this library considers any exception thrown from within preconditions, postconditions, and class invariants as a contract failure and reports it calling the related contract failure handler ([funcref boost::contract::precondition_failed], [funcref boost::contract::postcondition_failed], [funcref boost::contract::entry_invariant_failed] or [funcref boost::contract::exit_invariant_failed]).
In fact, if there is a need for it, programmers can always program contract assertions that throw user-defined exceptions without using [macroref BOOST_CONTRACT_ASSERT] (see also __Throw_on_Failure__):

    if(!``[^['boolean-condition]]``) throw ``[^['user-defined-exception]]``(...);

[heading Base Types (Variadic)]

As shown in __Base_Types__, this library provides the [macroref BOOST_CONTRACT_BASE_TYPES] variadic macro to declare a `base_types` member type that lists the public bases of a derived class.
Programmers can also declare `base_types` without using [macroref BOOST_CONTRACT_BASE_TYPES] at the cost of writing a bit more code manually (see also [@../../example/features/no_macros.cpp =no_macros.cpp=]):

[no_base_types_macro]

The `base_types` member type must be a `boost::mpl::vector` listing /only/ `public` base classes (because only public bases subcontract, see also __Function_Calls__).
[footnote
*Rationale.*
`boost::mpl::vector` is used because this library is design to work with other Boost libraries.
]
If the [macroref BOOST_CONTRACT_BASE_TYPES] macro is not used, it is the responsibility of the programmers to maintain the correct list of bases in the `boost::mpl::vector` each time the derived class inheritance list changes (this might complicate maintenance).
In general, it is recommended to use the [macroref BOOST_CONTRACT_BASE_TYPES] macro if possible.

[heading Old Values (Variadic)]

As shown in __Old_Values__ and __Virtual_Public_Functions__, this library provides the [macroref BOOST_CONTRACT_OLDOF] variadic macro to initialize old values.
Programmers can also initialize old values without using [macroref BOOST_CONTRACT_OLDOF] at the cost of writing a bit more code manually (see also [@../../example/features/no_macros.cpp =no_macros.cpp=]):

[no_oldof_macro]

C++ ternary operator `... ? ... : ...` must be used here to avoid evaluating and copying the old value expression (`size()` in this example) when old values are not being copied (because postcondition checking is disabled, within overridden virtual function calls for subcontracting, etc.).
[classref boost::contract::old]`()` creates an empty old value (that introduces no copy).
[funcref boost::contract::copy_old]`()` returns `true` if and only if old values are being copied.
When used in public virtual functions, programmers must pass the extra [classref boost::contract::virtual_]`* v` argument to [funcref boost::contract::copy_old]`(v)`, for example (see also [@../../example/features/no_macros.cpp =no_macros.cpp=]):

[no_virtual_oldof_macro]

In general, it is recommended to use the [macroref BOOST_CONTRACT_OLDOF] macro if possible.

[endsect]

[section No Lambda Functions (No C++11)]

This section illustrates how to use this library without C++11 lambda functions.
This presets some advantages:

* It allows to use this library on compilers that do not support C++11 lambda functions (essentially C++03 compilers can be used, see __No_Macros__ to also avoid using variadic macros).
* Functors can be programmed to fully enforce constant-correctness and other contract requirements at compile-time (see also __Constant_Correctness__).
[footnote
If C++ supported to capture lambda function variables by constant references `[const&] () { ... }` that could be used to program contract functors using lambda functions that also enforce __Constant_Correctness__ at compile-time (not that value captures cannot be used to program postconditions, plus it introduces an extra copy that might not always be possible or desirable).
]
* Contracts are automatically separated from function body implementations (see also __Specification_and_Implementation__ and __Separate_Body_Implementation__).

However, not using C++11 lambda functions comes to the significant cost of having to manually write a great deal of extra code to program the contract functors (therefore, the authors think this library is most useful when C++11 lambda functions can be used).

For example (see also [@../../example/features/no_lambdas.hpp =no_lambdas.hpp=] and [@../../example/features/no_lambdas.cpp =no_lambdas.cpp=]):

[import ../../example/features/no_lambdas.hpp]
[no_lambdas_hpp]

[import ../../example/features/no_lambdas.cpp]
[no_lambdas_cpp]

If programmers also want to fully enforce all contract programming constant-correctness requirements at compile-time, they should follow these rules when programming the contract functions (see also __Constant_Correctness__):

* In general, precondition and postcondition functions (e.g., named `..._precondition` and `..._postcondition`) should take their arguments by `const&` and they should be either `static` or `const` member functions.
However, postconditions can (but do not have to) take old value arguments by value (because these are pointers to `const` objects already).
* In general, old value functions (e.g., named `..._old`) should take their arguments by `const&` a part from old value pointers that should be taken by `&` (so only old value pointers can be modified), and they should be either `static` or `const` member functions.
* Constructor precondition and old value functions should be `static` (because constructor preconditions and old-values cannot access the object `this`, see also __Constructor_Calls__).
* Destructor postcondition functions should be `static` (because destructor postconditions cannot access the object `this`, see also __Destructor_Calls__).

Note that the extra contract functions also allowed to program only the contract code in the header file (see also __Specification_and_Implementation__).
All function body implementation code was instead programmed in the source file (including the constructor member initialization list, that could not be done with the technique illustrated by __Separate_Body_Implementation__).
[footnote
In this example, `bind` was used to generate nullary functors from the contract functions.
As always with `bind`, `cref` and `ref` must be used to bind arguments by `const&` and `&` respectively, plus it might be necessary to explicitly `static_cast` the function pointer passed to `bind` in case the bound function name is overloaded.
]

Finally, note that the extra contract functions can always be declared `private` if programmers need to exactly control the public members of the class (this was not done in this example only for brevity, see also __Access__).

[endsect]

[endsect]

