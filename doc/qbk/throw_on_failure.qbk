
[section:throw_on_failure Annex: Throw on Failure]

This example shows how to setup the library to throw exceptions on contract condition failure (overriding the library default behaviour to call `std::terminate()` to handle contract failures).

Specifically:

# Any exception (including user defined ones) that is thrown when checking a contract condition is re-thrown by the contract failure handlers defined below.
# However, if a contract condition fails from a destructor, exceptions cannot be thrown (to comply with C++ STL exception safety requirements) so a message is logged to `std::clog` and the program execution continues.
[footnote Continuing the program in this case assumes that the destructors body will be able to somehow execute correctly even if the class invariants do not hold true.
This is usually /not/ a safe assumption and it is made here only for simplicity.
You could chose to still terminate in case class invariants fail for a destructor or to attempt to recover from such an error in some other, more sophisticated, way.]
# In addition, the postcondition failure handler catches any exception derived from `std::exception` to print the exception description `what()` on `std::clog` before re-throwing it (this is to show how the contract failure handlers can selectively catch exceptions).

[throw_on_failure_cpp]

[endsect]

