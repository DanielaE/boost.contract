/**

@page Quick_Start Quick Start

<div align="right"><small>
@ref index "Previous" | @ref Design_By_Contract "Next"
</small></div>

This section briefly shows how to use this library to write contracts.

@section Conventions

This library provides both a <em>macro-based API</em> and a
<em>code-based API</em> to write contracts. The code-based API relies less on 
macros, allows to more easily understand how the library works, but requires 
the programmer to write much more "setup code" and does not support automatic
contract documentation. The use of the macro-based API is recommended whenever 
possible because it makes the contracts more readable and it is less work for 
the programmer. This section illustrates the macro-based API while both APIs
are explained in later sections.

This library defines most of its symbols in the @c dbc namespace.
Futhermore, all library macros are prefixed by @c DBC_ (C++ macros are not local to any namespace). Any
library symbol (class, function, variable, macro, etc) ending with an
underscore @c _ is implementation specific and <em>must not</em> be used
directly so it is left out of this documentation.
Some library symbols are defined into the global namespace and at the class 
scope when contracts are added to a user defined classes (this is because the
user classes have to be "augmented" with symbols defining their contracts).
All these symbols defined by this library outside the @c dbc namespace have
names of the form @c dbc_..._ where the leading @c dbc_ attempts to avoid name
clashes and the ending underscore indicates that these symbols are
implementation specific and must not be used. Metapgrogramming constructs
used by this library and listed by this documentation are indicated with
implementation specific names ending with @c _ (as they should not be used
directly).

@section Platform

This library is highly portable as it only requires the highly portable
@ref Boost "Boost C++ library".

This library uses both preprocessor and template metaprogramming (via the
Boost.Preprocessor and Boost.MPL libraries), as a consequence it is
fairly demanding of C++ compiler compliance to ISO standards. At present,
this library has been successfully compiled and tested on the following
compilers/platform:

-#  g++ 4.2.4 on Ubuntu Linux.
-#  Microsoft Visual C++ 8.0 on Windows XP.
-#  g++ 3.2.1 on Cygwin.

This library has been developed under @ref Ubuntu Linux and this documentation 
makes explicit references to Linux commands. However, if you are using an
operating system different from Linux, it should be trivial to mirror the
commands used by this documentation into the equivalent ones for your operating
system.

This library has been developed using the Boost C++ library version 1.34.1.
Boost is a highly portable C++ library that is available for a variety of 
platforms. For example, on Ubuntu Linux, assuming your computer is properly
connected to the Internet, you can install Boost simply using:

@verbatim
$ sudo apt-get install libboost-dev
@endverbatim
<small>

@note Boost is used by this library implementation for the followings:
    <ul>
    <li> Boost.Preprocessor for preprocessor metaprogramming (essentially to
        support an arbitrary number of function arguments as specified by
        @c DBC_CONFIG_MAX_ARGC).
    <li> Boost.MPL for template metaprogramming (essentially for type traits, to
        support @c dbc::copyable, and to generate the @c DBC_ERROR_...
        compile-time errors for improper library use).
    </ul>
    Earlier versions of this library did not rely on Boost but the 
    implementation required quite a bit of manual (and error prone) code 
    duplication to deal with multiple function arguments, a good deal of type 
    traits reimplementation, and provided no compile-time checking for improper 
    library use.

</small>
This library has been developed using the @c g++ C++ compiler version 4.2.4.
For example, on Ubuntu Linux you can install @c g++ using:

@verbatim
$ sudo apt-get install g++-4.2
@endverbatim

@section Installation Installation

You can download the latest release of this library at
http://sourceforge.net/projects/dbcpp/ . On Linux, you can unpack the 
compressed downloaded file using:

@verbatim
$ tar -xzf dbcpp_<VERSION>.tar.gz
@endverbatim

This creates a directory @c "dbcpp_<VERSION>/" that contains the library source
files, examples, documentation, etc.

<table border="0">
<tr><td><c>dbcpp_<VERSTION>/</c>
    <td>
    <td>Library distribution root directly (referred as <c>$DBC_ROOT</c>).
<tr><td>
    <td><c>include/</c>
    <td>Library source files.
<tr><td>
    <td><c>doc/</c>
    <td>Library documentation.
        The HTML library documentation is in @c "doc/html/index.html".
<tr><td>
    <td><c>example/</c>
    <td>Library example files.
        Examples from [@ref Mey97], [@ref Mit02], [@ref Str97], etc. See
        @c "example/OO_SW_Constduction/Stack4/" for a good general DBC
        example, @c "example/DBC_by_Example/NameList/" for simple example
        of subcontdacting, and @c "example/DBC_by_Example/Observer/" for
        a more complex example.
<tr><td>
    <td><c>test/</c>
    <td>Library test files.
        These files also show advanced use of the library API.
<tr><td>
    <td><c>build/</c>
    <td>Example and test built programs.
        Run <c>`[$DBC_ROOT]$ make'</c> to see how to build example and test
        programs (the library itself does not need to be built).
<tr><td>
    <td><c>codedoc/</c>
    <td>Example and test source code documentation.
        This is NOT the library documentation. This documentation is
        generated when examples and tests are built and it contains their
        contract documentation automatically generated.
<tr><td>
    <td><c>bin/</c>
    <td>Library support programs and scripts.
</table>

@remark In the rest of this documentation, we will
    refer to this directory explicitly as @c "$DBC_ROOT" or implicitly when a
    file path is local (e.g., @c "inlucde/" implicitly indicates
    @c "$DBC_ROOT/include/"). Furthermore, command prompts that indicate the
    directory explicitly as in <c>[$DBC_ROOT]$ <em>command</em></c> require the
    specified command to be executed from the indicated directory. Otherwise, 
    if the prompt does not indicate any directory as in 
    <c>$ <em>command</em></c> then the command can be executed from the local 
    directory or any directory.

This library is composed of header files only (there is no pre-compiled object 
file). You can install the library simply by copying @e all contents of the
@c "$DBC_ROOT/include/" directory into a directory that is part of your
complier's include path. For example, on Linux you can copy the library header
files to the @c "/usr/include/" directory (you might need to be root):

@verbatim
[$DBC_ROOT]$ sudo cp -r include/ /usr/include/
@endverbatim

Or, you can install the library in some other directory and add that
directory to the compiler include path (use the @c -I option for the @c g++
complier).

@section Overview Overview

Design By Contract is characterized by at least four simple assertion
mechanisms (see [@ref Mey97]):
-#  It is possible to describe the member function's @b preconditions.
    These are logical conditions that the programmer of the function excepts to
    be true when the function is called (e.g., to check constraints on function
    parameters). @n @n
    In preconditions, the variable @c self is a constant reference to the
    object and constant reference to function arguments can be accessed via
    thier names @c argument_name. @n @n
-#  It is possible to describe the member function's @b postconditions.
    These are logical conditions that the programmer expects to be true when
    the function has ended normally (e.g., to check the result and any side
    effect that a function has). @n @n
    In postconditions, constant references to the object and function arguments
    current value, @e after the body execution, can be accessed via @c self.now
    and <c>argument_name.now</c> respectively. If the object class or
    function argument types have been declared copyable (using
    @c DBC_COPYABLE() or @c dbc::copyable) then their values @e before the
    body was executed can also be accessed, in this case via @c self.old and    
    <c>argument_name.old</c>. 
    Furthermore, postconditions of non-void member function can access a
    constant reference to the function returned value via @c result. @n @n
-#  It is possible to describe class @b invariants.
    These are logical conditions that the programmer expects to be true after
    the constructor has been executed successfully, before and after the
    execution of each member function with a contract, and before the
    destructor is executed (e.g., invariants can define a valid state for all
    objects of a class). @n @n
    In invariants, the variable @c self is a constant reference to the
    object. @n @n
-#  It is possible to formalize the notion of overriding a virtual member
    function via @b subcontracting.
    Subcontracting can be justified by substitution principles and it consists 
    of the following rules that the overriding function must obey:
    <ol>
    <li>    Preconditions cannot be stronger.
    <li>    Postconditions cannot be weaker.
    <li>    Invariants are inherited and can never be weaker in derived class.
    </ol>
    When subcontracting, this library automatically @e ORs preconditions and
    @e ANDs postconditions and invariants between the contracts of the base and
    derived classes to implement these rules. @n @n
    This library allows contracts in a derived class to be specificied as 
    subcontracts of the related contract in the base class via the @c DBC_BASE()
    macro or the @c B template argument of @c dbc::fum::mem.

@remark Contracts should use the class's public API as much as possible so they
    are implementation independent. However, postconditions and invariants are
    often used to check the correctness of the implementation and in come cases
    they must access the private or protected API. Preconditions
    should only access the public API, otherwise the caller cannot check them
    before invoking the function (see [@ref Mey97]). However, this
    library does not enforce any access level rule in contracts - this is left
    up to the programmer.

Based on the above definitions of preconditions, postconditions, and
invariants, this library implements the following call semantics for every 
member function, constructor, and destructor for which the programmer provides
a contract (as indicated in [@ref Mey97], [@ref Ott04], and [@ref Str97]):
-   @anchor Constructor_Call_Semantics <b>Constructor Call Semantic</b> @n
    A constructor call executes the following steps:
    -#  Initialize member variables (via the constructor's member 
        initialization block).
    -#  Check preconditions but not invariants. Constructor preconditions
        have no access to @c self. Before constructor body execution,
        there is no object and invariants do not have to hold.
    -#  Execute constructor body.
    -#  Check invariants.
    -#  Check postconditions.
-   @anchor Destructor_Call_Semantics <b>Destructor Call Semantic</b> @n
    A destructor call executes the following steps:
    -#  Check invariants (but only if destructor was not called during stack 
        unwinding because of a previously thrown and not yet handled
        exception). In case of failure, @c broken_destructor_invariant() is
        be called instead of throwing an exception (this is to comply with C++
        STL exception safety requirements, see [@ref Ott04] and [@ref Str97]).
    -#  Execute destructor body. After destructor body execution, there is
        no object anymore so invariants are not checked.
-   @anchor Member_Function_Call_Semantics <b>Member Function Call Semantics</b> @n
    A member function executes the following steps:
    -#  Check invariant @e and (when subcontracting) check base class
        function's invariants.
    -#  Check preconditions @e or (when subcontracting) check base class
        function's preconditions.
    -#  Execute function body.
    -#  Check invariant @e and (when subcontracting) check base class
        function's invariants.
    -#  Check postconditions @e and (when subcontracting) check base class
        function's postconditions.

In the above rules, @e "and" and @e "or" are evaluated in short-circuit (i.e.,
A @e and B evaluates B only if A is evaluated to be true, A @e or B
evaluates B only if A is evaluated to be false).

Once the programmer has specified contracts, the library provides a mechanism 
for checking whether the conditions hold at run-time. The @c DBC_CHECK_...
macros can be used to turn this run-time checking on or off selectively for the
sake of efficiency (e.g., only compile and check invariants and preconditions
but no postconditions).
If a condition fails, the library will throw an exception by default but a 
mechanism is provided for the programmer to specify conditions that throw user 
defined exceptions, terminate, or exit the program.
Furthermore, the programmer can selectively chose which of these conditions
should be checked using the @c DBC_CONFIG_ENABLE_... macros (e.g., only check
conditions that terminate or the program but no the ones that throw
exceptions).

@section A_Complete_Example A Complete Example

This is a fully working example that illustrates how to write contracts using
the library macro-based API (from @c "example/str/str.cpp").

@include example/str/str.cpp

On Linux, it can be compiled using:

@verbatim
[$DBC_ROOT]$ g++ -Wall -I./include -DDBC_ALL -DDBC_CONFIG_LOG_LEVEL=DBC_LOG_LEVEL_ALL ./example/str/str.cpp -o ./build/example/str
@endverbatim

The @c DBC_ALL macro is defined (@c -D option) to indicate that all contracts
(preconditions, postconditions, and invariants) should be compiled and checked.
The @c DBC_CONFIG_LOG_LEVEL macro is defined to @c DBC_LOG_LEVEL_ALL so the
library will output debug information on what conditions are being checked
(this verbose output is enabled here for demonstration only, usually 
the @c DBC_CONFIG_LOG_LEVEL can be left undefined so the DBC library will only 
log informations in case of a condition failure).

On Linux, the compiled example program can be executed using:

@verbatim
[$DBC_ROOT]$ ./build/example/str
@endverbatim

Which produces the following output:

@verbinclude doc/src/str.out

Note that the library's optional debug messages (prefixed by @c "dbc:") show how
preconditions, postconditions, and invariants are checked when constructors,
destructors, and member functions are called according to the
@ref Constructor_Call_Semantics "DBC call semantics".

Finally, <a href="str/classstr.html">this</a> shows the source code 
documentation generated by @ref doxygen for this example
(see @ref Automatic_Contract_Documentation for details).
Note that preconditions, postconditions, and invariants have been automatically
documented by this library.

<div align="right"><small>
@ref index "Previous" | @ref Design_By_Contract "Next"
</small></div>

*/

