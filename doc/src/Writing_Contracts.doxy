/**

@page Writing_Contracts Writing Contracts

<div align="right"><small>
@ref Design_By_Contract "Previous"
</small></div>

This library provides both a @e macro-based API and a @e code-based API to 
write contracts. This section gives an overview of both types of API, the 
actual API function and macro documentation should studied as well in order to 
understand how to use this library to write contracts.

In general, it is strongly recommended to use the macro-based API. The
code-based API may occasionally be needed in special cases where the
macro-based API does not suffice. The following is a summary of pro (+) and 
cons (-) of the two API.
        
<table>
<tr><th>Characteristic
    <th>Macro-Based API <em>(recommended)</em>
    <th>Code-Based API
<tr><td>Require extra code to "setup" the contract.
    <td>@b + No extra code required (the "setup" code is generated
        automatically by the macros).
    <td>@b - The programmer has to manually write quite a bit of extra "setup"
        code.
<tr><td>Enhance code readability.
    <td>@b + After about 1 week of use, you will become familiar with the macro
        syntax and the code will be easy to read.
    <td>@b - The extra "setup" code reduces the contract readability.
<tr><td>Automatically document contracts.
    <td>@b + Yes.
    <td>@b - No (unless programmers also manually program code to write the 
        documentation using the @c DBC_CONFIG_DOC_... macros but this will
        require a significant extra effort).
<tr><td>Require extra syntax to become familiar with.
    <td>@b - Programmers need to become familiar with the syntax used to
        specify the member function @a signature in @c DBC_MEM_FUN() and
        similar macros (this usually only requires about 1 week of using the
        library).
    <td>@b + No special syntax is introduced (just common C++ code structures).
<tr><td>Allow to easily understand how the library works.
    <td>@b - The mechanisms used by the library to check the contracts are
        hidden within the code automatically generated by the macros.
    <td>@b + The code allows to have a better understanding of how the library
        checks contracts at least at high level.
<tr><td>Provide extra flexibility to handle special cases.
    <td>@b - The code generated by the macros can handle most library uses
        but not necessarily all.
    <td>@b + Programmers have full control of the contract code as they are
        writing it manually. This extra flexibility might occasionally be
        needed to handle special cases (e.g., special C++ program structures,
        workaround internal compiler errors, etc). @n
        <em>In these special and rare cases, it is appropriate to use the
        code-based API instead of the macro-based API.</em>
</table>

@section Macro_Based_API Macro-Based API

The library macro-based API uses the @c DBC_CONSTRUCTOR(), @c DBC_DESTRUCTOR(),
and @c DBC_MEM_FUN() macros to specify contracts for constructors, destructor,
and member functions respectively.

@section Invariants Invariants

The @c DBC_INVARIANT() macro is used to specify the class invariants.

It is also possible to write the function that checks the class
invariants directly naming it using the @cref{DBC_INVARIANT_FUN} macro.
However, this approach is highly discourage and @c DBC_INVARIANT() should
be used whenever possible.

@section Base_Object Base Object

All classes for which a contract is specified must privately inherit from the
@c dbc::object class. This is achieved using the @c DBC_INHERIT_OBJECT() macro,
or the @c DBC_MULTI_INHERIT_OBJECT() macro in case of multiple inheritance.

@section Macro_Parameters_with_Commas Macro Parameters with Commas

The @c DBC_MPARAM() macro can be used to pass a macro parameter with
one or more comma @c "," .
(This is required because of a limitation of the C++
preprocessor that only recognizes the <c>()</c> parenthesis so a comma in
a macro parameter not wrapped by these parenthesis will split the parameter
into two different macro parameters.)

@section Assertions Assertions

The @c DBC_ASSERTION() macro can be used to specify contract assertions.
The @c DBC_ASSERTION_STREAM() macro can also be used and it allows the 
programmers to specify a more verbose error message and an action (throw, 
terminate, or exit) different from
@cref{DBC_CONFIG_DEFAULT_ON_ASSERTION_VIOLATION} to take in case of an 
assertion failure.

Run-time assertion checking can be selectively turned on or off depending on
the action in case of assertion failure using 
@cref{DBC_CONFIG_ENABLE_THROWING_ASSERTIONS},
@cref{DBC_CONFIG_ENABLE_EXITING_ASSERTIONS}, or
@cref{DBC_CONFIG_ENABLE_TEMNINATING_ASSERTIONS}.

These macros are wrappers around @c dbc::assertion and
@c dbc::oassertionstream. These assertion classes can be used directly but it 
is recommended to use the macros whenever possible to gain the benefits of
automatic contract documentation, run-time assertion checking enabling and
disabling using <c>DBC_CONFIG_ENABLE_..._ASSERTIONS</c>, etc.

@section Default_Exceptions Default Exceptions

By default, a precondition failure throws a
@c dbc::precondition_violation exception, a postcondition failure throws a
@c dbc::postcondition_violation exception, and an invariant violation throws a
@c dbc::invariant_violation exception. All these exceptions inherit from
@c dbc::condition_violation which in turns inherits from
@c std::logic_exception.

In case an invariant failure attempts to throw an exception when checked by the
destructor, no exception is thrown and @c dbc::broken_destructor_invariant()
is called instead (this is to comply with C++ STL exception safety 
requirements). The @c dbc::set_broken_destructor_invariant() can be used to 
specify a different function to be executed to handle this case.

@section Separating_Declaration_and_Definition Separating Declartion and Definition

Contracts are written together with the class declaration as they are part of
the class specification. The member function definition (the body) can either
be provided together with the contract in the class declaration or the
@c DBC_BODY() macro can be used to separate the function definition from its
declaration.

Similarly, the @c DBC_DESTRUCTOR_BODY() and @c DBC_OPERATOR_BODY() macros can
be used to separate body definitions from contract declarations for destructor
and member operators respectively. For constructors, the special @c init() 
function should be used instead -- see @c DBC_CONSTRUCTOR() for more detail.

In general, it is recommended to split body definitions from contract
declarations when possible as this will make the class declaration simpler and
easier to read plus the compile-time errors in the body code will be more
readable because the code will not be passed as a single-lined macro parameter.

@section The_old_Postfix The "old" Postfix

In the @a signature argument of the macro-based API, the @c DBC_COPYABLE()
macro is used to indicate either a copyable class or function argument type for
which the value before the body execution needs to be accessed in the
postconditions using the "old" postfix. For the code-based API,
@c dbc::copyable should be used instead.

In general, indicating a type copyable adds the extra requirement that the type
must have a copy constructor and it has an impact on performances due the
CPU time and memory required for the copy. Therefore, a type should be
indicated copyable only if the "old" prefix for the variable of that type is
needed to write the postconditions.

@section Subcontracting Subcontracting

In the @a signature argument of the code-based API, the @c DBC_BASE() macro is
used to specify a base class from which the contract is subcontracted. For the
code-based API, the @a B argument of @c dbc::fun::mem should be used instead.

@warning When invoking the base class member function from the overriding
    function, you must use the @c DBC_BODY() macro to refer to the base
    function in order to avoid infinite recursion. The library implementation
    might change in the future so to relax this requirement.

@section Optional_Contract_Compilation Optional Contract Compilation

The @cref{DBC_NO}, @cref{DBC_CHECK_REQUIRE},
@cref{DBC_CHECK_ENSURE}, @cref{DBC_CHECK_INVARIANT}, and
@cref{DBC_ALL} macro symbols can be used to respectively compile and check
either nothing, preconditions, postcondition, invariants, or all the above. If
on of these macro symbols is defined, the relative contract part (preconditions,
postconditions, or invariants) are compiled and checked, otherwise the relative
contract part is not compiled at all and it will not be part of the object
code (therefore, it will not be checked).

Any logically consistent combination of these macro symbols can be used as
well. For example, defining both @c DBC_CHECK_REQUIRE and
@c DBC_CHECK_INVARIANT will compile and check both preconditions and
invariants. However, defining @c DBC_NO and @c DBC_CHECK_REQUIRE will cause a
compile-time error as this is an logically inconsistent combination.

@section Configuration Configuration

The library can be configured at compile-time defining the @c DBC_CONFIG_...
macro symbols. If defined by the user, these symbols must be defined either in
the code before the @e first inclusion of the library or by the compiler (use
the <c>-D</c> and <c>-U</c> options for @c g++). If the user does not define 
these symbols, the library uses default values.

These configuration symbols allow to highly customize the library behaviour,
indicating what type of assertion to check at run-time, where to log messages,
the log verbosity level, how to automatically generate documentation (to use a
documentation tool different from @ref doxygen), what is the maximum number of
function arguments for which contracts should be supported, etc.

See the @c dbc/config.hpp documentation for details.

@section Code_Based_API Code-Based API

The code-based API uses @c dbc::fun::constr, @c dbc::fun::destr, and
@c dbc::fun::mem directly to write contracts (instead of using the
@c DBC_CONSTRUCTOR(), @c DBC_DESTRUCTOR(), and @c DBC_MEM_FUN() of the
macro-based API). However, the use of the macro-based API is preferred and the 
code-based API should only be used when the macro-based API does not suffice.

When using the code-based API, it is recommended to use the @c DBC_CONTRACT()
macro to name the contract class as this will allow to subcontract between
contracts written with the code-based API and others written with the
macro-based API.

The following is the same example introduced in @ref A_Complete_Example but
rewritten to use the code-based API instead of the macro-based API
(from @c "example/str/str-codeapi.cpp").

@include example/str/str-codeapi.cpp

On Linux, it can be complied and executed similarly to @ref A_Complete_Example.

Comparing it with the same example written the macro-based API, note how the
code-based API introduce much more code that reduce the contract readability,
it requires much more work for the programmer, it does not automatically
document the contract but it allows to better understand how the library checks
the contracts.

<div align="right"><small>
@ref Design_By_Contract "Previous"
</small></div>

*/

