/**

@page Design_By_Contract Design By Contract

<div align="right"><small>
@ref Quick_Start "Previous" | @ref Writing_Contracts "Next"
</small></div>

This section gives some background on Design By Contract (DBC) and points 
to references that can be used to learn more on the topic.

@section Benefits Benefits

The main use of DBC is to improve software quality. [@ref Mey97] discusses how
DBC can be used as the basic tool to write "correct" software. The following 
is a short summary of benefits associated with using DBC mainly taken from
[@ref Ott04]. See also [@ref Str97] for more discussion on the key importance
of class invariants and on advantages and disadvantages of using preconditions 
and postconditions.

-#  Using DBC preconditions and postconditions, the programmer can give a
    precise semantic description of what a function requires at its entry and
    what it ensures under its (normal) exit. In particular, using the "old"
    postfix in postconditions, DBC provides a mechanism that allows the 
    programmer to compare values of an expression before and after the 
    executions of the function's body. This mechanism is powerful enough to 
    enable the programmer to express many constraints in the code -- 
    constraints that would otherwise have to be captured at the best only 
    informally by the code documentation.
    @n @n
-#  In addition, using DBC invariants, the programmer can describe what to
    expect from a class and logic dependencies between class's member functions
    and variables. It is the job of the constructor to ensure that the
    invariants are satisfied when the object is first created. Then the 
    implementation of the member functions can be largely simplified as they 
    can be written knowing that the invariants are satisfied as DBC checks them
    before and after the execution of every member function body. Finally, the
    destructor makes sure the invariants hold for the entire object life-cycle
    checking the invariants one last time before destroying the object.
    @n @n
-#  This library automatically extracts the contract assertions and makes
    them integral part of the class source documentation. Because contracts are
    embedded directly into the source code, they are executed and verified at
    run-time so they are always up to date and the related documentation can be
    trusted.
    @n @n
-#  DBC can provide a powerful debugging facility because, if contracts are
    well written, bugs will cause contract assertions to fail exactly where the
    problem first occurs instead that in some later stage of the program in an 
    apparently unrelated manner.
    In general, a precondition failure points to a bug in the class user
    that called one of the member function with invalid parameters. A
    postcondition failure points instead to a bug in the class member 
    function's implementation.
    Furthermore, in case of a contract assertion failure, this library provides
    a detailed log messages that greatly helps debugging.
    @n @n
    @note Of course, if the contract is ill written then DBC is of little use.
        However, it is less likely to have a bug in both the contract and the
        body than in the body only. That is especially true if contracts are 
        kept simple and they only spell out the semantics of the class design 
        via a concise list of assertions. For example, consider the validation 
        of a result in postconditions. Validating the return value might seem
        redundant, but in this case we actually want that redundancy. When
        programmers write a function, there is a certain probability that they
        make an error implementing the function body. When they specify the 
        result of the function in the postconditions, there is also a certain
        probability that they make an error again in writing the contract.
        However, the probability that they make an error twice (in the body and
        the contract) is lower than the probability that the error is made once
        (only in the body).
    @n @n
-#  DBC complements testing because a contract also specify specifies what a 
    test should check. For example, preconditions of a function state which 
    input causes the function to throw (or simply fail) and postconditions
    state which input causes it to exit normally.
    @n @n
-#  DBC can serve to reduce the gap between designer and programmer by
    providing a precise and unambiguous specification language. Moreover,
    contracts can make code reviews easier.
    @n @n
-#  DBC formalizes the overriding mechanism of virtual member 
    functions via the concept of subcontracting. This keeps the base class 
    programmer in control as any derived functions still has to fully 
    satisfy the base class contract. @n
    However, this library leaves it up to the programmer of the derived
    class whether to subcontract the base class or not. The derived class 
    contract clearly states if it is bypassing the base class contract or 
    not but this weakens the benefit listed above -- it is strongly recommend
    to always subcontract when overriding virtual member functions.
    @n @n
-#  DBC assertions replace checks commonly used for
    <em>defensive programming</em> making the code more readable.

@section Costs Costs

The above DBC benefits come to the cost of performance as discussed in detail
in both [@ref Str97] and [@ref Mey97].

The run-time performances are impacted by DBC mainly because of the followings.
-#  The extra processing required to check the assertions.
-#  The extra processing required by the additional function calls
    (additional functions are invoked to check preconditions, 
    postconditions, and invariants).
-#  The extra processing required to copy the object and function
    arguments that were made copyable using @c DBC_COPYABLE()
    or @c dbc::copyable to support the "old" postfix in postconditions.
    
The library implementation tries to minimize the performance impact using
@c inline functions and not compiling at all the parts of the contracts that 
are disabled using @c DBC_CHECK_... .

A reasonable approach is to:
-#  Always write contracts to clarify the semantics of your design embedding
    them directly into the code and its documentation.
-#  Enable preconditions, postconditions, and invariants during early testing.
-#  Enable only preconditions (and possibly invariants) during release testing 
    and in the final program release. (Postconditions are usually more
    expensive to check.)

In reality, you will have to decide based on the performance trade-off required
by your system.

Compile-time performances are also impacted by this library because the library
implementation extensively uses C++ preprocessor and template metaprogramming.
The use of metapgramming turned out to be essential to support the "old"
postfix for non-copyable types and a variable number of function arguments 
without code duplication. Testing showed that the increase in CPU time and 
memory required by the preprocessor is minimal. However, the increase in CPU 
time and memory used by the compiler might be very significant depending on
your program structure. Improving the library implementation to reduce 
compilation-time is an ongoing activity so check future releases of this
library for an hopefully faster compilation of your contracts (these future
implementation optimization will introduce no change in the library public
API).

@note At the moment, C++ compilers are usually not optimized for
    metaprogramming (see [@ref Abr05]). However, the C++ standard committee is 
    considering adding metaprogramming libraries to STL (e.g., type traits).
    This could serve as an incentive for future C++ compiler implementations to
    more efficiently compile metaprograms.

In general, DBC is an essential approach to improve software quality even if it
comes at a performance cost. While performance trade offs should be carefully
considered depending on the application domain, software quality cannot be
sacrificed -- it is difficult to see the value of a system that quickly and
efficiently provides the incorrect output.

@section Other_Approaches Other Approaches

DBC is built into Eiffel [@ref Mey97] and D [@ref Bri04a] programming
languages, and the Digital Mars C++ compiler has it as an extension
[@ref Bri04b]. There are tools for different languages that try to emulate DBC
(notably, @ref iContract for the Java programming language).
See [@ref Ott04] for more information.

At the point when this library was developed, there was no publicly available 
tool for C++ providing all DBC features supported by Effiel. Existing tools
lacked of support for either the "old" postfix in postconditions,
subcontracting, automatic contract documentation, or a combination of the 
above. Therefore this library was developed to provide all Eiffel DBC features
for C++.

The following table compares DBC features among different languages, libraries,
and tools (similar to the comparison presented in [@ref Ott04]). Some level of 
detail is provided on @e how this library implements the listed DBC features.

<table border ="1">
<tr><th rowspan="2">Design By Contract (DBC) Feature
    <th colspan="2">This DBC Library
    <th rowspan="2">Eiffel [@ref Mey97]
    <th rowspan="2">D [@ref Bri04a]
    <th rowspan="2">Proposal to add DBC to C++ [@ref Ott04]
<tr><td><em>Support</em><td><em>Detail</em>
<tr><td><em>Keywords</em>
    <td>Not apply to a library.
    <td>Code-based API (no keywords) follow Eiffel names: @c require(),
        @c ensure(), @c DBC_BODY(), <c>.old</c> (and <c>.now</c>), and 
        @c DBC_INVARIANT().
    <td>@c require, @c ensure, @c do, <c>require else</c>, <c>ensure then</c>, 
        @c old, @c invariant, and @c result.
    <td>@c in, @c out, @c body, @c invariant, and @c assert.
    <td>@c in, @c out, @c do, @c invariant, and @c return.
<tr><td><em>On condition violation</em>
    <td>Throw (by default), terminate, or exit.
    <td>Programmer can select action on violation using @c DBC_ASSERT() and
        @c DBC_ASSERT_STREAM().
    <td>Throw exception.
    <td>Throw exception.
    <td>Terminate (by default), might throw or exit.
<tr><td><em>Return value evaluation</em>
    <td>Yes.
    <td>@c result argument of @c ensure() (only if postconditions compiled
        in object code).
    <td>Yes, @c result keyword.
    <td>No.
    <td>Yes, @c return keyword.
<tr><td><em>Expression copying in postconditions</em>
    <td>Yes.
    <td>For object and function arguments declared @c DBC_COPYABLE() or
        @c dbc::copyable, accessed via <c>.old</c> (only if postconditions
        compiled in object code).
    <td>Yes, @c old keyword.
    <td>No.
    <td>Yes, @c in keyword.
<tr><td><em>Subcontracting</em>
    <td>Yes.
    <td>Use @c DBC_BASE() or @c B template parameter of @c dbc::fun::mem
        (but derived class programmer can decide to subcontract or not,
        recommended to always subcontract).
    <td>Yes.
    <td>Yes.
    <td>Yes.
<tr><td><em>Assertion nameing</em>
    <td>Yes.
    <td>A string passed to @c DBC_ASSERT() and @c DBC_ASSERT_STREAM().
    <td>Yes.
    <td>No.
    <td>No.
<tr><td><em>Arbitrary code in contracts</em>
    <td>Yes.
    <td>But recommended to keep contract code simple, ideally limit it to
        a list of assertions.
    <td>No.
    <td>Yes.
    <td>No.
<tr><td><em>Contract for abstract functions</em>
    <td>Yes.
    <td>When body is defined pure virtual by <c>"= 0;"</c>.
    <td>Yes.
    <td>No.
    <td>Yes.
<tr><td><em>Code ordering</em>
    <td>Order: Preconditions, postconditions, and body.
    <td>For macro-based API only.
    <td>Order: Preconditions, body, and postconditions.
    <td>Order: Preconditions, postconditions, and body.
    <td>Order: Preconditions, postconditions, and body.
<tr><td><em>Static assertions</em>
    <td>Yes.
    <td>Use C++ metaprogramming (e.g., the @ref Boost "Boost.MPL" library).
    <td>No.
    <td>Yes.
    <td>Yes.
<tr><td><em>Prevent contract side-effects</em>
    <td>Yes.
    <td>Use constant (@c const) code block, object @c self, function
        arguments, and @c result to limit unintended contract side
        side-effects.
    <td>Yes.
    <td>No.
    <td>No.
<tr><td><em>Contracts removable from object code</em>
    <td>Yes.
    <td>Compilation and checking of preconditions, postconditions, invariants,
        and any of their combination can be enabled or disabled using the
        @c DBC_CHECK_... macros.
    <td>Not preconditions.
    <td>Yes.
    <td>Only default assertions.
<tr><td><em>Check invariants</em>
    <td>At end of constructors, at beginning and end of member functions, and
        at beginning of destructor (if programmer specifies contracts for
        those).
    <td>E.g., programmer may omit contract for all private member functions
        so their calls will not check invariants. Furthermore, invariant
        checking in destructor is disabled during stack unwinding because of an
        unhandled exceptions (as contracts themselves can throw).
    <td>At end of constructors, at beginning and end of public member
        functions.
    <td>At end of constructors, at beginning and end of public member
        functions, and at beginning of destructor.
    <td>At end of constructors, at beginning and end of public member
        functions, and at beginning of destructor.
<tr><td><em>Disabling assertion checking within assertions</em>
    <td>Yes.
    <td>To prevent infinite recursion when checking contracts.
    <td>Yes.
    <td>No.
    <td>Yes.
<tr><td><em>In nested function calls</em>
    <td>Disable invariants only.
    <td>To prevent infinite recursion when checking contracts.
    <td>Disable all assertions.
    <td>Disable nothing.
    <td>Disable invariants only.
<tr><td><em>Concurrency</em>
    <td>Not yet.
    <td>On roadmap to implement this similarly to Eiffel (i.e., making this
        library thread-safe and supporting waiting conditions).
    <td>Yes (implements waiting conditions).
    <td>No.
    <td>No.
<tr><td><em>Automatic contract documentation</em>
    <td>Yes.
    <td>@ref doxygen is used by default (see @c DBC_CONFIG_DOC_...).
    <td>Yes (contracts are part of the class <em>short form</em>).
    <td>No with existing documentation tools.
    <td>No with existing documentation tools.
</table>

The design of this library was somewhat inspired by:
-   [@ref Mal99] in how to implement optional contract compilation and 
    subcontracting (however because this library uses preprocessor and
    template metaprogramming the actual implementation of these features now
    differs quite a bit from the approach proposed by [@ref Mal99]).
-   [@ref Tan04] in the use of @ref doxygen for automatic contract
    documentation.

<div align="right"><small>
@ref Quick_Start "Previous" | @ref Writing_Contracts "Next"
</small></div>

*/

