/**
 * @file
 * Header file to only include facilities to write contracts using the 
 * macro-based API.
 */

namespace dbc {

/**
 * This macro specifies the base class from which an overriding member function
 * is subcontracting.
 * This macro should only be used with the @a signature argument of the
 * @c DBC_MEM_FUN() contract macro API. When the contract code API
 * @c dbc::fun::mem is used, the @a B template parameter is used instead of
 * this macro.
 * 
 * The given base class must specify a contract for a virtual (or pure virtual) 
 * member function matching the name of the overriding function. Then the
 * overriding function contract will subcontract from the one of base class 
 * function following the DBC @ref Member_Function_Call_Semantics
 * "Member Function Call Semantics". (Of course, the overriding function class
 * type must inherit from the specified base class type as it would normally do
 * in C++.)
 * 
 * In the following example (from 
 * @c "example/DBC_by_Example/NameList/names.hpp"),
 * @c RelaxedNameList inherits from @c NameList, and @c RelaxedNameList::put()
 * subcontracts @c NameList::put():
 * @include "example/DBC_by_Example/NameList/names.hpp"
 * 
 * @param[in] base_class_type The base class type. This class must specify a 
 *  contract for a virtual function with same name as the overriding function.
 * @return Subcontract the overriding function from the function's contract in 
 *  the specified base class. It is used in the @a signature argument of 
 *  @c DBC_MEM_FUN().
 * @see @a B template parameter of @c dbc::fun::mem for same functionality for
 *  contract code API.
 * @see @c "example/DBC_by_Example/Observer/" for an example of subcontracting
 *  a pure virtual member function.
 * @see @c "example/DBC_by_Example/CustomerManager/" for another subcontracting 
 *  example.
 */
#define DBC_BASE(base_class_type)

/**
 * This macro must follow the constructor declaration matching the specified
 * signature and it expands to the contract with the given preconditions, 
 * postconditions, and body.
 * 
 * See the more extensive @c DBC_MEM_FUN() documentation as this documentation
 * @e complements it for constructors.
 * 
 * As a result of the code generated by this macro expansion, every call to the 
 * constructor follows the DBC @ref Constructor_Call_Semantics
 * "Constructor Call Semantics" checking the constructor's contract.
 * The contract specified by this macro is automatically documented.
 * 
 * This macro can also follow special @e initialization member functions
 * named @c init(). Being able to call such @c init() functions with the DBC
 * @ref Constructor_Call_Semantics "Constructor Call Semantics" is necessary
 * for the library when separating constructors declaration and definition to 
 * deal with member initializers (see 
 * @ref Separating_Declaration_and_Definition 
 * "Separating Declaration and Definition"), and also to support emulation of 
 * <em>delegating constructors</em>.
 * 
 * @warning In order to avoid the issues associated with two stage 
 *  initialization (see [@ref Str97]), these @c init() functions should always 
 *  be declared private and invoked only by constructors.
 * 
 * @note If delegating constructors were to be added to future C++ standard
 *  revisions (which seems to be the case [@ref Sut05]), it may be possible to
 *  revisit this library to remove the reliance on the @c init() functions.
 *     
 * For example (from @ref A_Complete_Example):
 * @code
 *  #include <dbc.hpp>
 * 
 *  class str DBC_INHERIT_OBJECT(str) {
 *  public:
 *      static const size_t MAX_SIZE = 16000;
 *  
 *      str(const char* chars): size_(), chars_() // Constructor declaration.
 *      DBC_CONSTRUCTOR( (public) (str)( (const char*)(chars) ), {
 *          // Constructor preconditions.
 *          size_t len = strlen(chars); // Code allowed (but keep it simple).
 *          // Use DBC_ASSERT() or DBC_ASSERT_STREAM() to assert conditions.
 *          DBC_ASSERT(len >= 0 && len < str::MAX_SIZE, "size in range");
 *      }, {
 *          // Constructor postconditions.
 *          DBC_ASSERT(self.now.size() == strlen(chars.now), "size set");
 *          DBC_ASSERT(strcmp(self.now.chars_, chars.now) == 0, "chars set");
 *      }, {
 *          // Constructor body.
 *          size_ = strlen(chars);
 *          chars_ = new char[size_ + 1];
 *          strcpy(chars_, chars);
 *      })
 *      
 *  private:
 *      size_t size_;
 *      char* chars_;
 *      ...
 *  };
 * @endcode
 * Or, equivalently but separating constructor declaration and definition using
 * the @c init() function:
 * @todo Rework this example with actual copy constrcutor of str.
 * @code
 *  #include <dbc.hpp>
 *  
 *  class str DBC_INHERIT_OBJECT(str) {
 *  public:
 *      static const size_t MAX_SIZE = 16000;
 *      
 *      // Constructor deals with member initializers
 *      str(const char* chars): size_(), chars_() { // Member initializers...
 *          // ...then just call init (with DBC Constructor Call Semantics).
 *          init(chars);
 *      }
 *      
 *  private: // init() should be private and invoked by constructor only.
 *      // DBC_CONSTRUCTOR can be used for special init functions.
 *      void init(const char* chars) // Function declaration.
 *      DBC_CONSTRUCTOR( (public) (str)( (const char*)(chars) ), {
 *          // Constructor preconditions.
 *          size_t len = strlen(chars); // Code allowed (but keep it simple).
 *          // Use DBC_ASSERT() or DBC_ASSERT_STREAM() to assert conditions.
 *          DBC_ASSERT(len >= 0 && len < str::MAX_SIZE, "size in range");
 *      }, {
 *          // Constructor postconditions.
 *          DBC_ASSERT(self.now.size() == strlen(chars.now), "size set");
 *          DBC_ASSERT(strcmp(self.now.chars_, chars.now) == 0, "chars set");
 *      }, ;) // ';' separates declaration and definition.
 *      
 *      size_t size_;
 *      char* chars_;
 *      ...
 *  };
 *  
 *  // But member initializers are handled by constructor declaration.
 *  str::DBC_BODY(init)(const char* chars) { // Definition.
 *      // Constructor body.
 *      size_ = strlen(chars);
 *      chars_ = new char[size_ + 1];
 *      strcpy(chars_, chars);
 *  }
 * @endcode
 * 
 * @param[in] signature C++ preprocessor sequence of tokens matching the
 *  constructor declaration with the following syntax: @n
 *  @n <c>
 *  <em>{</em>(public) <em>||</em> (protected) <em>||</em> (private)<em>}</em>
 *  <em>[</em>(template)<em>]</em> (class_type)(
 *  <em>{[</em>DBC_COPYABLE<em>]</em>(argument_type)(argument_name)<em>}*</em>
 *  )
 *  </c> @n @n
 *  Comparing this @a signature syntax with the one of @c DBC_MEM_FUN() note:
 *  -   The absence of <c>(virtual)</c> as constructors cannot be virtual.
 *  -   The absence of <c>(result_type)</c> as constructors do not return
 *      any type.
 *  -   The absence of @c DBC_COPYABLE for @c class_type as before the body
 *      execution there is no object so @c self.old is never available in 
 *      postconditions.
 *  -   The absence of @c DBC_BASE(base_class_type) as C++ will
 *      automatically call the base class constructor contract (if there is
 *      one) as part of the object construction mechanism, with no need for 
 *      explicit subcontracting.
 *  -   The absence of @c function_name as the constructor name is inferred 
 *      from @c class_type.
 *  -   The absence of <c>(const)</c> as constructors can never be constant 
 *      member functions since they construct the object.
 * @param[in] preconditions A code block <c>{...}</c> listing the constructor
 *  preconditions. The following variables are available in this code block
 *  (see @c dbc::fun::constr::require()): @c argument_name. (@c self is not
 *  available because there is no object before the constructor body is 
 *  executed.) @n
 *  Limit this code to a simple list of assertions using @c DBC_ASSERT() and
 *  @c DBC_ASSERT_STREAM().
 * @param[in] postconditions A code block <c>{...}</c> listing the constructor
 *  postconditions. The following variables are available in this code block
 *  (see @c dbc::fun::constr::ensure()):
 *  @c self.now, @c argument_name.now, @c argument_name.old (if
 *  relative @c argument_type was declared copyable). (@c self.old is not
 *  available because there was no object before the constructor body
 *  execution, @c result is not available because constructors do not return
 *  any value.) @n
 *  Limit this code to a simple list of assertions using @c DBC_ASSERT() and
 *  @c DBC_ASSERT_STREAM().
 * @param[in] body A code block <c>{...}</c> listing the constructor body
 *  definition. Use @c ; (and @c init()) when the function definition is 
 *  separate from its declaration.    
 * @return This macro expands to the constructor contract. Preconditions, 
 *  postconditions, and invariants optional compilation is controlled by the
 *  @c DBC_CHECK_REQUIRE, @c DBC_CHECK_ENSURE, and @c DBC_CHECK_INVARIANT
 *  compile-time symbols.
 * @see Different macros @c DBC_DESTRUCTOR() and @c DBC_MEM_FUN() need to be 
 *  used for destructor and member function contracts because of their
 *  different DBC call semantics.
 * @see @c DBC_INVARIANT() to specify class invariants.
 */
#define DBC_CONSTRUCTOR(signature, precondtions, postconditions, body)

/**
This macro must follow the destructor declaration matching the specified 
signature and it expands to the contract with the body.

See the more extensive @c DBC_MEM_FUN() documentation as this documentation
@e complements it for destructors.

As a result of the code generated by this macro expansion, every call to
destructor follows the DBC @ref Destructor_Call_Semantics
"Destructor Call Semantics" checking the class invariant (destructors have no
preconditions and postconditions). The contract specified by this macro is
automatically documented.

@note The C++ Standard Template Library (STL) exception safety rules require 
destructors to never throw exceptions. To comply with this STL requirement,
if the class invariant is violated while the destrcutor contract is checked,
no exception will be thrown and @c dbc::broken_destructor_invariant() will be
invoked instead (this function can be redefined by the user, it terminates
by default). Furthermore, if the destructor is invoked during stack unwinding
due to an unhandled exception then an invariant violation while checking the
destructor contract will simply be ignored (no exception will be thrown,
@c dbc::broken_destructor_invariant() will @e not be invoked, and only a
warning message will be logged).

For example (from @ref A_Complete_Example):
@code
#include <dbc.hpp>

class str DBC_INHERIT_OBJECT(str) {
public:
    virtual ~str() // Destructor declaration.
    DBC_DESTRUCTOR( (public) (virtual) (str)(), { // No pre/post-conditions.
        // Destructor body (only check invariant at entry).
        delete[] chars_; // Invariant already checked chars_ != 0.
    })
    
private:
    char* chars_;
    ...
};
@endcode

@param[in] signature C++ preprocessor sequence of tokens matching the
    destructor declaration with the following syntax: @n
    @n <c>
    <em>{</em>(public) <em>||</em> (protected) <em>||</em> (private)<em>}</em>
    <em>[</em>(virtual)<em>]</em>
    <em>[</em>(template)<em>]</em> (class_type)()
    </c> @n @n
    Comparing this @a signature syntax with the one of @c DBC_MEM_FUN() note:
    -   The absence of <c>(result_type)</c> as destructors do not return
        any type.
    -   The absence of @c DBC_COPYABLE for @c class_type as destructors
        have no postconditions.
    -   The absence of @c DBC_BASE(base_class_type) as C++ will 
        automatically call the base class destructor contract (if there is one)
        as part of the object destruction mechanism, with no need for explicit
        subcontracting.
    -   The absence of @c function_name as the destructor name is inferred 
        from @c class_type.
    -   The absence of <c>argument_type</c> and <c>argument_name</c> as
        destructors have no arguments.
    -   The absence of <c>(const)</c> as destructors can never be constant 
        member functions since they destroy the object.
@param[in] body A code block <c>{...}</c> listing the destructor body
    definition. Use @c ; (and @c DBC_DESTRUCTOR_BODY()) when function
    definition is separate from its declaration.
@return This macro expands to the destructor contract. Invariants optional
    compilation is controlled by @c DBC_CHECK_INVARIANT compile-time symbol.
@see Different macros @c DBC_CONSTRUCTOR() and @c DBC_MEM_FUN() need to be used
    for constructor and member function contracts because of their different
    DBC call semantics.
@see @c DBC_INVARIANT() to specify class invariants.
*/
#define DBC_DESTRUCTOR(signature, body)

/**
This macro must follow the member function declaration matching the
specified signature and it expands to the contract with the given
preconditions, postconditions, and body.
As a result of the code generated by this macro expansion, every call to
the member function follows the DBC @ref Member_Function_Call_Semantics
"Member Function Call Semantics" checking the function's contract.
The contract specified by this macro is automatically documented (see @ref Automatic_Contract_Documentation).

For example (from @ref A_Complete_Example):
@code
#include <dbc.hpp>

class str DBC_INHERIT_OBJECT(str) {
public:
    // No (virtual), (template), DBC_COPYABLE, DBC_BASE(...), and no args.
    size_t size() const // Member function declaration.
    DBC_MEM_FUN( (public) (size_t) (str) (size)() (const), {
        // Preconditions here (keep it simple).
        // No preconditions in this case.
    }, {
        // Postconditions here (keep it simple).
        DBC_ASSERT(result == self.now.size_, "returning size");
    }, {
        // Body definition here.
        return size_;
    })

private:
    size_t size_;
    ...
};
@endcode

@param[in] signature A C++ preprocessor sequence of tokens (see @ref Boost
    "Boost.Preprocessor" sequences) matching the member function declaration
    with the following syntax: @n
    @n <c>
    <em>{</em>(public) <em>||</em> (protected) <em>||</em> (private)<em>}</em>
    <em>[</em>(virtual)<em>]</em> (result_type)
    <em>[</em>(template)<em>]
    </em><em>[</em>DBC_COPYABLE<em>]</em>(class_type)<em>[</em><c>DBC_BASE(base_class_type)</c><em>]</em>
    (function_name)(
    <em>{[</em>DBC_COPYABLE<em>]</em>(argument_type)(argument_name)<em>}*</em>
    ) <em>[</em>(const)<em>]</em>
    </c> @n @n
    Where all parenthesis <c>()</c> are mandatory, spaces are optional, and:
    @arg <c><em>expression1 || expression2</em></c> indicates that either
        <c>@e expression1</c> or <c>@e expression2</c> can be specified.
    @arg <c><em>{expression}</em></c> indicates the result of the enclosed
        <c>@e expression</c>. For example, <c><em>{</em>(public) <em>||</em> (protected) <em>||</em> (private)<em>}</em></c>
        indicates that either <c>(public)</c>, <c>(protected)</c>, or
        <c>(private)</c> can be specified.
    @arg <c><em>[expression]</em></c> indicates that <c>@e expression</c> is
        optional. For example, <c><em>[</em>DBC_COPYABLE<em>]</em></c>
        indicates that either <c>DBC_COPYABLE</c> or nothing (no token) can be
        specified.
    @arg <c><em>{expression}*</em></c> indicates that <c>@e expression</c> can
        be repeated an arbitrary number of times specifing different tokens or
        it can be omitted (i.e., it can be repeated 0, 1, 2, ... times).
        For example, <c>( <em>{</em>(argument_type)
        (argument_name)<em>}*</em> )</c> 
        indicates that either <c>()</c> (repeated 0 times),
        or <c>( (argument0_type)(argument0_name) )</c>
        (repeated 1 time), or <c>( (argument0_type)(argument0_name)
        (argument1_type)(argument1_name) )</c> (repeated 2 times), etc
        can be specified.
    @arg @c result_type is the member function return type.
    @arg @c class_type is the member function class type. The class type
        must inherit (privately) from dbc::object (see @c DBC_INHERIT_OBJECT())
        and must have an invariant (see @c DBC_INVARIANT()).
    @arg @c base_class_type is the base class from which the member
        function is being derived using @c DBC_BASE() (only required when
        @ref Subcontracting "subcontracting").
    @arg @c function_name is the member function name. This must be a valid
        C++ preprocessor token name so operator symbols cannot be used; spell
        the operator name instead. For example, @c operator== cannot be used
        because the @c == symbol is not a valid preprocessor token name but you
        can use an arbitrary name (with no symbols) like @c operator_equal
        instead (when separating definitions from declaration, this same name
        has to be passed to @c DBC_OPERATOR_BODY()).
    @arg @c argument_type is the argument type (can be omitted or repeated
        up to <c>DBC_CONFIG_MAX_ARGC - 1</c> times for multiple arguments).
    @arg @c argument_name is the argument name (can be omitted or repeated
        up to <c>DBC_CONFIG_MAX_ARGC - 1</c> times for for multiple arguments).

    The syntax of \a signature is defined to follow the C++ member function
    declaration syntax as much as possible (e.g., you first indicate the access
    level, then virtual, class follow by function names, then argument, etc).
    This way of expressing function signatures using C++ preprocessor token
    sequences might seems unfamiliar at first but, in our experience, you will
    quickly get used to it with a just little practice. The numerous examples
    distributed with the library illustrate how to use this syntax for
    templates, operators, virtual functions, etc (see the code in the
    @c "example/" directory).
@param[in] preconditions A code block <c>{...}</c> listing the member
    function preconditions. The following variables are available in this code
    block (see @c dbc::fun::mem::require()):
    @arg @c self is a constant reference <c>const&</c> to the object (of type
        @c class_type).
    @arg @c argument_name is a constant reference to the named argument.

    @c DBC_ASSERT() and @c DBC_ASSERT_STREAM() can be used to assert
    conditions in this code block. General code is allowed in this code block 
    but it is strongly recommended to limit it to a @e simple list of
    assertions (otherwise it is likely that the contract will have more bugs
    than the code it is checking).
@param[in] postconditions A code block <c>{...}</c> listing the member
    function postconditions. The following variables are available in this code
    block (see @c dbc::fun::mem::ensure()):
    @arg @c self.now is a constant reference to the current object value (after
        the body execution).
    @arg @c self.old is a constant reference to the object value before the
        body execution. This is available only if the class type was declared
        copyable in \a signature using <c>DBC_COPYABLE(class_type)</c>.
    @arg @c argument_name.now is a constant reference to the named
        argument current value (after the body execution).
    @arg @c argument_name.old is a constant reference to the named
        argument value before the body execution. This is available only if the
        relative argument type was declared copyable in \a signature using
        <c>DBC_COPYABLE(argument_type)</c>.
    @arg @c result is a constant reference to the value being returned. This is
        available only for non-void functions (i.e., if @c result_type was
        not declared @c void in \a signature).

    @c DBC_ASSERT() and @c DBC_ASSERT_STREAM() can be used to assert
    conditions in this code block. General code is allowed in this code block 
    but it is strongly recommended to limit it to a @e simple list of
    assertions (otherwise it is likely that the contract will have more bugs
    than the code it is checking).
@param[in] body A code block <c>{...}</c> listing the member function body
    definition. Use @c ; (and @c DBC_BODY()) when the function definition is 
    separate from its declaration (see @ref 
    Separating_Declaration_and_Definition). Use <c>= 0;</c> for pure virtual
    functions (see @ref Subcontracting).
@return This macro expands to the member function contract.
    If preconditions/postconditions are not checked
    (<c>DBC_CHECK_REQUIRE</c>/<c>DBC_CHECK_ENSURE</c> symbols are not defined
    at compile-time), the preconditions/postconditions code block will not be
    part of the macro expansion so it will not be compiled and checked.
    If no preconditions, no postconditions, and no invariants are checked
    (@c DBC_CHECK_REQUIRE, @c DBC_CHECK_ENSURE, and @c DBC_CHECK_INVARIANT are
    all not defined), this macro trivially expands to just the body code block 
    and no contract code is compiled and checked.
    See @ref Optional_Contract_Compilation.
@see Different macros @c DBC_CONSTRUCTOR() and @c DBC_DESTRUCTOR() need to be 
    used for constructor and destructor contracts because of their different
    DBC call semantics.
@see @c DBC_INVARIANT() to specify class invariants.
*/
#define DBC_MEM_FUN(signature, preconditions, postconditions, body)

} // namespace dbc


