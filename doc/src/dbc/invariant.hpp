/**
 * @file
 * Header file to only include facilities to write class invariants.
 */

/**
 * This symbol expands to the name of the class invariant function.
 * This can be used to manually write the invariant function code therefore
 * avoiding to use @c DBC_INVARIANT(). This library will internally call
 * a function named @c DBC_INVARIANT_FUN with a single argument of the correct
 * class type (the object) to check the class invariant.
 * 
 * @warning Explaining @c DBC_INVARIANT_FUN might be useful to better 
 *  understand how the library internally works, but it is <b>strongly
 *  recommended to use </b>
 * @c DBC_INVARIANT() instead of @c DBC_INVARIANT_FUN because:
 * -#   @c DBC_INVARIANT_FUN reduces code readability.
 * -#   @c DBC_INVARIANT_FUN requires the programmer to write more code to
 *      handle the <c>\#ifdef DBC_...</c> compilation guard increasing the
 *      possibility of errors.
 * -#   Only @c DBC_INVARIANT() automatically documents the invariants.
 * -#   Only @c DBC_INVARIANT() checks at compile time for incorrect use of the 
 *      library (e.g., makes sure that the specified class type inherits from
 *      @c dbc::object).
 * 
 * The @c DBC_INVARIANT() macro expands to an inline friend void function named
 * by @c DBC_INVARIANT_FUN with the specified invariants code block as its
 * definition and taking a constant reference to the object as single argument.
 * For example:
 * @code
 *  #include <dbc.hpp>
 *  
 *  class C DBC_INHERIT_OBJECT(C) { // Recommended form.
 *      ...
 *  private:
 *      DBC_INVARIANT(C, {
 *          ... // Assert C's invariants here.
 *      })
 *  };
 * @endcode
 * is essentially equivalent to:
 * @code
 *  #include <dbc.hpp>
 *  
 *  class C DBC_INHERIT_OBJECT(C) { // Equivalent code form (not recommended).
 *      ...
 *  private:
 *  #ifdef DBC_CHECK_INVARIANT
 *      friend inline void DBC_INVARIANT_FUN(const C& self) {
 *          ... // Assert C's invariants here.
 *      }
 *  #endif // DBC_CHECK_INVARIANT
 *  };
 * @endcode
 * (The correct function is selected via function overloading resolution based
 * on the class type function argument.)
 * @return If the @c DBC_CHECK_INVARIANT symbol is not defined at compile-time, 
 *  this macro expands to nothing. Otherwise, it expands to the name of the 
 *  function internally invoked by the library to check class invariants. (The
 *  actual name of the invariant function is implementation specific it should
 *  be referred to via this macro.)
 */
#define DBC_INVARIANT_FUN

/**
 * This macro must be used within the class declaration and it specifies the 
 * invariants for the given class.
 * 
 * As a result of the code generated by this macro expansion, the specified
 * class invariants are checked by calls to the class constructors, destructor,
 * and member functions (if they have a contract) following the DBC
 * @ref Constructor_Call_Semantics "call semantics".
 * The invariants specified by this macro are automatically documented (see
 * @ref Automatic_Contract_Documentation).
 * 
 * @remark It is recommended to use this macro at the very end of the class 
 *  declaration and within a session with private access level. This is to make
 *  it clear that the code generated by this macro is not part of the public
 *  API of the class.
 * 
 * For example (from @ref A_Complete_Example):
 * @code
 *  #include <dbc.hpp>
 *  
 *  class str DBC_INHERIT_OBJECT(str) {
 *  public:
 *      static const size_t MAX_SIZE = 16000;
 *      ...
 *  private:
 *      size_t size_;
 *      char* chars_;
 *      ...
 *      
 *      DBC_INVARIANT(str, {  // At the very end and in a private section.
 *          // Invariants.
 *          DBC_ASSERT(self.chars_ != 0, "chars exist");
 *          DBC_ASSERT(self.size_ >= 0 && self.size_ < str::MAX_SIZE,
 *                  "size in range");
 *          // Assertions above passed, chars_[size_] can be accessed.
 *          DBC_ASSERT(self.chars_[self.size_] == '\0', "null-terminated");
 *      })
 *  };
 * @endcode
 * @param[in] full_class_type The fully qualified class type. This class is 
 *  <em>fully qualified</em> as it must indicate the full namespace (if
 *  declared within a namespace) and all the template parameters (for template
 *  classes). Furthermore, the class type must inherit from @c dbc::object
 *  (see @c DBC_INHERIT_OBJECT()). For example:
 *  @code
 *      namespace n {
 *          
 *      template<typename T>
 *      class C DBC_INHERIT_OBJECT(C<T>) { // Must inherit from dbc::object.
 *      ...
 *      private:
 *          // Both namespace 'n' and template parameter 'T' are specified.
 *          DBC_INVARIANT(n::C<T>, { // Fully qualified class type.
 *              ... // Invariants here.
 *          })
 *      };
 *          
 *      } // namespace n
 *  @endcode
 *  (This is different from the @c class_type parameter used by other
 *  macros which does not require full qualification.)
 * @param[in] invariants A code block <c>{...}</c> listing the class invariants.
 *  The following variables are available in this code block:
 *  @arg @c self is a constant reference <c>const&</c> to the object (of type
 *      @c full_class_type).
 * 
 *  @c DBC_ASSERT() and @c DBC_ASSERT_STREAM() can be used to assert
 *  conditions in this code block. General code is allowed in this code block 
 *  but it is strongly recommended to limit it to a @e simple list of
 *  assertions (otherwise it is likely that the contract will have more bugs
 *  than the code it is checking).
 *  @remark Invariants should use public members as much as possible so the
 *      contracts will be implementation independent. However, invariants
 *      are also used to check the correctness of the implementation and
 *      sometimes they must access the private or protected members.
 * @return This macro expands to the class invariants. If the
 *  @c DBC_CHECK_INVARIANT symbol is not defined at compile-time, this macro 
 *  trivially expands to nothing, and no invariant code is compiled and
 *  checked.
 * @see @c DBC_CONSTRUCTOR(), @c DBC_DESTRUCTOR(), and @c DBC_MEM_FUN() to
 *  specify member contracts.
 * @see Use @c DBC_MPARAM() if @a full_class_type is a template with more than
 *  one parameter.
 * @see Use @c DBC_INVARIANT_FUN to directly write the invariant code bypassing
 *  this macro (not recommended).
 */
#define DBC_INVARIANT(full_class_type, invariants)

