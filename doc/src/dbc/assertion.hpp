/**
 * @file
 * Header file to only include facilities for assertions.
 */

namespace dbc {

/**
 * Assert the specified condition, intended to be used to assert preconditions,
 * postconditions, and invariants.
 * This macro expands to code that uses @c dbc::assertion to assert the 
 * specified condition with the specified label. The macros @c __FILE__ and 
 * @c __LINE__ are automatically used to indicate the location of the
 * assertion, and the condition's code is used for the description message.
 * Furthermore, the assertion generated by this macro is automatically
 * documented (see @ref Automatic_Contract_Documentation).
 * 
 * In case the asserted condition is false, this macro will either throw a
 * @c dbc::condition_violation exception (default), call C++ @c ::exit(), or
 * call C++ @c std::terminate() depending on the value of
 * @c DBC_CONFIG_DEFAULT_ON_ASSERTION_VIOLATION.
 * 
 * For an example (from @ref A_Complete_Example):
 * @code
 *  #include <dbc.hpp>
 *  
 *  class str DBC_INHERIT_OBJECT(str) {
 *  public:
 *      char& operator[](const size_t& index)
 *      DBC_MEM_FUN( (public) (char&) DBC_COPYABLE(str)
 *              (operator_at)( (const size_t&)(index) ), {
 *          // Member function preconditions.
 *          DBC_ASSERT(index >= 0 && index < self.size(), "index in range");
 *      }, {
 *          // Member function postconditions.
 *          // Not a const mem fun, use 'self.old' for object before body.
 *          DBC_ASSERT(result == self.old.chars_[index.now],
 *                  "returning char at index");
 *      }, {
 *          // Member function body.
 *          return chars_[index];
 *      })
 *      
 *  private:
 *      char* chars_;
 *      ...
 *  };
 * @endcode
 * 
 * @note This macro is mainly used for convenience to avoid repeating
 *  @c __FILE__ and @c __LINE__, avoid writing the <c>\#ifdef DBC</c> guard
 *  by hand, and to support automatic contract documentation. It is recommended
 *  to use this macro instead of using @c dbc::assert directly. For example:
 *  @code
 *      #include <dbc.hpp>
 *      ...
 *      
 *      DBC_ASSERT(1 < 2, "1 less than 2")
 *  @endcode
 *  is essentially equivalent to
 *  @code
 *      #include <dbc.hpp>
 *      ...
 * 
 *      #ifdef DBC
 *      dbc::assert(1 < 2, "1 less than 2", __FILE__, __LINE__,
 *              "1 < 2").raise();
 *              // or .exit(1), or .terminate() depending on
 *              // DBC_CONFIG_DEFAULT_ON_ASSERTION_VIOLATION.
 *      #endif // DBC
 *  @endcode
 *     
 * @param[in] condition A C++ expression that evaluates to a @c bool value.
 * @param[in] label A C++ @c std::string @e shortly describing the assertion in
 *  a human readable form.
 * @return If preconditions, postconditions, or invariants are checked
 *  (@c DBC_CHECK_REQUIRE_, @c DBC_CHECK_ENSURE, or @c DBC_CHECK_INVARIANT
 *  symbols are defined at compile-time), this macro expands to code that 
 *  assert the specified condition using from @c dbc::assertion. Otherwise,
 *  this macro expands to nothing.
 * @see To specify the action to take on condition violation, use
 *  @c DBC_ASSERT_STREAM().
 * @see Use @c DBC_CONFIG_ENABLE_THROWING_ASSERTIONS,
 *  @c DBC_CONFIG_ENABLE_EXITION_ASSERTIONS,
 *  @c DBC_CONFIG_ENABLE_TERMINATING_ASSERTIONS to enable or disable run-time
 *  checking of assertions that throw, exit, or terminate respectively.
 */
#define DBC_ASSERT(condition, label)

/**
 * Assert the specified condition allowing to indicate the action to take in
 * case the condition is false, intended to be used to assert preconditions,
 * postconditions, and invariants.
 * This macro expands to code that uses @c dbc::assertionstream to assert the 
 * specified condition with the specified label. The macros @c __FILE__ and
 * @c __LINE__ are automatically used to indicate the location of the assertion,
 * and the condition's code is used for the description message. Furthermore, 
 * the assertion generated by this macro is automatically documented (see
 * @ref Automatic_Contract_Documentation).
 * 
 * In case the asserted condition is false, this macro will execute the
 * specified @a stream_error code expression. In this code expression, the
 * @c dbc::assertionstream object can be accessed via the declared local
 * variable @c err automatically declared by the macro. The @a stream_error can
 * be used to specify a more descriptive error message (printing variable
 * values, etc) and also to specify the action to take in case of assertion
 * violation using @c dbc::raise, @c dbc::uraise, @c dbc::exit, or
 * @c dbc::terminate. If no action is taken by @a stream_error, the default
 * action specified by @c DBC_CONFIG_DEFAULT_ON_ASSERTION_VIOLATION is taken.
 * 
 * For an example (adapted from @ref A_Complete_Example):
 * @code
 *  #include <dbc.hpp>
 *  #include <stdexcept>
 *  
 *  class str DBC_INHERIT_OBJECT(str) {
 *  public:
 *      char& operator[](const size_t& index)
 *      DBC_MEM_FUN( (public) (char&) DBC_COPYABLE(str)
 *              (operator_at)( (const size_t&)(index) ), {
 *          // Member function preconditions.
 *          // Log detailed error message and throw user defined exception.
 *          DBC_ASSERT_STREAM(index >= 0 && index < self.size(),
 *                  "index in range", err << "index " << index
 *                  << " not in range [0, " << self.size() << ")"
 *                  << dbc::uraise<std::out_of_range>(
 *                  std::out_of_range(err.str()));
 *      }, {
 *          ... // Member function postconditions.
 *      }, {
 *          ... // Member function body.
 *      })
 *  
 *      ...
 *  };
 * @endcode
 * Similarly:
 * @code
 *  #include <dbc.hpp>    
 *  ...
 *  
 *  const int count = -1;
 *  // On violation do as from DBC_CONFIG_DEFAULT_ON_ASSERTION_VIOLATION.
 *  DBC_ASSERT(count > 0, "count positive");
 *  // Same action as above but prints count in error message.
 *  DBC_ASSERT_STREAM(count > 0, "count positive",
 *          err << "count " << count << " negative");
 *  // Throws dbc::condition_violation and prints count in error message.
 *  DBC_ASSERT_STREAM(count > 0, "count positive",
 *          err << "count " << count << " negative" << dbc::raise());
 *  // Throws user's defined int(-1) exception.
 *  DBC_ASSERT_STREAM(count > 0, "count positive",
 *          err << dbc::uraise<int>(int(count)));
 *  // Exits with code 5.
 *  DBC_ASSERT_STREAM(count > 0, "count positive", err << dbc::exit(5));
 *  // Terminates.
 *  DBC_ASSERT_STREAM(count > 0, "count positive", err << dbc::terminate());
 * @endcode
 * 
 * @param[in] condition A C++ expression that evaluates to a @c bool value.
 * @param[in] label A C++ @c std::string @e shortly describing the assertion in
 *  a human readable form.
 * @param[in] stream_error A code expression where the @c dbc::assertionstream
 *  object can be accessed via the local variable @c err.
 * @return If preconditions, postconditions, or invariants are checked
 *  (@c DBC_CHECK_REQUIRE_, @c DBC_CHECK_ENSURE, or @c DBC_CHECK_INVARIANT
 *  symbols are defined at compile-time), this macro expands to code that 
 *  assert the specified condition using from @c dbc::assertionstream.
 *  Otherwise, this macro expands to nothing.
 * @see If there is no need for a more descriptive error message or to specify
 *  the action to take on condition violation, use the simpler @c DBC_ASSERT().
 * @see Use @c DBC_CONFIG_ENABLE_THROWING_ASSERTIONS,
 *  @c DBC_CONFIG_ENABLE_EXITIONG_ASSERTIONS,
 *  @c DBC_CONFIG_ENABLE_TERMINATING_ASSERTIONS to enable or disable run-time
 *  checking of assertions that throw, exit, or terminate respectively.
 */
#define DBC_ASSERT_STREAM(condition, label, stream_error)

/** 
 * Class to write assertions.
 * Usually, the @c DBC_ASSERT() macro wrapper should be used instead of
 * using this assertion class directly.
 * @code
 *  #include <dbc.hpp>
 *
 *  int main() {
 *      int x = 10;
 *      dbc::assertion(x < 0, "negative x", __FILE__, __LINE__,
 *              "x < 0").exit(200); // Exit with code 200 as x is not negative.
 *      return 0; // Otherwise, would have exited with code 0...
 *  }
 * @endcode
 */
class assertion {
public:
    /** 
     * Construct this assertion.
     * @param[in] condition The boolean condition to assert.
     *  The condition expression is evaluate to @c true or @c false when this
     *  argument is passed.
     * @param[in] label The assertion label (for log messages).
     * @param[in] file The file containing the assertion (for log messages).
     * @param[in] line The line containing the assertion (for log messages).
     * @param[in] code A string with the code generating the asserted
     *  condition (for log messages).
     */
    explicit assertion(const bool& condition = true,
            const std::string& label = "",
            const char* file = "", const int& line = 0,
            const std::string& code = "");

    /** Destroy this assertion. */
    virtual ~assertion();

    /**
     * Set the assertion condition.
     * @param[in] New condition boolean value.
     *  The condition expression is evaluate to @c true or @c false when this
     *  argument is passed.
     */
    virtual void condition(const bool& the_condition);

    /** Return the assertion condition value. */
    virtual bool condition() const;

    /** Set the assertion descriptive label.
     * @param[in] New assertion label.
     */
    virtual void label(const std::string& the_label);
    
    /** Return the assertion descriptive label. */
    virtual std::string label();

    /**
     * Set the file and line containing the assertion.
     * The @c __FILE__ and @c __LINE__ macros can be used for these arguments.
     * @param[in] file The file containing the assertion.
     * @param[in] line The line containing the assertion.
     */
    virtual void at(const char* file, const int& line);

    /**
     * Set the file and line containing the assertion.
     * @param[in] file The file containing the assertion.
     * @param[in] line The line containing the assertion.
     */
    virtual void at(const std::string& file, const int& line);

    /** Return the file containing the assertion. */
    virtual std::string file() const;

    /** Return the line containing the assertion. */
    virtual int line() const;

    /** Set a textual description of the asserting code.
     * @param[in] code Text of asserting code.
     */
    virtual void code(const std::string& the_code);

    /** Return a textual description of the asserted code. */
    virtual std::string code() const;

    /**
     * If the assertion condition is false, throw the specified exception.
     * @tparam E Type of exception to throw. This exception must have a
     *  constructor taking one single string argument in input as the error
     *  description.
     */
    template<typename E> void raise() const;

    /**
     * If the assertion condition is false, throw the specified execption.
     * @tparam E Type of exception to throw.
     * @param[in] exception Exception object to throw. Because the object is
     *  constructed by the user and passed as an argument, this function does
     *  not require any specific constructor for the @a E type.
     */
    template<typename E> void raise(const E& exception) const;

    /** 
     * If the assertion condition is false, exit the program with the specified
     * exit code (calling ::exit()).
     * @param[in] code Exit code.
     */
    void exit(const int& code) const;
    
    /** 
     * If the assertion condition is false, terminate the program (calling 
     * std::terminate()). 
     */
    void terminate() const; 
};

/** 
 * Class to write assertions reporting verbose error messages.
 * Usually, the @c DBC_ASSERT_STREAM() macro wrapper should be used instead of
 * using this output-assertion-stream class directly.
 * @code
 *  #include <dbc.hpp>
 *
 *  int main() {
 *      int x = 10;
 *      dbc::oassertionstream a(x < 0, "negative x", __FILE__, __LINE__,
 *              "x < 0");
 *      // Use as an output stream to report verbose error messages.
 *      a << "x value " << x << " is not negative"; // Error message.
 *      a.exit(200); // Exit with code 200 as x is not negative.
 *      return 0; // Otherwise, would have exited with code 0...
 *  }
 * @endcode
 * @note The name of this class follows the STL convention for
 *  @c std::ostringstream and it stands for output-assertion-stream.
 */
class oassertionstream: public assertion, public std::ostringstream {
public:
    /** 
     * Construct this output-assertion-stream.
     * @param[in] condition The boolean condition to assert.
     *  The condition expression is evaluate to @c true or @c false when this
     *  argument is passed.
     * @param[in] label The assertion label (for log messages).
     * @param[in] file The file containing the assertion (for log messages).
     * @param[in] line The line containing the assertion (for log messages).
     * @param[in] code A string with the code generating the asserted
     *  condition (for log messages).
     */
    explicit oassertionstream(const bool& condition = true,
            const std::string& label = "",
            const char* file = "", const int& line = 0,
            const std::string& code = "");
    
    /** Destroy this output-assertion-stream. */
    virtual ~oassertionstream();
};

/**
 * Modifier to cause an assertion-stream to throw the specified exception.
 * @code
 *  #include <dbc.hpp>
 *
 *  int main() {
 *      int x = 10;
 *      dbc::oassertionstream a(x < 0, "negative x", __FILE__, __LINE__,
 *              "x < 0");
 *      // Throws dbc::condition_violation with specified error message.
 *      a << "x value " << x << " is not negative" << dbc::raise();
 *      return 0; // Otherwise, would have exited with code 0...
 *  }
 * @endcode
 * @tparam E Type of exception to throw. This exception must have a
 *  constructor taking one single string argument in input as the error
 *  description.
 */
template<typename E = condition_violation>
class raise {};

/**
 * Modifier to cause an assertion-stream to throw the specified exception.
 * @code
 *  #include <dbc.hpp>
 *
 *  int main() {
 *      int x = 10;
 *      dbc::oassertionstream a(x < 0, "negative x", __FILE__, __LINE__,
 *              "x < 0");
 *      // Throws an int object of value 10 as the exception.
 *      a << "x value " << x << " is not negative" << dbc::raise(x);
 *      return 0; // Otherwise, would have exited with code 0...
 *  }
 * @endcode
 * @tparam E Type of exception to throw. Because the object to throw is
 *  constructed by the user and passed as an argument, this function does
 *  not require any specific constructor for the @a E type.
 * @note The name stands for "user raise" as a user constructed object is
 *  thrown as the exception.
 */
template<typename E>
class uraise {
public:
    /**
     * Construct this modifier to throw specified exception object.
     * @param[in] exception Exception object to throw.
     */
    explicit uraise(const E& expection);
};

/**
 * Modifier to cause an assertion-stream to exit the program with the specified
 * code.
 * @code
 *  #include <dbc.hpp>
 *
 *  int main() {
 *      int x = 10;
 *      dbc::oassertionstream a(x < 0, "negative x", __FILE__, __LINE__,
 *              "x < 0");
 *      a << "x value " << x << " is not negative" << dbc::exit(200);
 *      return 0; // Otherwise, would have exited with code 0...
 *  }
 * @endcode
 */
class exit {
public:
    /**
     * Construct this modifier to exit with specified code.
     * @param[in] code Exit code to be returned by the program.
     */
    explicit exit(const int& code);
};

/**
 * Modifier to cause an assertion-stream to terminate the program.
 * @code
 *  #include <dbc.hpp>
 *
 *  int main() {
 *      int x = 10;
 *      dbc::oassertionstream a(x < 0, "negative x", __FILE__, __LINE__,
 *              "x < 0");
 *      a << "x value " << x << " is not negative" << dbc::terminate();
 *      return 0; // Otherwise, would have exited with code 0...
 *  }
 * @endcode
 */
class terminate {};

} // namespace dbc

