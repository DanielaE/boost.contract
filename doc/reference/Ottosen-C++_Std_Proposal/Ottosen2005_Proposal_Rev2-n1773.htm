<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0066)http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html -->
<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><HEAD><META http-equiv="Content-Type" content="text/html; charset=UTF-8">

<META name="generator" content="Docutils 0.3.7: http://docutils.sourceforge.net/">
<TITLE>Proposal to add Contract Programming to C++ (revision 2)</TITLE>
<META name="author" content="David Abrahams, Lawrence Crowl, Thorsten Ottosen, James Widman">
<META name="date" content="2005-03-04">
<STYLE type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2004/01/12 02:49:54 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr {
  width: 75% }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

tt {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }
  
pre{
  BORDER-RIGHT: gray 1pt solid;
  PADDING-RIGHT: 2pt;
  BORDER-TOP: gray 1pt solid;
  DISPLAY: block;
  PADDING-LEFT: 2pt;
  PADDING-BOTTOM: 2pt;
  BORDER-LEFT: gray 1pt solid;
  MARGIN-RIGHT: 32pt;
  PADDING-TOP: 2pt;
  BORDER-BOTTOM: gray 1pt solid;
  FONT-FAMILY: "Courier New", Courier, mono; 
  background-color: #EEEEEE; 
}


.keyword{color: #0000FF;}
.identifier{}
.comment{font-style: italic; color: #008000;}
.special{color: #800040;}
.preprocessor{color: #3F007F;}
.string{font-style: italic; color: #666666;}
.literal{/*font-style: italic;*/ color: #000000;}

</STYLE>
<TITLE> </TITLE></HEAD><BODY>
<DIV class="document" id="proposal-to-add-contract-programming-to-c-revision-2">
<H1 class="title">Proposal to add Contract Programming to C++ (revision 2)</H1>
<TABLE class="docinfo" frame="void" rules="none">
<COL class="docinfo-name">
<COL class="docinfo-content">
<TBODY valign="top">
<TR><TH class="docinfo-name">Author:</TH>
<TD>David Abrahams, Lawrence Crowl, Thorsten Ottosen, James Widman</TD></TR>
<TR><TH class="docinfo-name">Contact:</TH>
<TD><A class="first reference" href="mailto:dave@boost-consulting.com">dave@boost-consulting.com</A>, <A class="reference" href="mailto:lawrence.crowl@sun.com">lawrence.crowl@sun.com</A>, <A class="reference" href="mailto:nesotto@cs.aau.dk">nesotto@cs.aau.dk</A>, <A class="last reference" href="mailto:widman@gimpel.com">widman@gimpel.com</A></TD></TR>
<TR class="field"><TH class="docinfo-name">organizations:</TH><TD class="field-body">Boost-Consulting, Sun Microsystems, Dezide Aps, Gimpel Software</TD>
</TR>
<TR><TH class="docinfo-name">Date:</TH>
<TD>2005-03-04</TD></TR>
<TR class="field"><TH class="docinfo-name">Number:</TH><TD class="field-body">WG21/N1773 and J16/05-0033. This proposal is a
revision of paper <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1669.html">n1669</A>.</TD>
</TR>
<TR class="field"><TH class="docinfo-name">Working Group:</TH><TD class="field-body">Evolution</TD>
</TR>
</TBODY>
</TABLE>
<DIV class="abstract topic">
<P class="topic-title first">Abstract</P>
<P>Contract Programming is about providing the programmer with stronger tools 
for expressing correctness arguments directly in the source code. Moreover, the
contracts enable new and powerful optimization opportunities. 
This proposal describes a small assertion sub-language 
that unifies compile-time and run-time assertions.
The benefits 
are among others a higher degree of self-documenting source code,
better design tools, 
and easier debugging and testing.</P>
</DIV>
<DIV class="contents topic" id="table-of-contents">
<P class="topic-title first"><A name="table-of-contents">Table of Contents</A></P>
<UL class="auto-toc simple">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#motivation" id="id34" name="id34">1&nbsp;&nbsp;&nbsp;Motivation</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#the-proposal" id="id35" name="id35">2&nbsp;&nbsp;&nbsp;The proposal</A><UL class="auto-toc">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#assertions" id="id36" name="id36">2.1&nbsp;&nbsp;&nbsp;Assertions</A><UL class="auto-toc">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#static-assertions" id="id37" name="id37">2.1.1&nbsp;&nbsp;&nbsp;Static assertions</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#runtime-assertions" id="id38" name="id38">2.1.2&nbsp;&nbsp;&nbsp;Runtime assertions</A></LI>
</UL>
</LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#keyword-old" id="id39" name="id39">2.2&nbsp;&nbsp;&nbsp;Keyword <TT class="docutils literal"><SPAN class="pre">__old</SPAN></TT></A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#function-pre-and-postconditions" id="id40" name="id40">2.3&nbsp;&nbsp;&nbsp;Function pre- and postconditions</A><UL class="auto-toc">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#virtual-functions" id="id41" name="id41">2.3.1&nbsp;&nbsp;&nbsp;Virtual functions</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#constructors" id="id42" name="id42">2.3.2&nbsp;&nbsp;&nbsp;Constructors</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#function-pointers" id="id43" name="id43">2.3.3&nbsp;&nbsp;&nbsp;Function pointers</A></LI>
</UL>
</LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#class-invariants" id="id44" name="id44">2.4&nbsp;&nbsp;&nbsp;Class invariants</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#namespace-invariants" id="id45" name="id45">2.5&nbsp;&nbsp;&nbsp;Namespace invariants</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#failure-handler-functions" id="id46" name="id46">2.6&nbsp;&nbsp;&nbsp;Failure handler functions</A></LI>
</UL>
</LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#open-issues" id="id47" name="id47">3&nbsp;&nbsp;&nbsp;Open issues</A><UL class="auto-toc">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#how-do-contracts-interact-with-function-try-blocks" id="id48" name="id48">3.1&nbsp;&nbsp;&nbsp;How do contracts interact with function-try-blocks?</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#are-failure-handler-functions-wrongly-specified" id="id49" name="id49">3.2&nbsp;&nbsp;&nbsp;Are failure handler functions wrongly specified?</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#changes-to-the-standard-library" id="id50" name="id50">3.3&nbsp;&nbsp;&nbsp;Changes to the standard library</A></LI>
</UL>
</LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#major-changes-from-n1669" id="id51" name="id51">4&nbsp;&nbsp;&nbsp;Major changes from n1669</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#list-of-proposals-that-could-affect-or-be-affected-by-this-proposal" id="id52" name="id52">5&nbsp;&nbsp;&nbsp;List of proposals that could affect or be affected by this proposal</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#implementability" id="id53" name="id53">6&nbsp;&nbsp;&nbsp;Implementability</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#list-of-examples" id="id54" name="id54">7&nbsp;&nbsp;&nbsp;List of examples</A><UL class="auto-toc">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#vector-example-hpp" id="id55" name="id55">7.1&nbsp;&nbsp;&nbsp;vector_example.hpp</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#subcontracting-example-hpp" id="id56" name="id56">7.2&nbsp;&nbsp;&nbsp;subcontracting_example.hpp</A></LI>
</UL>
</LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#comparison-of-contract-programming-in-d-eiffel-and-c" id="id57" name="id57">8&nbsp;&nbsp;&nbsp;Comparison of Contract Programming in D, Eiffel and C++</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#acknowledgements" id="id58" name="id58">9&nbsp;&nbsp;&nbsp;Acknowledgements</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#footnotes" id="id59" name="id59">10&nbsp;&nbsp;&nbsp;Footnotes</A></LI>
</UL>
</DIV>
<DIV class="section" id="motivation">
<H1><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id34" name="motivation">1&nbsp;&nbsp;&nbsp;Motivation</A></H1>
<P>Language support for Contract Programming has several benefits:</P>
<OL class="arabic simple">
<LI>It can remove the need for separation of documentation and implementation <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id21" id="id1" name="id1">[0]</A>.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="2">
<LI>It can enable the compiler to generate faster code <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id22" id="id2" name="id2">[1]</A>.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="3">
<LI>It can make debugging and testing much easier <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id23" id="id3" name="id3">[2]</A>.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="4">
<LI>It can improve communication between designers and programmers in large C++ projects <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id24" id="id4" name="id4">[3]</A>.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="5">
<LI>It can make inheritance easier to use correctly (see <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#subcontracting-example-hpp">subcontracting_example.hpp</A> ).</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="6">
<LI>It can ensure that every programmer understands the contract metaphors <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id25" id="id5" name="id5">[4]</A> .</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="7">
<LI>It might make static analysis tools much more powerful <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id26" id="id6" name="id6">[5]</A>.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="8">
<LI>It will benefit C++'s image as a secure language <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id27" id="id7" name="id7">[6]</A>.</LI>
</OL>
<P>Please refer to <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1613.pdf">n1613</A> for an extensive discussion of these benefits.</P>
<P>Already with the current proposal, it is quite remarkable how much
of an interface that can be documented. For a good example, please
see how <TT class="docutils literal"><SPAN class="pre">std::vector</SPAN></TT> is declared in <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#vector-example-hpp">vector_example.hpp</A>; there is only a small
portion of the specification of <TT class="docutils literal"><SPAN class="pre">std::vector</SPAN></TT> that cannot be described in the 
contracts.</P>
</DIV>
<DIV class="section" id="the-proposal">
<H1><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id35" name="the-proposal">2&nbsp;&nbsp;&nbsp;The proposal</A></H1>
<P>The idea is to extend C++</P>
<UL class="simple">
<LI>function declarations with <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#functionx">pre- and postconditions</A>,</LI>
</UL>
<!--  -->
<UL class="simple">
<LI>class declarations with <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#class-invariants">class invariants</A>,</LI>
</UL>
<!--  -->
<UL class="simple">
<LI>namespace declarations with <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#namespace-invariants">namespace invariants</A>.</LI>
</UL>
<P>These new <EM>contract scopes</EM> can contain <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#assertions">assertions</A> that
may be evaluated either at compiler-time or at
run-time as part of the program to verify their correctness.</P>
<DIV class="section" id="assertions">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id36" name="assertions">2.1&nbsp;&nbsp;&nbsp;Assertions</A></H2>
<P>The basic building blocks of contracts are 
<EM>assertions</EM>. Assertions come in two categories:</P>
<UL class="simple">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#static-assertions">static assertions</A></LI>
</UL>
<!--  -->
<UL class="simple">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#runtime-assertions">runtime assertions</A></LI>
</UL>
<DIV class="section" id="static-assertions">
<H3><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id37" name="static-assertions">2.1.1&nbsp;&nbsp;&nbsp;Static assertions</A></H3>
<P>There are two flavors of <EM>static</EM> assertions:</P>
<OL class="arabic">
<LI><P class="first"><EM>default</EM> assertions</P>
<BLOCKQUOTE>
<DL class="docutils">
<DT>syntax: </DT>
<DD><P class="first last"><EM>static-assertion</EM>: <TT class="docutils literal"><SPAN class="pre">static</SPAN></TT> <EM>constant-expression</EM> <TT class="docutils literal"><SPAN class="pre">:</SPAN></TT> <EM>string-literal</EM> <TT class="docutils literal"><SPAN class="pre">;</SPAN></TT></P>
</DD>
<DT>example: </DT>
<DD><P class="first last"><TT class="docutils literal"><SPAN class="pre">static</SPAN> <SPAN class="pre">is_pod&lt;T&gt;::value</SPAN> <SPAN class="pre">:</SPAN> <SPAN class="pre">"T</SPAN> <SPAN class="pre">must</SPAN> <SPAN class="pre">model</SPAN> <SPAN class="pre">a</SPAN> <SPAN class="pre">POD";</SPAN></TT></P>
</DD>
</DL>
</BLOCKQUOTE>
</LI>
<LI><P class="first"><EM>select</EM> assertions</P>
<BLOCKQUOTE>
<DL class="docutils">
<DT>syntax:</DT>
<DD><OL class="first last arabic simple">
<LI><EM>static-assertion-sequence</EM>: <EM>static-assertion</EM></LI>
<LI><EM>static-assertion-sequence</EM>: <EM>static-assertion</EM> <EM>static-assertion-sequence</EM></LI>
<LI><EM>static-body</EM>: <EM>static-assertion</EM></LI>
<LI><EM>static-body</EM>: <TT class="docutils literal"><SPAN class="pre">{</SPAN></TT> <EM>static-assertion-sequence</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
<LI><EM>static-if-assertion</EM> : <TT class="docutils literal"><SPAN class="pre">if(</SPAN></TT> <EM>constant-expression</EM> <TT class="docutils literal"><SPAN class="pre">)</SPAN></TT> <EM>static-body</EM> <EM>static-else-assertion</EM> <SUB>opt</SUB></LI>
<LI><EM>static-else-assertion</EM> : <TT class="docutils literal"><SPAN class="pre">else</SPAN></TT> <EM>static-body</EM></LI>
</OL>
</DD>
<DT>example:</DT>
<DD><DL class="first last docutils">
<DT><TT class="docutils literal"><SPAN class="pre">if(</SPAN> <SPAN class="pre">is_pod&lt;T&gt;::value</SPAN> <SPAN class="pre">)</SPAN></TT></DT>
<DD><P class="first last"><TT class="docutils literal"><SPAN class="pre">static</SPAN> <SPAN class="pre">sizeof(</SPAN> <SPAN class="pre">T</SPAN> <SPAN class="pre">)</SPAN> <SPAN class="pre">&lt;=</SPAN> <SPAN class="pre">sizeof(</SPAN> <SPAN class="pre">long</SPAN> <SPAN class="pre">)</SPAN> <SPAN class="pre">:</SPAN> <SPAN class="pre">"Only</SPAN> <SPAN class="pre">PODs</SPAN> <SPAN class="pre">smaller</SPAN> <SPAN class="pre">than</SPAN> <SPAN class="pre">long</SPAN> <SPAN class="pre">supported";</SPAN></TT></P>
</DD>
</DL>
</DD>
</DL>
</BLOCKQUOTE>
</LI>
</OL>
<P>The static assertions are exactly like the ones described in <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1617.html">n1617</A>. The 
main difference is that we</P>
<OL class="arabic simple">
<LI>reuse the keyword <TT class="docutils literal"><SPAN class="pre">static</SPAN></TT> instead of adding a new one,</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="2">
<LI>confine the scope of the static assertion to contract scope, and</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="3">
<LI>allow compile-time select statements to avoid duplication of conditions.</LI>
</OL>
</DIV>
<DIV class="section" id="runtime-assertions">
<H3><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id38" name="runtime-assertions">2.1.2&nbsp;&nbsp;&nbsp;Runtime assertions</A></H3>
<P>There are two flavors of <EM>runtime</EM> assertions:</P>
<OL class="arabic">
<LI><P class="first"><EM>default</EM> assertions</P>
<BLOCKQUOTE>
<DL class="docutils">
<DT>syntax:</DT>
<DD><P class="first last"><EM>runtime-assertion</EM> : <EM>boolean-expression</EM> <TT class="docutils literal"><SPAN class="pre">;</SPAN></TT></P>
</DD>
<DT>example:</DT>
<DD><P class="first last"><TT class="docutils literal"><SPAN class="pre">std::cout.good();</SPAN></TT></P>
</DD>
</DL>
</BLOCKQUOTE>
</LI>
<LI><P class="first"><EM>select</EM> assertions</P>
<BLOCKQUOTE>
<DL class="docutils">
<DT>syntax:</DT>
<DD><OL class="first last arabic simple">
<LI><EM>runtime-assertion-sequence</EM> : <EM>runtime-assertion</EM></LI>
<LI><EM>runtime-assertion-sequence</EM> : <EM>runtime-assertion</EM> <EM>runtime-assertion-sequence</EM></LI>
<LI><EM>runtime-body</EM> : <EM>runtime-assertion</EM></LI>
<LI><EM>runtime-body</EM> : <TT class="docutils literal"><SPAN class="pre">{</SPAN></TT> <EM>runtime-assertion-sequence</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
<LI><EM>runtime-if-assertion</EM> : <TT class="docutils literal"><SPAN class="pre">if(</SPAN></TT> <EM>condition</EM> <TT class="docutils literal"><SPAN class="pre">)</SPAN></TT> <EM>runtime-body</EM> <EM>runtime-else-assertion</EM> <SUB>opt</SUB></LI>
<LI><EM>runtime-else-assertion</EM> : <TT class="docutils literal"><SPAN class="pre">else</SPAN></TT> <EM>runtime-body</EM></LI>
</OL>
</DD>
<DT>example:</DT>
<DD><DL class="first last docutils">
<DT><TT class="docutils literal"><SPAN class="pre">if(</SPAN> <SPAN class="pre">empty()</SPAN> <SPAN class="pre">)</SPAN></TT> </DT>
<DD><P class="first last"><TT class="docutils literal"><SPAN class="pre">result</SPAN> <SPAN class="pre">==</SPAN> <SPAN class="pre">end();</SPAN></TT></P>
</DD>
</DL>
</DD>
</DL>
</BLOCKQUOTE>
</LI>
</OL>
<P>The following general points are worth noting:</P>
<OL class="arabic">
<LI><P class="first">Default assertions defaults to calling <TT class="docutils literal"><SPAN class="pre">terminate()</SPAN></TT>, but the behavior can be <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#failure-handler-functions">customized</A>.</P>
<BLOCKQUOTE>
</BLOCKQUOTE>
</LI>
<LI><P class="first">The select assertions remove the need for the implication operator that was discussed in <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1613.pdf">n1613</A>.</P>
</LI>
<LI><P class="first">The syntactic freedom have been kept minimal to ensure a good documentation effect.</P>
</LI>
<LI><P class="first">Wrt. constness, then contract scope behaves as if it was a const member function <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id28" id="id10" name="id10">[7]</A>.</P>
</LI>
<LI><P class="first">If the compiler can determine that an assertion is true, it may choose not to evaluate 
that assertion.</P>
</LI>
<LI><P class="first">If the compiler can determine that an assertion is false, it may choose 
to call the <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#failure-handler-functions">broken contract handler</A> without evaluating that condition.</P>
</LI>
</OL>
<P>It is possible to mix static and runtime assertions. In that case we talk about
assertion sequences:</P>
<BLOCKQUOTE>
<OL class="arabic simple">
<LI><EM>assertion-sequence</EM> : <EM>static-assertion-sequence</EM></LI>
<LI><EM>assertion-sequence</EM> : <EM>runtime-assertion-sequence</EM></LI>
<LI><EM>assertion-sequence</EM> : <EM>assertion-sequence</EM> <EM>assertion-sequence</EM> <SUB>opt</SUB></LI>
</OL>
</BLOCKQUOTE>
</DIV>
</DIV>
<DIV class="section" id="keyword-old">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id39" name="keyword-old">2.2&nbsp;&nbsp;&nbsp;Keyword <TT class="docutils literal"><SPAN class="pre">__old</SPAN></TT></A></H2>
<P>It is very useful to be able to take a copy of a variable to compare
it with other values later. In particular, this is true in <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#function">function postconditions</A>.</P>
<P>Assume <TT class="docutils literal"><SPAN class="pre">i</SPAN></TT> is a visible <TT class="docutils literal"><SPAN class="pre">int</SPAN></TT>, then the compiler translates</P>
<PRE class="literal-block">{
    __old i == 42;
}
</PRE>
<P>into</P>
<PRE class="literal-block">{
    const int __old_i( i );
    __old_i == 42;
}
</PRE>
<P>A set of rules govern how <TT class="docutils literal"><SPAN class="pre">__old</SPAN></TT> behaves within a certain contract:</P>
<OL class="arabic simple">
<LI>If it is applied to the same expression <EM>n</EM> times, that expression need only be
evaluated once and only one copy need to be stored.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="2">
<LI>The copy of its argument is taken <EM>after</EM> the precondition is evaluated.</LI>
</OL>
<P>The precondition should be evaluated first to allow it to report its errors first.
Notice that we can only apply <TT class="docutils literal"><SPAN class="pre">__old</SPAN></TT> to objects of a type that defines a copy-constructor 
taking a <TT class="docutils literal"><SPAN class="pre">const</SPAN></TT> reference (ie., <TT class="docutils literal"><SPAN class="pre">std::auto_ptr</SPAN></TT> cannot be used).</P>
<A class="target" id="function" name="function"></A><A class="target" id="functionx" name="functionx"></A></DIV>
<DIV class="section" id="function-pre-and-postconditions">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id40" name="function-pre-and-postconditions">2.3&nbsp;&nbsp;&nbsp;Function pre- and postconditions</A></H2>
<P>The function declaration and definition
are changed into:</P>
<BLOCKQUOTE>
<BLOCKQUOTE>
<OL class="arabic simple">
<LI><EM>precontracted-function</EM> : <EM>function-head</EM></LI>
<LI><EM>precontracted-function</EM> : <EM>function-head</EM> <EM>precondition-contract</EM></LI>
<LI><EM>postcontracted-function</EM> : <EM>precontracted-function</EM></LI>
<LI><EM>postcontracted-function</EM> : <EM>precontracted-function</EM> <EM>postcondition-contract</EM></LI>
<LI><EM>function-declaration</EM> : <EM>postcontracted-function</EM> <TT class="docutils literal"><SPAN class="pre">;</SPAN></TT></LI>
<LI><EM>function-definition</EM> : <EM>postcontracted-function</EM> <TT class="docutils literal"><SPAN class="pre">{</SPAN></TT> <EM>function-body</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
<LI><EM>precondition-contract</EM> : <TT class="docutils literal"><SPAN class="pre">precondition</SPAN> <SPAN class="pre">{</SPAN></TT> <EM>assertion-sequence</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
<LI><EM>postcondition-contract</EM> : <TT class="docutils literal"><SPAN class="pre">postcondition</SPAN></TT> <EM>return-value-declaration</EM><SUB>opt</SUB> <TT class="docutils literal"><SPAN class="pre">{</SPAN></TT> <EM>assertion-sequence</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
<LI><EM>return-value-declaration</EM>: <TT class="docutils literal"><SPAN class="pre">(</SPAN></TT> <EM>identifier</EM> <TT class="docutils literal"><SPAN class="pre">)</SPAN></TT></LI>
</OL>
</BLOCKQUOTE>
<P>example:</P>
<PRE class="literal-block">double sqrt( double r )
    precondition
    {
        r &gt; 0.;
    }
    postcondition( result )
    {
        equal_within_precision( result * result, r );
    }
</PRE>
</BLOCKQUOTE>
<P>In the <EM>return-value-declaration</EM> we declare a local variable that acts as a <TT class="docutils literal"><SPAN class="pre">const</SPAN></TT> reference to the computed 
return value. It follows that a <EM>return-value-declaration</EM> is illegal if the return type is <TT class="docutils literal"><SPAN class="pre">void</SPAN></TT>.</P>
<P>The following general rules apply:</P>
<OL class="arabic">
<LI><P class="first">If a function has both a declaration and a definition, the contracts must appear on the declaration.</P>
</LI>
<LI><P class="first"><A class="target" id="the-execution-of-a-function" name="the-execution-of-a-function">The execution of a function</A> is now</P>
<BLOCKQUOTE>
<OL class="loweralpha simple">
<LI>evaluate the precondition assertion by assertion in order starting from the top,</LI>
<LI>evaluate <TT class="docutils literal"><SPAN class="pre">__old</SPAN></TT> occurrences in the postcondition,</LI>
<LI>evaluate the function body,</LI>
<LI>evaluate the postcondition assertion by assertion in order starting from the top.</LI>
</OL>
</BLOCKQUOTE>
</LI>
<LI><P class="first">The execution of a member function is now as in 2, but</P>
<BLOCKQUOTE>
<OL class="loweralpha">
<LI><P class="first"><TT class="docutils literal"><SPAN class="pre">2.a</SPAN></TT> is <EM>preceded</EM> by a call to the <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#class-invariants">class invariant</A>,</P>
</LI>
<LI><P class="first"><TT class="docutils literal"><SPAN class="pre">2.d</SPAN></TT> is <EM>preceded</EM> by a call to the class invariant,</P>
<BLOCKQUOTE>
<UL class="simple">
<LI>rationale: the contracts might call public functions in the class which require the invariant to be established.</LI>
</UL>
</BLOCKQUOTE>
</LI>
</OL>
</BLOCKQUOTE>
</LI>
</OL>
<DIV class="section" id="virtual-functions">
<H3><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id41" name="virtual-functions">2.3.1&nbsp;&nbsp;&nbsp;Virtual functions</A></H3>
<P>If the function <TT class="docutils literal"><SPAN class="pre">F</SPAN></TT> is virtual, we must require that</P>
<OL class="arabic simple">
<LI>only the first declaration/definition of <TT class="docutils literal"><SPAN class="pre">F</SPAN></TT> can have a precondition.</LI>
</OL>
<P>Section <TT class="docutils literal"><SPAN class="pre">3.5</SPAN></TT> of <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1613.pdf">n1613</A> explains how little redefinition of preconditions is used. Even though
subcontracting is theoretically sound, it ends up being fairly useless in practice <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id29" id="id14" name="id14">[8]</A>.</P>
<P>Postconditions can be made stronger in a derived class as seen in the <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#subcontracting-example-hpp">subcontracting_example.hpp</A>.
We can summarize the remaining rules for virtual functions as</P>
<OL class="arabic simple" start="2">
<LI>pure virtual functions can have contracts,</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="3">
<LI>postconditions from a function in a base class and the overridden version in a derived class
are <EM>AND</EM>ed together <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id30" id="id15" name="id15">[9]</A>.</LI>
</OL>
<P>The last rule ensures that the function in the derived class has a stronger postcondition <EM>by design</EM>.
A programmer can via a downcast obtain the stronger guarantee, but the runtime check must still
follow rule 3 above.</P>
</DIV>
<DIV class="section" id="constructors">
<H3><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id42" name="constructors">2.3.2&nbsp;&nbsp;&nbsp;Constructors</A></H3>
<P>Constructors behaves much like member functions. This means that a constructor</P>
<OL class="arabic simple">
<LI>can have a precondition and a postcondition,</LI>
</OL>
</DIV>
<DIV class="section" id="function-pointers">
<H3><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id43" name="function-pointers">2.3.3&nbsp;&nbsp;&nbsp;Function pointers</A></H3>
<P>If the address of a function is taken, it holds that</P>
<OL class="arabic simple">
<LI>the precondition is evaluated before the function body when the function is called 
through the function pointer.</LI>
</OL>
<P>Remark: A compiler might be able to determine that the precondition is satisfied, in that case
the compiler may generate a call directly to the function body 
(thus sharing implementation with the function pointer call).</P>
</DIV>
</DIV>
<DIV class="section" id="class-invariants">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id44" name="class-invariants">2.4&nbsp;&nbsp;&nbsp;Class invariants</A></H2>
<P>Within class scope it is possible to define a class invariant:</P>
<BLOCKQUOTE>
<DL class="docutils">
<DT>syntax:</DT>
<DD><OL class="first last arabic simple">
<LI><EM>static-class-invariant</EM> : <TT class="docutils literal"><SPAN class="pre">static</SPAN> <SPAN class="pre">invariant</SPAN> <SPAN class="pre">{</SPAN></TT> <EM>static-assertion-sequence</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
<LI><EM>runtime-class-invariant</EM> : <TT class="docutils literal"><SPAN class="pre">invariant</SPAN> <SPAN class="pre">{</SPAN></TT> <EM>runtime-assertion-sequence</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
</OL>
</DD>
<DT>example: </DT>
<DD>see <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#vector-example-hpp">vector_example.hpp</A></DD>
</DL>
</BLOCKQUOTE>
<P>The class invariant has the following properties:</P>
<OL class="arabic">
<LI><P class="first">It must appear in the declaration of a class.</P>
</LI>
<LI><P class="first">It is inherited in the sense that the invariant of a derived class <EM>implicitly</EM> will have the base-class invariant(s)
<EM>AND</EM>ed to it (see also item 6-7).</P>
<BLOCKQUOTE>
<P>example:</P>
<PRE class="literal-block">struct base { invariant { ... } };
struct derived : base
{
    invariant
    {
        base::invariant(); // implicitly generated
        ...
    }
};
</PRE>
<P>(Remark: the above is pseudo-code.)</P>
</BLOCKQUOTE>
</LI>
<LI><P class="first">It can always be called from within or outside the class as if it was a member function with the declaration <TT class="docutils literal"><SPAN class="pre">void</SPAN> <SPAN class="pre">invariant()</SPAN> <SPAN class="pre">const;</SPAN></TT>.</P>
</LI>
<LI><P class="first">It is called <EM>implicitly</EM> from public</P>
<BLOCKQUOTE>
<OL class="loweralpha simple">
<LI>member functions' <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#function">pre- and postconditions</A>,</LI>
</OL>
<OL class="loweralpha" start="2">
<LI><P class="first">constructors,</P>
<BLOCKQUOTE>
<UL class="simple">
<LI>call the class invariant <EM>before</EM> the postcondition,</LI>
</UL>
</BLOCKQUOTE>
</LI>
<LI><P class="first">destructors,</P>
<BLOCKQUOTE>
<UL class="simple">
<LI>call the class invariant <EM>before</EM> the destructor body.</LI>
</UL>
</BLOCKQUOTE>
</LI>
<LI><P class="first">member functions that exit abnormally via an exception <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id31" id="id17" name="id17">[10]</A></P>
</LI>
</OL>
</BLOCKQUOTE>
</LI>
<LI><P class="first"><A class="target" id="it-is-always-called" name="it-is-always-called">It is always called</A> as if surrounded by a try-catch block:</P>
<PRE class="literal-block">try
{
    class_invariant();
}
catch( ... )
{
    std::class_invariant_broken();
}
</PRE>
</LI>
</OL>
<BLOCKQUOTE>
<UL class="simple">
<LI>rationale: this ensures that exceptions thrown in the invariant cannot escape from functions 
and in particular not from the destructor. <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id32" id="id18" name="id18">[11]</A></LI>
</UL>
</BLOCKQUOTE>
<OL class="arabic" start="6">
<LI><P class="first">For its execution <EM>during</EM> construction <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id33" id="id19" name="id19">[12]</A> holds that:</P>
<BLOCKQUOTE>
<OL class="loweralpha">
<LI><P class="first">each assertion is executed in order starting from the top <EM>excluding</EM> any part inherited,</P>
<BLOCKQUOTE>
<UL class="simple">
<LI>rationale: if we do not exclude inherited parts, those parts would be evaluated multiple times.</LI>
</UL>
</BLOCKQUOTE>
</LI>
</OL>
</BLOCKQUOTE>
</LI>
<LI><P class="first">For its execution <EM>after</EM> construction holds that:</P>
<BLOCKQUOTE>
<OL class="loweralpha simple">
<LI>each assertion is executed in order starting from the top <EM>including</EM> any part inherited,</LI>
<LI>if the class has any sub-classes, then the inherited portion is executed first,</LI>
<LI>if the class has several sub-classes the order of the classes in the base-clause is followed.</LI>
</OL>
</BLOCKQUOTE>
</LI>
</OL>
</DIV>
<DIV class="section" id="namespace-invariants">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id45" name="namespace-invariants">2.5&nbsp;&nbsp;&nbsp;Namespace invariants</A></H2>
<P>To better support global state or namespace state we introduces namespace invariants:</P>
<BLOCKQUOTE>
<DL class="docutils">
<DT>syntax:    </DT>
<DD><OL class="first last arabic simple">
<LI><EM>static-namespace-invariant</EM>: <TT class="docutils literal"><SPAN class="pre">static</SPAN> <SPAN class="pre">invariant</SPAN> <SPAN class="pre">{</SPAN></TT> <EM>static-assertion-sequence</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
<LI><EM>runtime-namespace-invariant</EM>: <TT class="docutils literal"><SPAN class="pre">invariant</SPAN> <SPAN class="pre">{</SPAN></TT> <EM>runtime-assertion-sequence</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
</OL>
</DD>
</DL>
<P>example:</P>
<PRE class="literal-block">namespace foo
{
    int     buffer_size;
    int*    buffer;

    invariant
    {
        buffer_size &gt; 0;
        buffer     != 0;
    }

    static invariant
    {
        static sizeof( int ) &gt;= 4 : "int must be 32 bit"; 
    }
}
</PRE>
</BLOCKQUOTE>
<P>The properties of namespace invariants are:</P>
<OL class="arabic">
<LI><P class="first">they can appear multiple times in the same namespace across multiple translation units,</P>
</LI>
<LI><P class="first">for each translation unit, the present invariants are executed once 
after the static initialization phase, that is, conceptually as the 
last part of the static initialization phase,</P>
</LI>
<LI><P class="first">they are always called as if surrounded by a try-catch block:</P>
<PRE class="literal-block">try
{
    namespace_invariant();
}
catch( ... )
{
    std::namespace_invariant_broken();
}
</PRE>
</LI>
<LI><P class="first">the order of evaluation of the invariants is unspecified,</P>
</LI>
<LI><P class="first">the order of evaluation of the assertions in an invariant is from top to bottom,</P>
</LI>
<LI><P class="first">for any namespace <TT class="docutils literal"><SPAN class="pre">N</SPAN></TT>, <TT class="docutils literal"><SPAN class="pre">N::invariant()</SPAN></TT> executes all invariants from namespace <TT class="docutils literal"><SPAN class="pre">N</SPAN></TT>.</P>
</LI>
</OL>
</DIV>
<DIV class="section" id="failure-handler-functions">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id46" name="failure-handler-functions">2.6&nbsp;&nbsp;&nbsp;Failure handler functions</A></H2>
<P>The default behavior for all default assertions is to call <TT class="docutils literal"><SPAN class="pre">terminate()</SPAN></TT> via a call
to their respective handler. As seen below, we have a handler for each type of contract.
If the default behavior
is undesirable, the standard library provides the following handlers:</P>
<PRE class="literal-block">namespace std
{        
    void precondition_broken();
    void postcondition_broken();
    void class_invariant_broken();
    void namespace_invariant_broken();
    
    typedef void (*broken_contract_handler)();
    
    broken_contract_handler  set_precondition_broken_handler( broken_contract_handler r ) throw();
    broken_contract_handler  set_postcondition_broken_handler( broken_contract_handler r ) throw();
    broken_contract_handler  set_class_invariant_broken_handler( broken_contract_handler r ) throw();
    broken_contract_handler  set_namespace_invariant_broken_handler( broken_contract_handler r ) throw();
}
</PRE>
<P>This should provide plenty of room for customization. The precondition for all the <TT class="docutils literal"><SPAN class="pre">set_XX_handler</SPAN></TT>
functions should be <TT class="docutils literal"><SPAN class="pre">r</SPAN> <SPAN class="pre">!=</SPAN> <SPAN class="pre">0</SPAN></TT>.</P>
</DIV>
</DIV>
<DIV class="section" id="open-issues">
<H1><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id47" name="open-issues">3&nbsp;&nbsp;&nbsp;Open issues</A></H1>
<UL class="simple">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#how-do-contracts-interact-with-function-try-blocks">How do contracts interact with function-try-blocks?</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#are-failure-handler-functions-wrongly-specified">Are failure handler functions wrongly specified?</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#changes-to-the-standard-library">Changes to the standard library</A></LI>
</UL>
<DIV class="section" id="how-do-contracts-interact-with-function-try-blocks">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id48" name="how-do-contracts-interact-with-function-try-blocks">3.1&nbsp;&nbsp;&nbsp;How do contracts interact with function-try-blocks?</A></H2>
<P>There seems to be at least two solutions:</P>
<OL class="arabic">
<LI><P class="first">Forbid function-try-blocks and contracts on the same function.</P>
</LI>
<LI><P class="first">Allow it as in this example:</P>
<PRE class="literal-block">void foo( int i )
    precondition
    {
        i &gt; 0;
    }
    try
    {
        // ...
    }
    catch( ... )
    {
    }
</PRE>
</LI>
</OL>
<P>In case of 2, then the question would be</P>
<UL class="simple">
<LI>should the try-block catch exceptions from the pre- and postcondition?</LI>
</UL>
</DIV>
<DIV class="section" id="are-failure-handler-functions-wrongly-specified">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id49" name="are-failure-handler-functions-wrongly-specified">3.2&nbsp;&nbsp;&nbsp;Are failure handler functions wrongly specified?</A></H2>
<P>Currently a <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#failure-handler-functions">failure handler function</A> does not
allow one to</P>
<OL class="arabic simple">
<LI>see the context of the broken assertion, or</LI>
<LI>use other functions than free-standing functions.</LI>
</OL>
<P>It might be desirable to change the functions to</P>
<PRE class="literal-block">namespace std
{
    class assertion_context
    {
        contract_context( const char* where, const char* assertion ) throw();
        ~contract_context() throw();
        const char* context() const throw();
    };

    void precondition_broken( const assertion_context&amp; cc );
    // ... etc
}
</PRE>
<P>or even</P>
<PRE class="literal-block">namespace std
{
    extern std::function&lt; void ( const assertion_context&amp; ) &gt; precondition_broken;
    // ... etc
}
</PRE>
<P>This would hopefully ensure good error-messages.</P>
</DIV>
<DIV class="section" id="changes-to-the-standard-library">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id50" name="changes-to-the-standard-library">3.3&nbsp;&nbsp;&nbsp;Changes to the standard library</A></H2>
<P>We suggest that no required changes should be made to
the standard library. An implementation is free to
implement all standard guarantees in terms of contract
code, but not required to.</P>
<P>Another possibility is to require certain contracts 
(in particular preconditions) to
be used in the standard library. This might be a way 
for the committee to guarantee a safer version of the 
standard library to novices.</P>
</DIV>
</DIV>
<DIV class="section" id="major-changes-from-n1669">
<H1><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id51" name="major-changes-from-n1669">4&nbsp;&nbsp;&nbsp;Major changes from </A><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1669.html">n1669</A></H1>
<OL class="arabic">
<LI><P class="first">removed loop invariants</P>
</LI>
<LI><P class="first">reformulated the syntax of <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#static-assertions">static assertions</A></P>
</LI>
<LI><P class="first">reformulated the syntax of <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#runtime-assertions">runtime assertions</A></P>
</LI>
<LI><P class="first">removed rules demanding assertions to be disabled within assertions</P>
</LI>
<LI><P class="first">removed rules demanding invariants to be disabled within public functions</P>
</LI>
<LI><P class="first">changed use of keyword:</P>
<BLOCKQUOTE>
<TABLE border="1" class="docutils">
<COLGROUP>
<COL width="44%">
<COL width="56%">
</COLGROUP>
<TBODY valign="top">
<TR><TD><P class="first last"><STRONG>before</STRONG></P>
</TD>
<TD><P class="first last"><STRONG>now</STRONG></P>
</TD>
</TR>
<TR><TD><P class="first last"><TT class="docutils literal"><SPAN class="pre">std::old()</SPAN></TT></P>
</TD>
<TD><P class="first last"><TT class="docutils literal"><SPAN class="pre">__old</SPAN></TT></P>
</TD>
</TR>
</TBODY>
</TABLE>
</BLOCKQUOTE>
</LI>
</OL>
</DIV>
<DIV class="section" id="list-of-proposals-that-could-affect-or-be-affected-by-this-proposal">
<H1><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id52" name="list-of-proposals-that-could-affect-or-be-affected-by-this-proposal">5&nbsp;&nbsp;&nbsp;List of proposals that could affect or be affected by this proposal</A></H1>
<OL class="arabic simple">
<LI>static assertions as described in <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1617.html">n1617</A></LI>
<LI>concepts as described in <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2003/n1510.pdf">n1510</A>, <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2003/n1522.pdf">n1522</A>, <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2003/n1536.pdf">n1536</A> and <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1758.pdf">n1758</A></LI>
<LI>any proposal that seeks to enhance meta-programming capabilities</LI>
<LI><TT class="docutils literal"><SPAN class="pre">reading()</SPAN></TT> specifications as described in <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1664.pdf">n1664</A></LI>
</OL>
</DIV>
<DIV class="section" id="implementability">
<H1><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id53" name="implementability">6&nbsp;&nbsp;&nbsp;Implementability</A></H1>
<P>We expect that it will take about 3 man months to implement the proposal without
dedicating any time to optimizations.</P>
</DIV>
<DIV class="section" id="list-of-examples">
<H1><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id54" name="list-of-examples">7&nbsp;&nbsp;&nbsp;List of examples</A></H1>
<UL class="simple">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#vector-example-hpp">vector_example.hpp</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#subcontracting-example-hpp">subcontracting_example.hpp</A></LI>
</UL>
<DIV class="section" id="vector-example-hpp">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html#id55" name="vector-example-hpp">7.1&nbsp;&nbsp;&nbsp;vector_example.hpp</A></H2>




<LINK rel="stylesheet" href="./Ottosen2005_Proposal_Rev2-n1773_files/style.css" type="text/css">




<PRE><SPAN class="comment">///////////////////////////////////////
// Tools
///////////////////////////////////////</SPAN>

<SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">Iter</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">T</SPAN> <SPAN class="special">&gt;</SPAN>
<SPAN class="keyword">bool</SPAN> <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">Iter</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">Iter</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
<SPAN class="special">{</SPAN> <SPAN class="comment">/* for simplicity, let us assume T's can be compared */</SPAN> <SPAN class="special">}</SPAN>

<SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">Iter</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">Size</SPAN> <SPAN class="special">&gt;</SPAN>
<SPAN class="keyword">bool</SPAN> <SPAN class="identifier">equal_distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">Iter</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">Iter</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">Size</SPAN> <SPAN class="identifier">size</SPAN> <SPAN class="special">)</SPAN>
<SPAN class="special">{</SPAN> <SPAN class="comment">/* internal tagging mechnism so even input iterators can be passed */</SPAN> <SPAN class="special">}</SPAN>

<SPAN class="comment">///////////////////////////////////////
// New vector interface
///////////////////////////////////////</SPAN>

<SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">Alloc</SPAN> <SPAN class="special">=</SPAN> <SPAN class="identifier">allocator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">T</SPAN><SPAN class="special">&gt;</SPAN> <SPAN class="special">&gt;</SPAN>
<SPAN class="keyword">class</SPAN> <SPAN class="identifier">vector</SPAN> 
<SPAN class="special">{</SPAN>
    <SPAN class="keyword">static</SPAN> <SPAN class="keyword">invariant</SPAN>
    <SPAN class="special">{</SPAN>
        <SPAN class="keyword">static</SPAN> <SPAN class="identifier">is_assignable</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">T</SPAN><SPAN class="special">&gt;::</SPAN><SPAN class="identifier">value</SPAN>         <SPAN class="special">:</SPAN> <SPAN class="string">"value_type must be Assignable"</SPAN> <SPAN class="special">;</SPAN>
        <SPAN class="keyword">static</SPAN> <SPAN class="identifier">is_copy_constructible</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">T</SPAN><SPAN class="special">&gt;::</SPAN><SPAN class="identifier">value</SPAN> <SPAN class="special">:</SPAN> <SPAN class="string">"value_type must be CopyConstructible"</SPAN> <SPAN class="special">;</SPAN>
    <SPAN class="special">}</SPAN>
    
    <SPAN class="keyword">invariant</SPAN>
    <SPAN class="special">{</SPAN>
        <SPAN class="special">(</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="number">0</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN>
        <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">std</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN>
        <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">std</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">rbegin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN>
        <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN>
        <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN>
    <SPAN class="special">}</SPAN>
    
    
<SPAN class="keyword">public</SPAN><SPAN class="special">:</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="identifier">Alloc</SPAN>                             <SPAN class="identifier">allocator_type</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">pointer</SPAN>           <SPAN class="identifier">pointer</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">const_pointer</SPAN>     <SPAN class="identifier">const_pointer</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">reference</SPAN>         <SPAN class="identifier">reference</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">const_reference</SPAN>   <SPAN class="identifier">const_reference</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">value_type</SPAN>        <SPAN class="identifier">value_type</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="special">...</SPAN>                               <SPAN class="identifier">iterator</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="special">...</SPAN>                               <SPAN class="identifier">const_iterator</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="special">...</SPAN>                               <SPAN class="identifier">size_type</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="special">...</SPAN>                               <SPAN class="identifier">difference_type</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="identifier">reverse_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">iterator</SPAN><SPAN class="special">&gt;</SPAN>        <SPAN class="identifier">reverse_iterator</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="identifier">reverse_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">const_iterator</SPAN><SPAN class="special">&gt;</SPAN>  <SPAN class="identifier">const_reverse_iterator</SPAN><SPAN class="special">;</SPAN>

             <SPAN class="identifier">vector</SPAN><SPAN class="special">()</SPAN>                  
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN> 
                 
    <SPAN class="keyword">explicit</SPAN> <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">al</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> 
                                 <SPAN class="identifier">al</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">get_allocator</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
    <SPAN class="keyword">explicit</SPAN> <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">;</SPAN> 
                                 <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">;</SPAN> 
                                 <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">al</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">;</SPAN> 
                                 <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">);</SPAN> 
                                 <SPAN class="identifier">al</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">get_allocator</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}:</SPAN>
             
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">vector</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">right</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">right</SPAN> <SPAN class="special">==</SPAN> <SPAN class="special">*</SPAN><SPAN class="keyword">this</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
    
             <SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="special">&gt;</SPAN>
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="keyword">static</SPAN> <SPAN class="identifier">is_input_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">InIt</SPAN><SPAN class="special">&gt;::</SPAN><SPAN class="identifier">value</SPAN> <SPAN class="special">:</SPAN> <SPAN class="string">"Iterator argument must model an InputIterator"</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">equal_distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="special">&gt;</SPAN>
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">al</SPAN> <SPAN class="special">);</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="keyword">static</SPAN> <SPAN class="identifier">is_input_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">InIt</SPAN><SPAN class="special">&gt;::</SPAN><SPAN class="identifier">value</SPAN> <SPAN class="special">:</SPAN> <SPAN class="string">"Iterator argument must model an InputIterator"</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">equal_distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN> 
                                 <SPAN class="identifier">al</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">get_allocator</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>

             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">reserve</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">()</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_iterator</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">();</SPAN>
             <SPAN class="identifier">const_iterator</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
             
             <SPAN class="identifier">reverse_iterator</SPAN> <SPAN class="identifier">rbegin</SPAN><SPAN class="special">()</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_reverse_iterator</SPAN> <SPAN class="identifier">rbegin</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">reverse_iterator</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">();</SPAN>
             <SPAN class="identifier">const_reverse_iterator</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
             
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">resize</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">newsize</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="comment">// version 1: with an if</SPAN>
                 <SPAN class="special">{</SPAN> 
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">newsize</SPAN><SPAN class="special">;</SPAN> 
                     <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">newsize</SPAN> <SPAN class="special">&gt;</SPAN> <SPAN class="identifier">__old</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN>
                         <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">__old</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN>
                 <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">resize</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">newsize</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">T</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="comment">// version 2: with ternary operator</SPAN>
                 <SPAN class="special">{</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">newsize</SPAN><SPAN class="special">;</SPAN> 
                     <SPAN class="identifier">newsize</SPAN> <SPAN class="special">&gt;</SPAN> <SPAN class="identifier">__oldsize</SPAN><SPAN class="special">())</SPAN> <SPAN class="special">?</SPAN> 
                         <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">__old</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">:</SPAN> <SPAN class="keyword">true</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
         
             <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">bool</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="special">(</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="number">0</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">Alloc</SPAN> <SPAN class="identifier">get_allocator</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
             
             <SPAN class="identifier">reference</SPAN> <SPAN class="identifier">at</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">);</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_reference</SPAN> <SPAN class="identifier">at</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">)</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">reference</SPAN> <SPAN class="keyword">operator</SPAN><SPAN class="special">[](</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>

             <SPAN class="identifier">const_reference</SPAN> <SPAN class="keyword">operator</SPAN><SPAN class="special">[](</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
    
             <SPAN class="identifier">reference</SPAN> <SPAN class="identifier">front</SPAN><SPAN class="special">();</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_reference</SPAN> <SPAN class="identifier">front</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
    
             <SPAN class="identifier">reference</SPAN> <SPAN class="identifier">back</SPAN><SPAN class="special">()</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_reference</SPAN> <SPAN class="identifier">back</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">push_back</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">back</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">val</SPAN><SPAN class="special">;</SPAN> 
                                 <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">__old</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="number">1</SPAN><SPAN class="special">;</SPAN> 
                                 <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">__old</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">pop_back</SPAN><SPAN class="special">()</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">__old</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">-</SPAN> <SPAN class="number">1</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="special">&gt;</SPAN>
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">assign</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  
                 <SPAN class="special">{</SPAN>
                     <SPAN class="keyword">static</SPAN> <SPAN class="identifier">is_input_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">InIt</SPAN><SPAN class="special">&gt;::</SPAN><SPAN class="identifier">value</SPAN> <SPAN class="special">:</SPAN> <SPAN class="string">"Iterator argument must model an InputIterator"</SPAN><SPAN class="special">;</SPAN> 
                     <SPAN class="string">"The range [first,last) is not a sub-range of [begin(),end())"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">equal_distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">assign</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">insert</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">where</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="special">{</SPAN>
                     <SPAN class="special">*</SPAN><SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">val</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN>  <SPAN class="special">==</SPAN> <SPAN class="identifier">__old</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="number">1</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">__old</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN>
                     
                     <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;</SPAN> <SPAN class="identifier">__old</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN>
                         <SPAN class="string">"All iterators have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="keyword">else</SPAN>
                         <SPAN class="string">"All iterators in the range [where,end()) have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">insert</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">where</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> 
                 <SPAN class="special">{</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">__old</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">__old</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN>
                     
                     <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">__old</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN>
                     <SPAN class="special">{</SPAN>
                         <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">__old</SPAN> <SPAN class="identifier">prior</SPAN><SPAN class="special">(</SPAN><SPAN class="identifier">where</SPAN><SPAN class="special">),</SPAN> <SPAN class="identifier">__old</SPAN> <SPAN class="identifier">prior</SPAN><SPAN class="special">(</SPAN><SPAN class="identifier">where</SPAN><SPAN class="special">)</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">);</SPAN>
                         <SPAN class="string">"All iterators in the range [where,end()) have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="special">}</SPAN>
                     <SPAN class="keyword">else</SPAN>
                         <SPAN class="string">"All iterators have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
                 
             <SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="special">&gt;</SPAN>
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">insert</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">where</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  
                 <SPAN class="special">{</SPAN> 
                     <SPAN class="keyword">static</SPAN> <SPAN class="identifier">is_input_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">InIt</SPAN><SPAN class="special">&gt;::</SPAN><SPAN class="identifier">value</SPAN> <SPAN class="special">:</SPAN> <SPAN class="string">"Iterator argument must model an InputIterator"</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="string">"The range [first,last) is not a sub-range of [begin(),end())"</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> 
                 <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN>
                 <SPAN class="special">{</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">__old</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">__old</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN>
        
                     <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">__old</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN>
                     <SPAN class="special">{</SPAN>
                         </PRE></DIV></DIV></DIV></BODY></HTML>