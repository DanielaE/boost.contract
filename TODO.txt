
IMPLEMENTATION -----------------------------------------------------------------

*   Add a config macro to define the Boost.MPL sequence to use to hold bases.
    By default this should be boost::mpl::vector (because more efficient), but
    it could be #defined to boost::mpl::list by users in case vector's max size
    limit is hit (mpl::vector has a max size, while mpl::list does not, but
    mpl::list usually compiles slower than mpl::vector).

*   Should C++11 move preserve class invariants at exit and/or on throw?
    *   If not, how I can program C++11 move operations with the lib? (If I user
        boost::contract::function then I don't check inv at entry...)

->  Volatile members and class invariants.

*   Disable pre, post, and/or entry/exit inv (all combinations).

->  Deep-search functions to override in base_types.
    *   And compiler-error if public_function<override...> does not find any
        function to actually override.

*   Can I use unique_ptr instead of shared_ptr for old values, and maybe also
    for contract variables internal to the library, etc... ?

*   What shall I do with unions... can/shall I contract them? Check-out which
    members C++11 unions can have (ctors, dtor, etc.).

->  Make work the case a pure virtual uses boost::optional<T> result but an
    overriding function uses just T result, and the other way around too.

*   What happens to OLDOF and related assertions if old-of expression type T
    does not have a copy constructor?
    *   In this case OLDOF (and old) could just skip the copy leaving the
        pointer to be null. Then programmers could check if the old-value
        pointer is null so skip evaluating its assertion in postconditions...
        this seems a simple and elegant solution (without having to use
        call_if, bind, etc. here).
    *   C++11 std::is_copy_constructible could be used, but maybe still be
        wrapped within a boost::contract::has_oldof trait so to work on C++03
        via user specializations...
    *   Hhmmm... but this will not allow programmers to force compilation to
        fail in case the old value expr is not copyable... that's not good
        then... but maybe in these cases users can just
        BOOST_STATIC_ASSERT(has_oldof<???>).

*   Library data (already checking guard, failure handlers, etc.).
    *   Move in src/ files (also re-design impl to move as much code as possible
        (i.e., min templates) to src/ for faster compile-times.
    *   Thread safety (of lib's data if THREAD_SAFE #defined).

->  If an overriding functions does not specify preconditions, make sure the
    overridden preconditions are checked (and not that subcontracted
    preconditions always pass just because the overriding function does not
    specify them).

TESTING ------------------------------------------------------------------------

*   Use MSVC 2013 (instead of MSVC 2010)
    *   I should be able to use lambdas also in ctor templates member inits...
    *   Add a note about this MSVC 2010 bug in the docs.

*   Result by ref so never copied (not even when boost::optional).

*   Failure handlers and throw on contract failure (non-contract exception).
    *   Add a test for throwing exception handlers (somewhat similar to
        stroustrup97/string.cpp but more comprehensive).
    *   Test what happens if bodies throw (e.g., public func should check inv,
        dtor too, but ctor not, etc.)... test all contract types when bodies
        throw.
    *   Test what happens if old expr throws (with and without .old(...)).

*   Test subcontracting when:
    *   Overridden missing pre and/or post and/or inv.
    *   Overridden missing from direct parent, but found in grand parent.

*   Contracts disabled while checking contracts.
    *   Add a test to disable/ similar to n1962/factorial.cpp, where the
        contract recursively calls the function itself in the assertions.
    *   Add a config macro to disable no assertion during preconditions (to
        avoid passing unchecked argument to function body...).

*   Overloading for all contracts.
    *   Test subcontracting of overloaded virtual (overload both overridden and
        overriding functions).

*   No static inv / const inv / volatile inv checked when static_inv /
    inv const / inv const volatile func not defined (for ctor, dtor, and
    public functions)

*   Derived public function override base protected virtual function (subst
    princ does not apply here because base protected virtual cannot be called
    by users so it cannot be "substituted")... what will this lib do?

*   Test function and array argument types like:
    `void f(int x[2][3], int (*g)(int))`

*   Test there's never ambiguity among the overloaded public_function APIs
    (e.g., between public_function(v, func_ptr, this) and
    public_function<O>(v, &a::f, this), etc.).

DOCS ---------------------------------------------------------------------------

*   Add a comment to the docs that for multi-threading, a recursive (for
    virtual calls?) scoped lock can appear before contract code.

*   Look at Andrzej's discussion on preconditions:
    https://akrzemi1.wordpress.com/2013/01/04/preconditions-part-i/

*   pre > old > post all optional, but when specified must be specified in that
    order (rationale, this makes contract code more readable and simplify lib
    impl.)

*   Using .old(...) copies old values before body but after entry checks of inv
    and pre (more correct), plus it calls post_broken_handler in case old copy
    throws (also more correct). However, if .old(...) more correct, in practise
    init old directly at function entry above contract should be OK most of the
    times.

