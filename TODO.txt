
/** @todo[LC] Add tests to verify that const mem fun body cannot change obj 
state (compiler error) while non-const mem fun body can. */

/** @todo[LC] Make sure DBC library complies with STL exceptions safety rules
(detructors don't throw, etc) -- read from C++ book. There is also a discussion
of exception safety and invariant checking in Str97! */

/** @todo[LC] Shall self be available in constructor preconditions?
Maybe not because technicall there's no object before exec of constrcutor body
(and for example inv was not verified yet so using self of an obj on which inv
is not checked could lead to strange errors and contract violation). However, 
then constrcutor preconditions will not be able to call mem functions 
(using self.some_function())... is this too much of a limitation to enforce?
What does Eiffel do? Can you call object features from object's constructor
preconditions? */

/** @todo[LC] Does "virtual inline" mean anything? Check in Str97 and remove it
from fun.hpp in case it does not mean anything... */

/** @todo[LC] I have seen GCC internal segfaul error if DBC_CONFIG_MAX_ARGC is
more than 3 some some of the DBC++ test programs... I wonder is the compiler 
gets confused by fun<...> instead of fun0, fun1, ... (maybe the template
specialization with partial default argument is not properly supported...). */

/** @todo[LC] Add all @file w/ copyright info -- see what Boost copyright text
says... Add reference to book from which examples where taken to all example
doc comments. */

/** @todo[LC] Create a test for copyable where both class and args are declared
copyable and not. */

/** @todo[LC] Write a test for required(). */

/** @todo[LC] When invoking parent's function directly from overriden function,
must use DBC_BODY() to avoid infinite recursive checking of contract. See
NameList example.
@code
    struct B DBC_INHERIT_OBJECT(B) {
        virtual void f() DBC_MEM_FUN(..., {})
        ...
    };
    struct D: public B DBC_TRAILING_OJECT(D) {
        virtual void f() DBC_MEM_FUN(..., { B::DBC_BODY(f)(); })
        // This instead, will cause infinite contract checking recursion.
        virtual void f() DBC_MEM_FUN(..., { B::f(); })
        ...
    };
#endcode
This is quite annoying as a small developper error in omitting DBC_BODY() in 
this context will result in a infinite recursion a run-time!!! Can I avoid this
somehow??? Can I check it a compile-time? Can I make it work even if calling 
w/out DBC_BODY()? Also, what happens if the body function is not declared 
virtual but only the actual function is declared virtual?
More in general than above todo, how shall DbC handle recursion?
Shall contract checking always be disabled when a function recursively invokes
itself? Maybe not, since it might invoke itself w/ different arguments and w/
obj in a different state (is it is not a const mem fun)... What is Eiffel
policy on DbC and recursion? */

/** @todo[LC] When constrcutor contract is delegated to init() initializer, the
contract does not show up in Doxygen... that is because constr (which are 
public) have no contract, while init() has the contract but it is private...
is there a way around this? Since Doxygen reports the header files, the contract
code (for init() also) is in the reported header but that's not ideal... It'd be
nice if I could say in the Doxyfile to report init() (and del()) doc even if
they are private... */

/** @todo[LC] Make library thread-safe if DBC_THREADING is #define.
In this case: DbC++ will also require Boost.Threading. sync_<> must have mutex.
dbc_global_checking_ must have a mutex. Exectuiong inv+require+body+inv+ensure
must be atomic (sync'd by a mutex) so that effectivelly only 1 operation at the
time for class can be exec among the operations w/ contracts. Consider impl
waiting pre/post conditions. What would this do to performances? This will add
quite a bit on sync at the class level but also at a global level via
dbc_global_checking_... */

/** @todo[LC] Can I use Boost.MPL none and/or void to get rid of dbc::none_? */

/** @todo[LC] Fix all Boost.MPL static assertions in dbc::fun<>. Do I need to
add any more static assertions? */

